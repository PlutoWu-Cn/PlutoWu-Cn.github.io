<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>PlutoWu的个人博客</title>
  
  <subtitle>Programming | Photography | Film</subtitle>
  <link href="http://plutowu.top/atom.xml" rel="self"/>
  
  <link href="http://plutowu.top/"/>
  <updated>2021-03-11T11:42:53.000Z</updated>
  <id>http://plutowu.top/</id>
  
  <author>
    <name>Shiyuan Wu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java后端面试笔记-算法</title>
    <link href="http://plutowu.top/2021/03/11/Java%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95/"/>
    <id>http://plutowu.top/2021/03/11/Java%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95/</id>
    <published>2021-03-11T10:19:59.000Z</published>
    <updated>2021-03-11T11:42:53.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="算法篇"><a href="#算法篇" class="headerlink" title="算法篇"></a>算法篇</h1><h2 id="001-反转链表-Easy"><a href="#001-反转链表-Easy" class="headerlink" title="001 反转链表 (Easy)"></a>001 反转链表 (Easy)</h2><p>定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。</p><p><strong>示例:</strong></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>-&gt;NULL</span><br><span class="line">输出: <span class="number">5</span>-&gt;<span class="number">4</span>-&gt;<span class="number">3</span>-&gt;<span class="number">2</span>-&gt;<span class="number">1</span>-&gt;NULL</span><br></pre></td></tr></table></figure><p><strong>限制：</strong></p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">0 </span>&lt;= 节点个数 &lt;= <span class="number">5000</span></span><br></pre></td></tr></table></figure><h3 id="解法一-栈"><a href="#解法一-栈" class="headerlink" title="解法一 栈"></a>解法一 栈</h3><p>最简单的一种方式就是使用栈，因为栈是先进后出的。实现原理就是把链表节点一个个入栈，当全部入栈完之后再一个个出栈，出栈的时候在把出栈的结点串成一个新的链表。原理如下</p><p><img src="https://plutowu-blogimgs.oss-cn-guangzhou.aliyuncs.com/img/343fd7cce80394422565b4beef398236832cc9ae0f77a85ebceacebe214785af-image.png" alt="image.png"></p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    Stack&lt;ListNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="comment">//把链表节点全部摘掉放到栈中</span></span><br><span class="line">    <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">        stack.push(head);</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (stack.isEmpty())</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    ListNode node = stack.pop();</span><br><span class="line">    ListNode dummy = node;</span><br><span class="line">    <span class="comment">//栈中的结点全部出栈，然后重新连成一个新的链表</span></span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">        ListNode tempNode = stack.pop();</span><br><span class="line">        node.next = tempNode;</span><br><span class="line">        node = node.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//最后一个结点就是反转前的头结点，一定要让他的next</span></span><br><span class="line">    <span class="comment">//等于空，否则会构成环</span></span><br><span class="line">    node.next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> dummy;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解法二-双指针迭代"><a href="#解法二-双指针迭代" class="headerlink" title="解法二 双指针迭代"></a>解法二 双指针迭代</h3><p>我们可以申请两个指针，第一个指针叫 pre，最初是指向 null 的。<br>第二个指针 cur 指向 head，然后不断遍历 cur。<br>每次迭代到 cur，都将 cur 的 next 指向 pre，然后 pre 和 cur 前进一位。<br>都迭代完了(cur 变成 null 了)，pre 就是最后一个节点了。<br>动画演示如下：</p><p><img src="https://pic.leetcode-cn.com/7d8712af4fbb870537607b1dd95d66c248eb178db4319919c32d9304ee85b602-%E8%BF%AD%E4%BB%A3.gif" alt="迭代.gif"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line"><span class="comment">//申请节点，pre和 cur，pre指向null</span></span><br><span class="line">ListNode pre = <span class="keyword">null</span>;</span><br><span class="line">ListNode cur = head;</span><br><span class="line">ListNode tmp = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">while</span>(cur!=<span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">//记录当前节点的下一个节点</span></span><br><span class="line">tmp = cur.next;</span><br><span class="line"><span class="comment">//然后将当前节点指向pre</span></span><br><span class="line">cur.next = pre;</span><br><span class="line"><span class="comment">//pre和cur节点都前进一位</span></span><br><span class="line">pre = cur;</span><br><span class="line">cur = tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解法三-递归"><a href="#解法三-递归" class="headerlink" title="解法三 递归"></a>解法三 递归</h3><p>递归的两个条件：</p><p>终止条件是当前节点或者下一个节点==null<br>在函数内部，改变节点的指向，也就是 head 的下一个节点指向 head 递归函数那句</p><p>head.next.next = head<br>很不好理解，其实就是 head 的下一个节点指向head。<br>递归函数中每次返回的 cur 其实只最后一个节点，在递归函数内部，改变的是当前节点的指向。<br>动画演示如下：</p><p><img src="https://pic.leetcode-cn.com/dacd1bf55dec5c8b38d0904f26e472e2024fc8bee4ea46e3aa676f340ba1eb9d-%E9%80%92%E5%BD%92.gif" alt="递归.gif"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line"><span class="comment">//递归终止条件是当前为空，或者下一个节点为空</span></span><br><span class="line"><span class="keyword">if</span>(head==<span class="keyword">null</span> || head.next==<span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这里的cur就是最后一个节点</span></span><br><span class="line">ListNode cur = reverseList(head.next);</span><br><span class="line"><span class="comment">//这里请配合动画演示理解</span></span><br><span class="line"><span class="comment">//如果链表是 1-&gt;2-&gt;3-&gt;4-&gt;5，那么此时的cur就是5</span></span><br><span class="line"><span class="comment">//而head是4，head的下一个是5，下下一个是空</span></span><br><span class="line"><span class="comment">//所以head.next.next 就是5-&gt;4</span></span><br><span class="line">head.next.next = head;</span><br><span class="line"><span class="comment">//防止链表循环，需要将head.next设置为空</span></span><br><span class="line">head.next = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">//每层递归函数都返回cur，也就是最后一个节点</span></span><br><span class="line"><span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="002-二叉树转双向链表-Medium"><a href="#002-二叉树转双向链表-Medium" class="headerlink" title="002 二叉树转双向链表 (Medium)"></a>002 二叉树转双向链表 (Medium)</h2><p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。</p><p>为了让您更好地理解问题，以下面的二叉搜索树为例：</p><p><img src="https://plutowu-blogimgs.oss-cn-guangzhou.aliyuncs.com/img/bstdlloriginalbst.png" alt="img"></p><p>我们希望将这个二叉搜索树转化为双向循环链表。链表中的每个节点都有一个前驱和后继指针。对于双向循环链表，第一个节点的前驱是最后一个节点，最后一个节点的后继是第一个节点。</p><p>下图展示了上面的二叉搜索树转化成的链表。“head” 表示指向链表中有最小元素的节点。</p><p><img src="https://plutowu-blogimgs.oss-cn-guangzhou.aliyuncs.com/img/bstdllreturndll.png" alt="img"></p><p>特别地，我们希望可以就地完成转换操作。当转化完成以后，树中节点的左指针需要指向前驱，树中节点的右指针需要指向后继。还需要返回链表中的第一个节点的指针。</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>本文解法基于性质：二叉搜索树的中序遍历为 <strong>递增序列</strong> 。<br>将 二叉搜索树 转换成一个 “排序的循环双向链表” ，其中包含三个要素：</p><ol><li><strong>排序链表</strong>： 节点应从小到大排序，因此应使用 <strong>中序遍历</strong> “从小到大”访问树的节点。</li><li><strong>双向链表</strong>： 在构建相邻节点的引用关系时，设前驱节点 <code>pre</code> 和当前节点 <code>cur</code> ，不仅应构建 <code>pre.right = cur</code> ，也应构建 <code>cur.left = pre</code> 。</li><li><strong>循环链表</strong>： 设链表头节点 <code>head</code> 和尾节点 <code>tail</code> ，则应构建 <code>head.left = tail</code> 和 <code>tail.right = head</code> 。</li></ol><p><img src="https://plutowu-blogimgs.oss-cn-guangzhou.aliyuncs.com/img/1599401091-PKIjds-Picture1.png" alt="Picture1.png"></p><p><strong>中序遍历</strong> 为对二叉树作 “左、根、右” 顺序遍历，递归实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打印中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    dfs(root.left); <span class="comment">// 左</span></span><br><span class="line">    System.out.println(root.val); <span class="comment">// 根</span></span><br><span class="line">    dfs(root.right); <span class="comment">// 右</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据以上分析，考虑使用中序遍历访问树的各节点 <code>cur</code> ；并在访问每个节点时构建 <code>cur</code> 和前驱节点 <code>pre</code> 的引用指向；中序遍历完成后，最后构建头节点和尾节点的引用指向即可。</p><h3 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h3><p><code>dfs(cur)</code>: 递归法中序遍历；</p><ol><li><p><strong>终止条件：</strong> 当节点 <code>cur</code> 为空，代表越过叶节点，直接返回；</p></li><li><p>递归左子树，即 <code>dfs(cur.left)</code> ；</p></li><li><p>构建链表：</p><ul><li>当 <code>pre</code> 为空时： 代表正在访问链表头节点，记为 <code>head</code> ；</li><li>当 <code>pre</code> 不为空时： 修改双向节点引用，即 <code>pre.right = cur</code> ， <code>cur.left = pre</code> ；</li><li>保存 <code>cur</code> ： 更新 <code>pre = cur</code> ，即节点 <code>cur</code> 是后继节点的 <code>pre</code> ；</li></ul></li><li><p>递归右子树，即 <code>dfs(cur.right)</code> ；</p></li></ol><p><code>treeToDoublyList(root)：</code></p><ol><li><strong>特例处理：</strong> 若节点 <code>root</code> 为空，则直接返回；</li><li><strong>初始化：</strong> 空节点 <code>pre</code> ；</li><li><strong>转化为双向链表：</strong> 调用 <code>dfs(root)</code> ；</li><li><strong>构建循环链表：</strong> 中序遍历完成后，<code>head</code> 指向头节点， <code>pre</code> 指向尾节点，因此修改<code>head</code>和<code> pre</code> 的双向节点引用即可；</li><li><strong>返回值：</strong> 返回链表的头节点 <code>head</code> 即可；</li></ol><p><strong>复杂度分析：</strong></p><ul><li><strong>时间复杂度 O(N) ：</strong> N 为二叉树的节点数，中序遍历需要访问所有节点。</li><li><strong>空间复杂度 O(N) ：</strong> 最差情况下，即树退化为链表时，递归深度达到 N，系统使用 O(N) 栈空间。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Node pre, head;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">treeToDoublyList</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        dfs(root);</span><br><span class="line">        head.left = pre;</span><br><span class="line">        pre.right = head;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(Node cur)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        dfs(cur.left);</span><br><span class="line">        <span class="keyword">if</span>(pre != <span class="keyword">null</span>) pre.right = cur;</span><br><span class="line">        <span class="keyword">else</span> head = cur;</span><br><span class="line">        cur.left = pre;</span><br><span class="line">        pre = cur;</span><br><span class="line">        dfs(cur.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="003-最长回文子串-Medium"><a href="#003-最长回文子串-Medium" class="headerlink" title="003 最长回文子串 (Medium)"></a>003 最长回文子串 (Medium)</h2><p>给你一个字符串 s，找到 s 中最长的回文子串。</p><p><strong>示例 1：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">s</span> = <span class="string">&quot;babad&quot;</span></span><br><span class="line">输出：<span class="string">&quot;bab&quot;</span></span><br><span class="line">解释：<span class="string">&quot;aba&quot;</span> 同样是符合题意的答案。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">s</span> = <span class="string">&quot;cbbd&quot;</span></span><br><span class="line">输出：<span class="string">&quot;bb&quot;</span></span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight smalltalk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="comment">&quot;a&quot;</span></span><br><span class="line">输出：<span class="comment">&quot;a&quot;</span></span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">s</span> = <span class="string">&quot;ac&quot;</span></span><br><span class="line">输出：<span class="string">&quot;a&quot;</span></span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 1000</code></li><li><code>s</code> 仅由数字和英文字母（大写和/或小写）组成</li></ul><h3 id="方法一：暴力匹配-（Brute-Force）"><a href="#方法一：暴力匹配-（Brute-Force）" class="headerlink" title="方法一：暴力匹配 （Brute Force）"></a>方法一：暴力匹配 （Brute Force）</h3><ul><li>根据回文子串的定义，枚举所有长度大于等于 22 的子串，依次判断它们是否是回文；</li><li>在具体实现时，可以只针对大于“当前得到的最长回文子串长度”的子串进行“回文验证”；</li><li>在记录最长回文子串的时候，可以只记录“当前子串的起始位置”和“子串长度”，不必做截取。这一步我们放在后面的方法中实现。</li></ul><p>说明：暴力解法时间复杂度高，但是思路清晰、编写简单。由于编写正确性的可能性很大，<strong>可以使用暴力匹配算法检验我们编写的其它算法是否正确</strong>。优化的解法在很多时候，是基于“暴力解法”，以空间换时间得到的，因此思考清楚暴力解法，分析其缺点，很多时候能为我们打开思路。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">if</span> (len &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> begin = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// s.charAt(i) 每次都会检查数组下标越界，因此先转换成字符数组</span></span><br><span class="line">        <span class="keyword">char</span>[] charArray = s.toCharArray();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 枚举所有长度大于 1 的子串 charArray[i..j]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; len; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j - i + <span class="number">1</span> &gt; maxLen &amp;&amp; validPalindromic(charArray, i, j)) &#123;</span><br><span class="line">                    maxLen = j - i + <span class="number">1</span>;</span><br><span class="line">                    begin = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(begin, begin + maxLen);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 验证子串 s[left..right] 是否为回文串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">validPalindromic</span><span class="params">(<span class="keyword">char</span>[] charArray, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (charArray[left] != charArray[right]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复杂度分析：</p><ul><li>时间复杂度：O(N<sup>3</sup>)，这里 N 是字符串的长度，枚举字符串的左边界、右边界，然后继续验证子串是否是回文子串，这三种操作都与 N 相关；</li><li>空间复杂度：O(1)，只使用到常数个临时变量，与字符串长度无关。</li></ul><h3 id="方法二：动态规划"><a href="#方法二：动态规划" class="headerlink" title="方法二：动态规划"></a>方法二：动态规划</h3><p>事实上，「回文」天然具有「状态转移」性质。</p><ul><li>一个回文去掉两头以后，剩下的部分依然是回文（这里暂不讨论边界情况）；</li></ul><p>依然从回文串的定义展开讨论：</p><ul><li>如果一个字符串的头尾两个字符都不相等，那么这个字符串一定不是回文串；</li><li>如果一个字符串的头尾两个字符相等，才有必要继续判断下去。<ul><li>如果里面的子串是回文，整体就是回文串；</li><li>如果里面的子串不是回文串，整体就不是回文串。</li></ul></li></ul><p>即：<strong>在头尾字符相等的情况下，里面子串的回文性质据定了整个子串的回文性质</strong>，这就是状态转移。因此可以把「状态」定义为原字符串的一个子串是否为回文子串。</p><h4 id="第-1-步：定义状态"><a href="#第-1-步：定义状态" class="headerlink" title="第 1 步：定义状态"></a><strong>第 1 步：定义状态</strong></h4><p><code>dp[i][j]</code> 表示子串 <code>s[i..j]</code> 是否为回文子串，这里子串 <code>s[i..j]</code> 定义为左闭右闭区间，可以取到 <code>s[i]</code> 和 <code>s[j]</code>。</p><h4 id="第-2-步：思考状态转移方程"><a href="#第-2-步：思考状态转移方程" class="headerlink" title="第 2 步：思考状态转移方程"></a><strong>第 2 步：思考状态转移方程</strong></h4><p>在这一步分类讨论（根据头尾字符是否相等），根据上面的分析得到：</p><p><code>dp[i][j] = (s[i] == s[j]) and dp[i + 1][j - 1]</code><br>说明：</p><ul><li>「动态规划」事实上是在填一张二维表格，由于构成子串，因此 <code>i</code> 和 <code>j</code> 的关系是 <code>i &lt;= j</code> ，因此，只需要填这张表格对角线以上的部分。</li><li>看到 <code>dp[i + 1][j - 1]</code> 就得考虑边界情况。</li></ul><p>边界条件是：表达式 <code>[i + 1, j - 1]</code> 不构成区间，即长度严格小于 <code>2</code>，即 <code>j - 1 - (i + 1) + 1 &lt; 2</code> ，整理得 <code>j - i &lt; 3</code>。</p><p>这个结论很显然：<code>j - i &lt; 3</code> 等价于 <code>j - i + 1 &lt; 4</code>，即当子串 <code>s[i..j]</code> 的长度等于 <code>2</code> 或者等于 <code>3</code> 的时候，其实只需要判断一下头尾两个字符是否相等就可以直接下结论了。</p><ul><li>如果子串 <code>s[i + 1..j - 1]</code> 只有 1 个字符，即去掉两头，剩下中间部分只有 1 个字符，显然是回文；</li><li>如果子串 <code>s[i + 1..j - 1]</code> 为空串，那么子串 <code>s[i, j]</code> 一定是回文子串。</li></ul><p>因此，在 <code>s[i] == s[j]</code> 成立和 <code>j - i &lt; 3</code> 的前提下，直接可以下结论，<code>dp[i][j] = true</code>，否则才执行状态转移。</p><h4 id="第-3-步：考虑初始化"><a href="#第-3-步：考虑初始化" class="headerlink" title="第 3 步：考虑初始化"></a><strong>第 3 步：考虑初始化</strong></h4><p>初始化的时候，单个字符一定是回文串，因此把对角线先初始化为 <code>true</code>，即 <code>dp[i][i] = true</code> 。</p><p>事实上，初始化的部分都可以省去。因为只有一个字符的时候一定是回文，<code>dp[i][i]</code> 根本不会被其它状态值所参考。</p><h4 id="第-4-步：考虑输出"><a href="#第-4-步：考虑输出" class="headerlink" title="第 4 步：考虑输出"></a><strong>第 4 步：考虑输出</strong></h4><p>只要一得到 <code>dp[i][j] = true</code>，就记录子串的长度和起始位置，没有必要截取，这是因为截取字符串也要消耗性能，记录此时的回文子串的「起始位置」和「回文长度」即可。</p><h4 id="第-5-步：考虑优化空间"><a href="#第-5-步：考虑优化空间" class="headerlink" title="第 5 步：考虑优化空间"></a><strong>第 5 步：考虑优化空间</strong></h4><p>因为在填表的过程中，只参考了左下方的数值。事实上可以优化，但是增加了代码编写和理解的难度，丢失可读和可解释性。在这里不优化空间。</p><p>注意事项：总是先得到小子串的回文判定，然后大子串才能参考小子串的判断结果，即填表顺序很重要。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 特判</span></span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">if</span> (len &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> begin = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// dp[i][j] 表示 s[i, j] 是否是回文串</span></span><br><span class="line">        <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[len][len];</span><br><span class="line">        <span class="keyword">char</span>[] charArray = s.toCharArray();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            dp[i][i] = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; len; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; j; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (charArray[i] != charArray[j]) &#123;</span><br><span class="line">                    dp[i][j] = <span class="keyword">false</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (j - i &lt; <span class="number">3</span>) &#123;</span><br><span class="line">                        dp[i][j] = <span class="keyword">true</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 只要 dp[i][j] == true 成立，就表示子串 s[i..j] 是回文，此时记录回文长度和起始位置</span></span><br><span class="line">                <span class="keyword">if</span> (dp[i][j] &amp;&amp; j - i + <span class="number">1</span> &gt; maxLen) &#123;</span><br><span class="line">                    maxLen = j - i + <span class="number">1</span>;</span><br><span class="line">                    begin = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(begin, begin + maxLen);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复杂度分析：</p><p>时间复杂度：O(N<sup>2</sup>)。<br>空间复杂度：O(N<sup>2</sup>)，二维 dp 问题，一个状态得用二维有序数对表示，因此空间复杂度是 O(N<sup>2</sup>)。</p><p>下面分别展示了错误的填表顺序和正确的填表顺序，以便大家理解动态规划要满足「无后效性」的意思。</p><p>说明：表格中的数字表示「填表顺序」，从 1 开始。表格外的箭头和数字也表示「填表顺序」，与表格中的数字含义一致。</p><p><img src="https://plutowu-blogimgs.oss-cn-guangzhou.aliyuncs.com/img/4a24bbe4e55421f4f7d199b14e961eff792146092dd9a0c18cf06c824728407c-image.png" alt="image.png"></p><p><img src="https://plutowu-blogimgs.oss-cn-guangzhou.aliyuncs.com/img/7e9d1f1dbe2095b0609233faa03b224ab32adf832515de1ce15b496f2cbdf0ab-image.png" alt="image.png"></p><p>下面这段代码只有内层循环和上文代码1.0不同，已经标注在注释中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">if</span> (len &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[len][len];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            Arrays.fill(dp[i], <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            dp[i][i] = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span>[] charArray = s.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; len; j++) &#123;</span><br><span class="line">            <span class="comment">// 只有下面这一行和代码1.0不同，i 正着写、倒过来写都行，因为子串都有参考值</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = j - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (charArray[i] == charArray[j]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (j - i &lt; <span class="number">3</span>) &#123;</span><br><span class="line">                        dp[i][j] = <span class="keyword">true</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 只要 dp[i][j] == true 成立，就表示子串 s[i, j] 是回文，此时记录回文长度和起始位置</span></span><br><span class="line">                <span class="keyword">if</span> (dp[i][j]) &#123;</span><br><span class="line">                    <span class="keyword">int</span> curLen = j - i + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span> (curLen &gt; maxLen) &#123;</span><br><span class="line">                        maxLen = curLen;</span><br><span class="line">                        start = i;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(start, start + maxLen);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>我们看到，用「动态规划」方法解决问题，有的时候并不是直接面向问题的。</li><li>「动态规划」依然是「空间换时间」思想的体现，并且本身「动态规划」作为一种打表格法，就是在用「空间」换「时间」。</li></ul><p>关于「动态规划」方法执行时间慢的说明：</p><ul><li>动态规划本质上还是「暴力解法」，因为需要枚举左右边界，有 O(N<sup>2</sup>)这么多；</li><li>以下提供的「中心扩散法」枚举了所有可能的回文子串的中心，有 O(2N)这么多，不在一个级别上。</li></ul><p>上面采用了时间复杂度估算的表示，O(N<sup>2</sup>)表示最高项是 aN<sup>2</sup>的多项式。</p><p>从这个问题我们也可以看出，虽然时间复杂度一样，但是实际执行时间有可能是有差距的，并且时间复杂度是一个估算，没有必要计算得很清楚，这是因为真正的运行时间还和很多因素有关：例如所运行机器的环境，测试用例等。</p><h3 id="方法三：-中心扩散"><a href="#方法三：-中心扩散" class="headerlink" title="方法三： 中心扩散"></a>方法三： 中心扩散</h3><p>暴力法采用双指针两边夹，验证是否是回文子串。</p><p>除了枚举字符串的左右边界以外，比较容易想到的是<strong>枚举可能出现的回文子串的“中心位置”，从“中心位置”尝试尽可能扩散出去，得到一个回文串</strong>。</p><p>因此中心扩散法的思路是：遍历每一个索引，以这个索引为中心，利用“回文串”中心对称的特点，往两边扩散，看最多能扩散多远。</p><p>枚举“中心位置”时间复杂度为 O(N)，从“中心位置”扩散得到“回文子串”的时间复杂度为 O(N)，因此时间复杂度可以降到 O(N<sup>2</sup>)。</p><p>在这里要注意一个细节：回文串在长度为奇数和偶数的时候，“回文中心”的形式是不一样的。</p><ul><li>奇数回文串的“中心”是一个具体的字符，例如：回文串 <code>&quot;aba&quot;</code> 的中心是字符 <code>&quot;b&quot;</code>；</li><li>偶数回文串的“中心”是位于中间的两个字符的“空隙”，例如：回文串串 <code>&quot;abba&quot;</code> 的中心是两个 <code>&quot;b&quot;</code> 中间的那个“空隙”。</li></ul><p><img src="https://plutowu-blogimgs.oss-cn-guangzhou.aliyuncs.com/img/572db4731d6a0e32ee9c14773ed476068bebb88883335bc7415cb0b43762303a.jpg" alt="图 1 ：奇数回文串与偶数回文串"></p><p>我们看一下一个字符串可能的回文子串的中心在哪里？</p><p><img src="https://plutowu-blogimgs.oss-cn-guangzhou.aliyuncs.com/img/3c4ca880f2dd7463e15ddf7bbd59e2f7d11434b7dbc69b55893660012726ee88.jpg" alt="图 2：枚举可能的所有回文中心"></p><p>我们可以设计一个方法，兼容以上两种情况：</p><ol><li>如果传入重合的索引编码，进行中心扩散，此时得到的回文子串的长度是奇数；</li><li>如果传入相邻的索引编码，进行中心扩散，此时得到的回文子串的长度是偶数。</li></ol><p>具体编码细节在以下的代码的注释中体现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">if</span> (len &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">1</span>;</span><br><span class="line">        String res = s.substring(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 中心位置枚举到 len - 2 即可</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            String oddStr = centerSpread(s, i, i);</span><br><span class="line">            String evenStr = centerSpread(s, i, i + <span class="number">1</span>);</span><br><span class="line">            String maxLenStr = oddStr.length() &gt; evenStr.length() ? oddStr : evenStr;</span><br><span class="line">            <span class="keyword">if</span> (maxLenStr.length() &gt; maxLen) &#123;</span><br><span class="line">                maxLen = maxLenStr.length();</span><br><span class="line">                res = maxLenStr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">centerSpread</span><span class="params">(String s, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// left = right 的时候，此时回文中心是一个字符，回文串的长度是奇数</span></span><br><span class="line">        <span class="comment">// right = left + 1 的时候，此时回文中心是一个空隙，回文串的长度是偶数</span></span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">int</span> i = left;</span><br><span class="line">        <span class="keyword">int</span> j = right;</span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; j &lt; len) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == s.charAt(j)) &#123;</span><br><span class="line">                i--;</span><br><span class="line">                j++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这里要小心，跳出 while 循环时，恰好满足 s.charAt(i) != s.charAt(j)，因此不能取 i，不能取 j</span></span><br><span class="line">        <span class="keyword">return</span> s.substring(i + <span class="number">1</span>, j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：O(N<sup>2</sup>)，理由已经叙述。</li><li>空间复杂度：O(1)，只使用到常数个临时变量，与字符串长度无关。</li></ul><p>事实上，还有时间复杂度更优的算法，是由计算机科学家 Manacher 发明的。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;算法篇&quot;&gt;&lt;a href=&quot;#算法篇&quot; class=&quot;headerlink&quot; title=&quot;算法篇&quot;&gt;&lt;/a&gt;算法篇&lt;/h1&gt;&lt;h2 id=&quot;001-反转链表-Easy&quot;&gt;&lt;a href=&quot;#001-反转链表-Easy&quot; class=&quot;headerlink&quot; title=&quot;001 反转链表 (Easy)&quot;&gt;&lt;/a&gt;001 反转链表 (Easy)&lt;/h2&gt;&lt;p&gt;定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例:&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight angelscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;-&amp;gt;&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;-&amp;gt;&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;-&amp;gt;&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;-&amp;gt;&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;-&amp;gt;NULL&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;-&amp;gt;&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;-&amp;gt;&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;-&amp;gt;&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;-&amp;gt;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;-&amp;gt;NULL&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;限制：&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight basic&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;symbol&quot;&gt;0 &lt;/span&gt;&amp;lt;= 节点个数 &amp;lt;= &lt;span class=&quot;number&quot;&gt;5000&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h3 id=&quot;解法一-栈&quot;&gt;&lt;a href=&quot;#解法一-栈&quot; class=&quot;headerlink&quot; title=&quot;解法一 栈&quot;&gt;&lt;/a&gt;解法一 栈&lt;/h3&gt;&lt;p&gt;最简单的一种方式就是使用栈，因为栈是先进后出的。实现原理就是把链表节点一个个入栈，当全部入栈完之后再一个个出栈，出栈的时候在把出栈的结点串成一个新的链表。原理如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://plutowu-blogimgs.oss-cn-guangzhou.aliyuncs.com/img/343fd7cce80394422565b4beef398236832cc9ae0f77a85ebceacebe214785af-image.png&quot; alt=&quot;image.png&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="面试" scheme="http://plutowu.top/categories/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="Java" scheme="http://plutowu.top/categories/%E9%9D%A2%E8%AF%95/Java/"/>
    
    <category term="笔记" scheme="http://plutowu.top/categories/%E9%9D%A2%E8%AF%95/Java/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="笔记" scheme="http://plutowu.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Java" scheme="http://plutowu.top/tags/Java/"/>
    
    <category term="面试" scheme="http://plutowu.top/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="算法" scheme="http://plutowu.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Java后端面试笔记-设计模式</title>
    <link href="http://plutowu.top/2021/03/11/Java%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AE%B0-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://plutowu.top/2021/03/11/Java%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AE%B0-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <published>2021-03-11T02:43:36.000Z</published>
    <updated>2021-03-11T14:25:11.660Z</updated>
    
    <content type="html"><![CDATA[<h1 id="设计模式篇"><a href="#设计模式篇" class="headerlink" title="设计模式篇"></a>设计模式篇</h1><h2 id="1-代理模式"><a href="#1-代理模式" class="headerlink" title="1. 代理模式"></a>1. 代理模式</h2><p>代理模式是一种比较好理解的设计模式。简单来说就是 <strong>我们使用代理对象来代替对真实对象(real object)的访问，这样就可以在不修改原目标对象的前提下，提供额外的功能操作，扩展目标对象的功能。</strong></p><p><strong>代理模式的主要作用是扩展目标对象的功能，比如说在目标对象的某个方法执行前后你可以增加一些自定义的操作。</strong></p><p>举个例子：你找了小红来帮你问话，小红就可以看作是代理你的代理对象，代理的行为（方法）是问话。</p><p><img src="https://plutowu-blogimgs.oss-cn-guangzhou.aliyuncs.com/img/1*DjWCgTFm-xqbhbNQVsaWQw.png" alt="Understanding the Proxy Design Pattern | by Mithun Sasidharan | Medium"></p><p style="text-align:right;font-size:13px;color:gray">https://medium.com/@mithunsasidharan/understanding-the-proxy-design-pattern-5e63fe38052a</p><p>代理模式有静态代理和动态代理两种实现方式，我们 先来看一下静态代理模式的实现。</p><a id="more"></a><h3 id="1-1-静态代理"><a href="#1-1-静态代理" class="headerlink" title="1.1. 静态代理"></a>1.1. 静态代理</h3><p><strong>静态代理中，我们对目标对象的每个方法的增强都是手动完成的（<em>后面会具体演示代码_），非常不灵活（_比如接口一旦新增加方法，目标对象和代理对象都要进行修改_）且麻烦(_需要对每个目标类都单独写一个代理类</em>)。</strong> 实际应用场景非常非常少，日常开发几乎看不到使用静态代理的场景。</p><p>上面我们是从实现和应用角度来说的静态代理，从 JVM 层面来说， <strong>静态代理在编译时就将接口、实现类、代理类这些都变成了一个个实际的 class 文件。</strong></p><p>静态代理实现步骤:</p><ol><li>定义一个接口及其实现类；</li><li>创建一个代理类同样实现这个接口</li><li>将目标对象注入进代理类，然后在代理类的对应方法调用目标类中的对应方法。这样的话，我们就可以通过代理类屏蔽对目标对象的访问，并且可以在目标方法执行前后做一些自己想做的事情。</li></ol><p>下面通过代码展示！</p><p><strong>1.定义发送短信的接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SmsService</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">send</span><span class="params">(String message)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2.实现发送短信的接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SmsServiceImpl</span> <span class="keyword">implements</span> <span class="title">SmsService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">send</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;send message:&quot;</span> + message);</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3.创建代理类并同样实现发送短信的接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SmsProxy</span> <span class="keyword">implements</span> <span class="title">SmsService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SmsService smsService;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SmsProxy</span><span class="params">(SmsService smsService)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.smsService = smsService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">send</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//调用方法之前，我们可以添加自己的操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;before method send()&quot;</span>);</span><br><span class="line">        smsService.send(message);</span><br><span class="line">        <span class="comment">//调用方法之后，我们同样可以添加自己的操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;after method send()&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4.实际使用</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SmsService smsService = <span class="keyword">new</span> SmsServiceImpl();</span><br><span class="line">        SmsProxy smsProxy = <span class="keyword">new</span> SmsProxy(smsService);</span><br><span class="line">        smsProxy.send(<span class="string">&quot;java&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行上述代码之后，控制台打印出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">before method send()</span><br><span class="line">send message:java</span><br><span class="line">after method send()</span><br></pre></td></tr></table></figure><p>可以输出结果看出，我们已经增加了 <code>SmsServiceImpl</code> 的<code>send()</code>方法。</p><h3 id="1-2-动态代理"><a href="#1-2-动态代理" class="headerlink" title="1.2. 动态代理"></a>1.2. 动态代理</h3><p>相比于静态代理来说，动态代理更加灵活。我们不需要针对每个目标类都单独创建一个代理类，并且也不需要我们必须实现接口，我们可以直接代理实现类( <em>CGLIB 动态代理机制</em>)。</p><p><strong>从 JVM 角度来说，动态代理是在运行时动态生成类字节码，并加载到 JVM 中的。</strong></p><p>说到动态代理，Spring AOP、RPC 框架应该是两个不得不的提的，它们的实现都依赖了动态代理。</p><p><strong>动态代理在我们日常开发中使用的相对较小，但是在框架中的几乎是必用的一门技术。学会了动态代理之后，对于我们理解和学习各种框架的原理也非常有帮助。</strong></p><p>就 Java 来说，动态代理的实现方式有很多种，比如 <strong>JDK 动态代理</strong>、<strong>CGLIB 动态代理</strong>等等。</p><p><a href="https://github.com/Snailclimb/guide-rpc-framework">guide-rpc-framework</a> 使用的是 JDK 动态代理，我们先来看看 JDK 动态代理的使用。</p><p>另外，虽然 <a href="https://github.com/Snailclimb/guide-rpc-framework">guide-rpc-framework</a> 没有用到 <strong>CGLIB 动态代理 ，我们这里还是简单介绍一下其使用以及和</strong>JDK 动态代理的对比。</p><h4 id="2-1-JDK-动态代理机制"><a href="#2-1-JDK-动态代理机制" class="headerlink" title="2.1. JDK 动态代理机制"></a>2.1. JDK 动态代理机制</h4><h5 id="2-1-1-介绍"><a href="#2-1-1-介绍" class="headerlink" title="2.1.1. 介绍"></a>2.1.1. 介绍</h5><p><strong>在 Java 动态代理机制中 <code>InvocationHandler</code> 接口和 <code>Proxy</code> 类是核心。</strong></p><p><code>Proxy</code> 类中使用频率最高的方法是：<code>newProxyInstance()</code> ，这个方法主要用来生成一个代理对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      Class&lt;?&gt;[] interfaces,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      InvocationHandler h)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IllegalArgumentException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法一共有 3 个参数：</p><ol><li><strong>loader</strong> :类加载器，用于加载代理对象。</li><li><strong>interfaces</strong> : 被代理类实现的一些接口；</li><li><strong>h</strong> : 实现了 <code>InvocationHandler</code> 接口的对象；</li></ol><p>要实现动态代理的话，还必须需要实现<code>InvocationHandler</code> 来自定义处理逻辑。 当我们的动态代理对象调用一个方法时候，这个方法的调用就会被转发到实现<code>InvocationHandler</code> 接口类的 <code>invoke</code> 方法来调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当你使用代理对象调用方法的时候实际会调用到这个方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> Throwable</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>invoke()</code> 方法有下面三个参数：</p><ol><li><strong>proxy</strong> :动态生成的代理类</li><li><strong>method</strong> : 与代理类对象调用的方法相对应</li><li><strong>args</strong> : 当前 method 方法的参数</li></ol><p>也就是说：<strong>你通过<code>Proxy</code> 类的 <code>newProxyInstance()</code> 创建的代理对象在调用方法的时候，实际会调用到实现<code>InvocationHandler</code> 接口的类的 <code>invoke()</code>方法。</strong> 你可以在 <code>invoke()</code> 方法中自定义处理逻辑，比如在方法执行前后做什么事情。</p><h5 id="2-1-2-JDK-动态代理类使用步骤"><a href="#2-1-2-JDK-动态代理类使用步骤" class="headerlink" title="2.1.2. JDK 动态代理类使用步骤"></a>2.1.2. JDK 动态代理类使用步骤</h5><ol><li>定义一个接口及其实现类；</li><li>自定义 <code>InvocationHandler</code> 并重写<code>invoke</code>方法，在 <code>invoke</code> 方法中我们会调用原生方法（被代理类的方法）并自定义一些处理逻辑；</li><li>通过 <code>Proxy.newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h)</code> 方法创建代理对象；</li></ol><h5 id="2-1-3-代码示例"><a href="#2-1-3-代码示例" class="headerlink" title="2.1.3. 代码示例"></a>2.1.3. 代码示例</h5><p>这样说可能会有点空洞和难以理解，我上个例子，大家感受一下吧！</p><p><strong>1.定义发送短信的接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SmsService</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">send</span><span class="params">(String message)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2.实现发送短信的接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SmsServiceImpl</span> <span class="keyword">implements</span> <span class="title">SmsService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">send</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;send message:&quot;</span> + message);</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3.定义一个 JDK 动态代理类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shuang.kou</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@createTime</span> 2020年05月11日 11:23:00</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DebugInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代理类中的真实对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DebugInvocationHandler</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> InvocationTargetException, IllegalAccessException </span>&#123;</span><br><span class="line">        <span class="comment">//调用方法之前，我们可以添加自己的操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;before method &quot;</span> + method.getName());</span><br><span class="line">        Object result = method.invoke(target, args);</span><br><span class="line">        <span class="comment">//调用方法之后，我们同样可以添加自己的操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;after method &quot;</span> + method.getName());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>invoke()</code> 方法: 当我们的动态代理对象调用原生方法的时候，最终实际上调用到的是 <code>invoke()</code> 方法，然后 <code>invoke()</code> 方法代替我们去调用了被代理对象的原生方法。</p><p><strong>4.获取代理对象的工厂类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdkProxyFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getProxy</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(</span><br><span class="line">                target.getClass().getClassLoader(), <span class="comment">// 目标类的类加载</span></span><br><span class="line">                target.getClass().getInterfaces(),  <span class="comment">// 代理需要实现的接口，可指定多个</span></span><br><span class="line">                <span class="keyword">new</span> DebugInvocationHandler(target)   <span class="comment">// 代理对象对应的自定义 InvocationHandler</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>getProxy()</code> ：主要通过<code>Proxy.newProxyInstance（）</code>方法获取某个类的代理对象</p><p><strong>5.实际使用</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SmsService smsService = (SmsService) JdkProxyFactory.getProxy(<span class="keyword">new</span> SmsServiceImpl());</span><br><span class="line">smsService.send(<span class="string">&quot;java&quot;</span>);</span><br></pre></td></tr></table></figure><p>运行上述代码之后，控制台打印出：</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">before <span class="function"><span class="keyword">method</span> <span class="title">send</span></span></span><br><span class="line"><span class="function"><span class="title">send</span> <span class="title">message</span>:</span>java</span><br><span class="line">after <span class="function"><span class="keyword">method</span> <span class="title">send</span></span></span><br></pre></td></tr></table></figure><h4 id="2-2-CGLIB-动态代理机制"><a href="#2-2-CGLIB-动态代理机制" class="headerlink" title="2.2. CGLIB 动态代理机制"></a>2.2. CGLIB 动态代理机制</h4><h5 id="2-2-1-介绍"><a href="#2-2-1-介绍" class="headerlink" title="2.2.1. 介绍"></a>2.2.1. 介绍</h5><p><strong>JDK 动态代理有一个最致命的问题是其只能代理实现了接口的类。</strong></p><p><strong>为了解决这个问题，我们可以用 CGLIB 动态代理机制来避免。</strong></p><p><a href="https://github.com/cglib/cglib">CGLIB</a>(<em>Code Generation Library</em>)是一个基于<a href="http://www.baeldung.com/java-asm">ASM</a>的字节码生成库，它允许我们在运行时对字节码进行修改和动态生成。CGLIB 通过继承方式实现代理。很多知名的开源框架都使用到了<a href="https://github.com/cglib/cglib">CGLIB</a>， 例如 Spring 中的 AOP 模块中：如果目标对象实现了接口，则默认采用 JDK 动态代理，否则采用 CGLIB 动态代理。</p><p><strong>在 CGLIB 动态代理机制中 <code>MethodInterceptor</code> 接口和 <code>Enhancer</code> 类是核心。</strong></p><p>你需要自定义 <code>MethodInterceptor</code> 并重写 <code>intercept</code> 方法，<code>intercept</code> 用于拦截增强被代理类的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MethodInterceptor</span></span></span><br><span class="line"><span class="class"><span class="keyword">extends</span> <span class="title">Callback</span></span>&#123;</span><br><span class="line">    <span class="comment">// 拦截被代理类中的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object obj, java.lang.reflect.Method method, Object[] args,</span></span></span><br><span class="line"><span class="function"><span class="params">                               MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li><strong>obj</strong> :被代理的对象（需要增强的对象）</li><li><strong>method</strong> :被拦截的方法（需要增强的方法）</li><li><strong>args</strong> :方法入参</li><li><strong>methodProxy</strong> :用于调用原始方法</li></ol><p>你可以通过 <code>Enhancer</code>类来动态获取被代理类，当代理类调用方法的时候，实际调用的是 <code>MethodInterceptor</code> 中的 <code>intercept</code> 方法。</p><h5 id="2-2-2-CGLIB-动态代理类使用步骤"><a href="#2-2-2-CGLIB-动态代理类使用步骤" class="headerlink" title="2.2.2. CGLIB 动态代理类使用步骤"></a>2.2.2. CGLIB 动态代理类使用步骤</h5><ol><li>定义一个类；</li><li>自定义 <code>MethodInterceptor</code> 并重写 <code>intercept</code> 方法，<code>intercept</code> 用于拦截增强被代理类的方法，和 JDK 动态代理中的 <code>invoke</code> 方法类似；</li><li>通过 <code>Enhancer</code> 类的 <code>create()</code>创建代理类；</li></ol><h5 id="2-2-3-代码示例"><a href="#2-2-3-代码示例" class="headerlink" title="2.2.3. 代码示例"></a>2.2.3. 代码示例</h5><p>不同于 JDK 动态代理不需要额外的依赖。<a href="https://github.com/cglib/cglib">CGLIB</a>(<em>Code Generation Library</em>) 实际是属于一个开源项目，如果你要使用它的话，需要手动添加相关依赖。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>1.实现一个使用阿里云发送短信的类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> github.javaguide.dynamicProxy.cglibDynamicProxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AliSmsService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">send</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;send message:&quot;</span> + message);</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2.自定义 <code>MethodInterceptor</code>（方法拦截器）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodInterceptor;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodProxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义MethodInterceptor</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DebugMethodInterceptor</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> o           被代理的对象（需要增强的对象）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method      被拦截的方法（需要增强的方法）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args        方法入参</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> methodProxy 用于调用原始方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">//调用方法之前，我们可以添加自己的操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;before method &quot;</span> + method.getName());</span><br><span class="line">        Object object = methodProxy.invokeSuper(o, args);</span><br><span class="line">        <span class="comment">//调用方法之后，我们同样可以添加自己的操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;after method &quot;</span> + method.getName());</span><br><span class="line">        <span class="keyword">return</span> object;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3.获取代理类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.Enhancer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibProxyFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getProxy</span><span class="params">(Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建动态代理增强类</span></span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        <span class="comment">// 设置类加载器</span></span><br><span class="line">        enhancer.setClassLoader(clazz.getClassLoader());</span><br><span class="line">        <span class="comment">// 设置被代理类</span></span><br><span class="line">        enhancer.setSuperclass(clazz);</span><br><span class="line">        <span class="comment">// 设置方法拦截器</span></span><br><span class="line">        enhancer.setCallback(<span class="keyword">new</span> DebugMethodInterceptor());</span><br><span class="line">        <span class="comment">// 创建代理类</span></span><br><span class="line">        <span class="keyword">return</span> enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4.实际使用</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AliSmsService aliSmsService = (AliSmsService) CglibProxyFactory.getProxy(AliSmsService.class);</span><br><span class="line">aliSmsService.send(<span class="string">&quot;java&quot;</span>);</span><br></pre></td></tr></table></figure><p>运行上述代码之后，控制台打印出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">before method send</span><br><span class="line">send message:java</span><br><span class="line">after method send</span><br></pre></td></tr></table></figure><h3 id="1-3-JDK-动态代理和-CGLIB-动态代理对比"><a href="#1-3-JDK-动态代理和-CGLIB-动态代理对比" class="headerlink" title="1.3. JDK 动态代理和 CGLIB 动态代理对比"></a>1.3. JDK 动态代理和 CGLIB 动态代理对比</h3><ol><li><strong>JDK 动态代理只能只能代理实现了接口的类或者直接代理接口，而 CGLIB 可以代理未实现任何接口的类。</strong> 另外， CGLIB 动态代理是通过生成一个被代理类的子类来拦截被代理类的方法调用，因此不能代理声明为 final 类型的类和方法。</li><li>就二者的效率来说，大部分情况都是 JDK 动态代理更优秀，随着 JDK 版本的升级，这个优势更加明显。</li></ol><h3 id="1-4-静态代理和动态代理的对比"><a href="#1-4-静态代理和动态代理的对比" class="headerlink" title="1.4. 静态代理和动态代理的对比"></a>1.4. 静态代理和动态代理的对比</h3><ol><li><strong>灵活性</strong> ：动态代理更加灵活，不需要必须实现接口，可以直接代理实现类，并且可以不需要针对每个目标类都创建一个代理类。另外，静态代理中，接口一旦新增加方法，目标对象和代理对象都要进行修改，这是非常麻烦的！</li><li><strong>JVM 层面</strong> ：静态代理在编译时就将接口、实现类、代理类这些都变成了一个个实际的 class 文件。而动态代理是在运行时动态生成类字节码，并加载到 JVM 中的。</li></ol>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;设计模式篇&quot;&gt;&lt;a href=&quot;#设计模式篇&quot; class=&quot;headerlink&quot; title=&quot;设计模式篇&quot;&gt;&lt;/a&gt;设计模式篇&lt;/h1&gt;&lt;h2 id=&quot;1-代理模式&quot;&gt;&lt;a href=&quot;#1-代理模式&quot; class=&quot;headerlink&quot; title=&quot;1. 代理模式&quot;&gt;&lt;/a&gt;1. 代理模式&lt;/h2&gt;&lt;p&gt;代理模式是一种比较好理解的设计模式。简单来说就是 &lt;strong&gt;我们使用代理对象来代替对真实对象(real object)的访问，这样就可以在不修改原目标对象的前提下，提供额外的功能操作，扩展目标对象的功能。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代理模式的主要作用是扩展目标对象的功能，比如说在目标对象的某个方法执行前后你可以增加一些自定义的操作。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;举个例子：你找了小红来帮你问话，小红就可以看作是代理你的代理对象，代理的行为（方法）是问话。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://plutowu-blogimgs.oss-cn-guangzhou.aliyuncs.com/img/1*DjWCgTFm-xqbhbNQVsaWQw.png&quot; alt=&quot;Understanding the Proxy Design Pattern | by Mithun Sasidharan | Medium&quot;&gt;&lt;/p&gt;
&lt;p style=&quot;text-align:right;font-size:13px;color:gray&quot;&gt;https://medium.com/@mithunsasidharan/understanding-the-proxy-design-pattern-5e63fe38052a&lt;/p&gt;

&lt;p&gt;代理模式有静态代理和动态代理两种实现方式，我们 先来看一下静态代理模式的实现。&lt;/p&gt;</summary>
    
    
    
    <category term="面试" scheme="http://plutowu.top/categories/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="Java" scheme="http://plutowu.top/categories/%E9%9D%A2%E8%AF%95/Java/"/>
    
    <category term="笔记" scheme="http://plutowu.top/categories/%E9%9D%A2%E8%AF%95/Java/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="笔记" scheme="http://plutowu.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Java" scheme="http://plutowu.top/tags/Java/"/>
    
    <category term="面试" scheme="http://plutowu.top/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="设计模式" scheme="http://plutowu.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Java后端面试笔记-线程</title>
    <link href="http://plutowu.top/2021/03/11/Java%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AE%B0-%E7%BA%BF%E7%A8%8B/"/>
    <id>http://plutowu.top/2021/03/11/Java%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AE%B0-%E7%BA%BF%E7%A8%8B/</id>
    <published>2021-03-11T01:55:44.000Z</published>
    <updated>2021-03-22T02:19:08.789Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-进程与线程"><a href="#1-进程与线程" class="headerlink" title="1.进程与线程"></a>1.进程与线程</h2><blockquote><p><strong>进程</strong></p></blockquote><p>进程是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。</p><p>在 Java 中，当我们启动 main 函数时其实就是启动了一个 JVM 的进程，而 main 函数所在的线程就是这个进程中的一个线程，也称主线程。</p><blockquote><p><strong>线程</strong></p></blockquote><p>线程与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享进程的<strong>堆</strong>和<strong>方法区</strong>资源，但每个线程有自己的<strong>程序计数器</strong>、<strong>虚拟机栈</strong>和<strong>本地方法栈</strong>，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。</p><p><img src="https://plutowu-blogimgs.oss-cn-guangzhou.aliyuncs.com/img/image-20210322101837933.png" alt="image-20210322101837933"></p><p>从上图可以看出：一个进程中可以有多个线程，多个线程共享进程的<strong>堆</strong>和<strong>方法区 (JDK1.8 之后的元空间)**资源，但是每个线程有自己的</strong>程序计数器<strong>、</strong>虚拟机栈** 和 <strong>本地方法栈</strong>。</p><a id="more"></a><p><strong>总结：</strong> 线程 是 进程 划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。线程执行开销小，但不利于资源的管理和保护；而进程则反之。</p><blockquote><p>线程的基本状态</p></blockquote><p>Java 线程在运行的生命周期中的指定时刻只可能处于下面 6 种不同状态的其中一个状态（图源《Java 并发编程艺术》4.1.4 节）。</p><p><img src="https://plutowu-blogimgs.oss-cn-guangzhou.aliyuncs.com/img/20210311103608.png"></p><p>线程在生命周期中并不是固定处于某一个状态而是随着代码的执行在不同状态之间切换。Java 线程状态变迁如下图所示（图源《Java 并发编程艺术》4.1.4 节）：</p><p><img src="https://plutowu-blogimgs.oss-cn-guangzhou.aliyuncs.com/img/20210311103632.png"></p><p>由上图可以看出：</p><p>线程创建之后它将处于 <strong>NEW（新建）</strong> 状态，调用 <code>start()</code> 方法后开始运行，线程这时候处于 <strong>READY（可运行）</strong> 状态。可运行状态的线程获得了 CPU 时间片（timeslice）后就处于 <strong>RUNNING（运行）</strong> 状态。</p><blockquote><p>操作系统隐藏 Java 虚拟机（JVM）中的 READY 和 RUNNING 状态，它只能看到 RUNNABLE 状态（图源：<a href="https://howtodoinjava.com/">HowToDoInJava</a>：<a href="https://howtodoinjava.com/java/multi-threading/java-thread-life-cycle-and-thread-states/">Java Thread Life Cycle and Thread States</a>），所以 Java 系统一般将这两个状态统称为 <strong>RUNNABLE（运行中）</strong> 状态 。</p></blockquote><p><img src="https://plutowu-blogimgs.oss-cn-guangzhou.aliyuncs.com/img/20210311103637.png"></p><p>当线程执行 <code>wait()</code>方法之后，线程进入 <strong>WAITING（等待）</strong> 状态。进入等待状态的线程需要依靠其他线程的通知才能够返回到运行状态，而 <strong>TIME_WAITING(超时等待)</strong> 状态相当于在等待状态的基础上增加了超时限制，比如通过 <code>sleep（long millis）</code>方法或 <code>wait（long millis）</code>方法可以将 Java 线程置于 TIMED WAITING 状态。当超时时间到达后 Java 线程将会返回到 RUNNABLE 状态。当线程调用同步方法时，在没有获取到锁的情况下，线程将会进入到 <strong>BLOCKED（阻塞）</strong> 状态。线程在执行 Runnable 的<code>run()</code>方法之后将会进入到 <strong>TERMINATED（终止）</strong> 状态。</p><h2 id="2-上下文切换"><a href="#2-上下文切换" class="headerlink" title="2.上下文切换"></a>2.上下文切换</h2><p>多线程编程中一般线程的个数都大于 CPU 核心的个数，而一个 CPU 核心在任意时刻只能被一个线程使用，为了让这些线程都能得到有效执行，CPU 采取的策略是为每个线程分配时间片并轮转的形式。当一个线程的时间片用完的时候就会重新处于就绪状态让给其他线程使用，这个过程就属于一次上下文切换。</p><p>概括来说就是：当前任务在执行完 CPU 时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。<strong>任务从保存到再加载的过程就是一次上下文切换</strong>。</p><p>上下文切换通常是计算密集型的。也就是说，它需要相当可观的处理器时间，在每秒几十上百次的切换中，每次切换都需要纳秒量级的时间。所以，上下文切换对系统来说意味着消耗大量的 CPU 时间，事实上，可能是操作系统中时间消耗最大的操作。</p><p>Linux 相比与其他操作系统（包括其他类 Unix 系统）有很多的优点，其中有一项就是，其上下文切换和模式切换的时间消耗非常少。</p><h2 id="3-并发与并行"><a href="#3-并发与并行" class="headerlink" title="3.并发与并行"></a>3.并发与并行</h2><ul><li><strong>并发：</strong> 同一时间段，多个任务都在执行 (单位时间内不一定同时执行)；</li><li><strong>并行：</strong> 单位时间内，多个任务同时执行。</li></ul><h2 id="4-线程死锁和避免策略"><a href="#4-线程死锁和避免策略" class="headerlink" title="4.线程死锁和避免策略"></a>4.线程死锁和避免策略</h2><h3 id="4-1线程死锁"><a href="#4-1线程死锁" class="headerlink" title="4.1线程死锁"></a>4.1线程死锁</h3><p>多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止。</p><p>如下图所示，线程 A 持有资源 2，线程 B 持有资源 1，他们同时都想申请对方的资源，所以这两个线程就会互相等待而进入死锁状态。</p><p><img src="https://plutowu-blogimgs.oss-cn-guangzhou.aliyuncs.com/img/20210311100124.png"></p><p>下面通过一个例子来说明线程死锁,代码模拟了上图的死锁的情况 (代码来源于《并发编程之美》)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLockDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object resource1 = <span class="keyword">new</span> Object();<span class="comment">//资源 1</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object resource2 = <span class="keyword">new</span> Object();<span class="comment">//资源 2</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (resource1) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;get resource1&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;waiting get resource2&quot;</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (resource2) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread() + <span class="string">&quot;get resource2&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;线程 1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (resource2) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;get resource2&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;waiting get resource1&quot;</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (resource1) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread() + <span class="string">&quot;get resource1&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;线程 2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Thread</span>[线程 <span class="number">1</span>,<span class="number">5</span>,main]get resource<span class="number">1</span></span><br><span class="line"><span class="attribute">Thread</span>[线程 <span class="number">2</span>,<span class="number">5</span>,main]get resource<span class="number">2</span></span><br><span class="line"><span class="attribute">Thread</span>[线程 <span class="number">1</span>,<span class="number">5</span>,main]waiting get resource<span class="number">2</span></span><br><span class="line"><span class="attribute">Thread</span>[线程 <span class="number">2</span>,<span class="number">5</span>,main]waiting get resource<span class="number">1</span></span><br></pre></td></tr></table></figure><p>线程 A 通过 synchronized (resource1) 获得 resource1 的监视器锁，然后通过<code>Thread.sleep(1000);</code>让线程 A 休眠 1s 为的是让线程 B 得到执行然后获取到 resource2 的监视器锁。线程 A 和线程 B 休眠结束了都开始企图请求获取对方的资源，然后这两个线程就会陷入互相等待的状态，这也就产生了死锁。上面的例子符合产生死锁的四个必要条件。</p><p>学过操作系统的朋友都知道产生死锁必须具备以下四个条件：</p><ol><li>互斥条件：该资源任意一个时刻只由一个线程占用。</li><li>请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。</li><li>不剥夺条件:线程已获得的资源在末使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。</li><li>循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。</li></ol><h3 id="4-2避免策略"><a href="#4-2避免策略" class="headerlink" title="4.2避免策略"></a>4.2避免策略</h3><p>只要破坏产生死锁的四个条件中的其中一个。</p><p><strong>破坏互斥条件</strong></p><p>这个条件我们没有办法破坏，因为我们用锁本来就是想让他们互斥的（临界资源需要互斥访问）。</p><p><strong>破坏请求与保持条件</strong></p><p>一次性申请所有的资源。</p><p><strong>破坏不剥夺条件</strong></p><p>占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。</p><p><strong>破坏循环等待条件</strong></p><p>靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。</p><p>我们对线程 2 的代码修改成下面这样就不会产生死锁了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (resource1) &#123;</span><br><span class="line">        System.out.println(Thread.currentThread() + <span class="string">&quot;get resource1&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread() + <span class="string">&quot;waiting get resource2&quot;</span>);</span><br><span class="line">        <span class="keyword">synchronized</span> (resource2) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread() + <span class="string">&quot;get resource2&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="string">&quot;线程 2&quot;</span>).start();</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Thread</span>[线程 <span class="number">1</span>,<span class="number">5</span>,main]get resource<span class="number">1</span></span><br><span class="line"><span class="attribute">Thread</span>[线程 <span class="number">1</span>,<span class="number">5</span>,main]waiting get resource<span class="number">2</span></span><br><span class="line"><span class="attribute">Thread</span>[线程 <span class="number">1</span>,<span class="number">5</span>,main]get resource<span class="number">2</span></span><br><span class="line"><span class="attribute">Thread</span>[线程 <span class="number">2</span>,<span class="number">5</span>,main]get resource<span class="number">1</span></span><br><span class="line"><span class="attribute">Thread</span>[线程 <span class="number">2</span>,<span class="number">5</span>,main]waiting get resource<span class="number">2</span></span><br><span class="line"><span class="attribute">Thread</span>[线程 <span class="number">2</span>,<span class="number">5</span>,main]get resource<span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">Process</span> finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure><p>我们分析一下上面的代码为什么避免了死锁的发生?</p><p>线程 1 首先获得到 resource1 的监视器锁,这时候线程 2 就获取不到了。然后线程 1 再去获取 resource2 的监视器锁，可以获取到。然后线程 1 释放了对 resource1、resource2 的监视器锁的占用，线程 2 获取到就可以执行了。这样就破坏了破坏循环等待条件，因此避免了死锁。</p><h2 id="5-sleep-方法与wait-方法的区别与共同点"><a href="#5-sleep-方法与wait-方法的区别与共同点" class="headerlink" title="5.sleep()方法与wait()方法的区别与共同点"></a>5.sleep()方法与wait()方法的区别与共同点</h2><ul><li>两者最主要的区别在于：<strong>sleep 方法没有释放锁，而 wait 方法释放了锁</strong> 。</li><li>两者都可以暂停线程的执行。</li><li>Wait 通常被用于线程间交互/通信，sleep 通常被用于暂停执行。</li><li>wait() 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 notify() 或者 notifyAll() 方法。sleep() 方法执行完成后，线程会自动苏醒。或者可以使用 wait(long timeout)超时后线程会自动苏醒。</li></ul><h2 id="6-为什么调用-start-方法时会执行-run-方法，为什么我们不能直接调用-run-方法？"><a href="#6-为什么调用-start-方法时会执行-run-方法，为什么我们不能直接调用-run-方法？" class="headerlink" title="6.为什么调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？"></a>6.为什么调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？</h2><p>new 一个 Thread，线程进入了新建状态;调用 start() 方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。 start() 会执行线程的相应准备工作，然后自动执行 run() 方法的内容，这是真正的多线程工作。 而直接执行 run() 方法，会把 run 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。</p><p><strong>总结： 调用 start 方法方可启动线程并使线程进入就绪状态，而 run 方法只是 thread 的一个普通方法调用，还是在主线程里执行。</strong></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;1-进程与线程&quot;&gt;&lt;a href=&quot;#1-进程与线程&quot; class=&quot;headerlink&quot; title=&quot;1.进程与线程&quot;&gt;&lt;/a&gt;1.进程与线程&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;进程&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;进程是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。&lt;/p&gt;
&lt;p&gt;在 Java 中，当我们启动 main 函数时其实就是启动了一个 JVM 的进程，而 main 函数所在的线程就是这个进程中的一个线程，也称主线程。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;线程&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;线程与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享进程的&lt;strong&gt;堆&lt;/strong&gt;和&lt;strong&gt;方法区&lt;/strong&gt;资源，但每个线程有自己的&lt;strong&gt;程序计数器&lt;/strong&gt;、&lt;strong&gt;虚拟机栈&lt;/strong&gt;和&lt;strong&gt;本地方法栈&lt;/strong&gt;，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://plutowu-blogimgs.oss-cn-guangzhou.aliyuncs.com/img/image-20210322101837933.png&quot; alt=&quot;image-20210322101837933&quot;&gt;&lt;/p&gt;
&lt;p&gt;从上图可以看出：一个进程中可以有多个线程，多个线程共享进程的&lt;strong&gt;堆&lt;/strong&gt;和&lt;strong&gt;方法区 (JDK1.8 之后的元空间)**资源，但是每个线程有自己的&lt;/strong&gt;程序计数器&lt;strong&gt;、&lt;/strong&gt;虚拟机栈** 和 &lt;strong&gt;本地方法栈&lt;/strong&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="面试" scheme="http://plutowu.top/categories/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="Java" scheme="http://plutowu.top/categories/%E9%9D%A2%E8%AF%95/Java/"/>
    
    <category term="笔记" scheme="http://plutowu.top/categories/%E9%9D%A2%E8%AF%95/Java/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="笔记" scheme="http://plutowu.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Java" scheme="http://plutowu.top/tags/Java/"/>
    
    <category term="面试" scheme="http://plutowu.top/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="线程" scheme="http://plutowu.top/tags/%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java后端面试笔记-Java基础</title>
    <link href="http://plutowu.top/2021/03/11/Java%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AE%B0-Java%E5%9F%BA%E7%A1%80/"/>
    <id>http://plutowu.top/2021/03/11/Java%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AE%B0-Java%E5%9F%BA%E7%A1%80/</id>
    <published>2021-03-11T01:21:38.000Z</published>
    <updated>2021-03-11T02:57:54.068Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基础篇"><a href="#基础篇" class="headerlink" title="基础篇"></a>基础篇</h1><h2 id="1-与-equals"><a href="#1-与-equals" class="headerlink" title="1.==与 equals"></a>1.==与 equals</h2><p><strong>==</strong> : 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同一个对象。(基本数据类型==比较的是值==，引用数据类型==比较的是内存地址==)</p><p><strong>equals()</strong> : 它的作用也是判断两个对象是否相等。但它一般有两种使用情况：</p><ul><li>情况 1：类没有覆盖 equals()方法。则通过 equals()比较该类的两个对象时，等价于通过“==”比较这两个对象。</li><li>情况 2：类覆盖了 equals()方法。一般，我们都覆盖 equals()方法来两个对象的内容相等；若它们的内容相等，则返回 true(即，认为这两个对象相等)。</li></ul><p><strong>举个例子：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String a = <span class="keyword">new</span> String(<span class="string">&quot;ab&quot;</span>); <span class="comment">// a为一个引用</span></span><br><span class="line">        String b = <span class="keyword">new</span> String(<span class="string">&quot;ab&quot;</span>); <span class="comment">// b为另一个引用,对象的内容一样</span></span><br><span class="line">        String aa = <span class="string">&quot;ab&quot;</span>; <span class="comment">// 放在常量池中</span></span><br><span class="line">        String bb = <span class="string">&quot;ab&quot;</span>; <span class="comment">// 从常量池中查找</span></span><br><span class="line">        <span class="keyword">if</span> (aa == bb) <span class="comment">// true</span></span><br><span class="line">            System.out.println(<span class="string">&quot;aa==bb&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (a == b) <span class="comment">// false，非同一对象</span></span><br><span class="line">            System.out.println(<span class="string">&quot;a==b&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (a.equals(b)) <span class="comment">// true</span></span><br><span class="line">            System.out.println(<span class="string">&quot;aEQb&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">42</span> == <span class="number">42.0</span>) &#123; <span class="comment">// true</span></span><br><span class="line">            System.out.println(<span class="string">&quot;true&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p><strong>说明：</strong></p><ul><li>String 中的 equals 方法是被重写过的，因为 object 的 equals 方法是比较的对象的内存地址，而 String 的 equals 方法比较的是对象的值。</li><li>当创建 String 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个 String 对象。</li></ul><h2 id="2-hashCode-与equals"><a href="#2-hashCode-与equals" class="headerlink" title="2.hashCode()与equals()"></a>2.hashCode()与equals()</h2><p>面试官可能会问你：“你重写过 <code>hashcode</code> 和 <code>equals </code>么，为什么重写 <code>equals</code> 时必须重写 <code>hashCode</code> 方法？”</p><h3 id="2-1-hashCode-介绍"><a href="#2-1-hashCode-介绍" class="headerlink" title="2.1 hashCode()介绍"></a>2.1 hashCode()介绍</h3><p><code>hashCode()</code> 的作用是获取哈希码，也称为散列码；它实际上是返回一个 int 整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。<code>hashCode() </code>定义在 JDK 的 <code>Object</code> 类中，这就意味着 Java 中的任何类都包含有 <code>hashCode()</code> 函数。另外需要注意的是： <code>Object</code> 的 hashcode 方法是本地方法，也就是用 c 语言或 c++ 实现的，该方法通常用来将对象的 内存地址 转换为整数之后返回。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）</p><h3 id="2-2-为什么要有-hashCode？"><a href="#2-2-为什么要有-hashCode？" class="headerlink" title="2.2 为什么要有 hashCode？"></a>2.2 为什么要有 hashCode？</h3><p><strong>我们以“<code>HashSet</code> 如何检查重复”为例子来说明为什么要有 hashCode：</strong></p><p>当你把对象加入 <code>HashSet</code> 时，<code>HashSet</code> 会先计算对象的 hashcode 值来判断对象加入的位置，同时也会与其他已经加入的对象的 hashcode 值作比较，如果没有相符的 hashcode，<code>HashSet</code> 会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用 equals（）方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，<code>HashSet</code> 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。（摘自我的 Java 启蒙书《Head fist java》第二版）。这样我们就大大减少了 equals 的次数，相应就大大提高了执行速度。</p><h3 id="2-3-为什么重写-equals-时必须重写-hashCode-方法？"><a href="#2-3-为什么重写-equals-时必须重写-hashCode-方法？" class="headerlink" title="2.3 为什么重写 equals 时必须重写 hashCode 方法？"></a>2.3 为什么重写 <code>equals</code> 时必须重写 <code>hashCode</code> 方法？</h3><p>如果两个对象相等，则 hashcode 一定也是相同的。两个对象相等,对两个对象分别调用 equals 方法都返回 true。但是，两个对象有相同的 hashcode 值，它们也不一定是相等的 。<strong>因此，equals 方法被覆盖过，则 <code>hashCode</code> 方法也必须被覆盖。</strong></p><blockquote><p> <code>hashCode()</code>的默认行为是对堆上的对象产生独特值。如果没有重写 <code>hashCode()</code>，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）</p></blockquote><h3 id="2-4-为什么两个对象有相同的-hashcode-值，它们也不一定是相等的？"><a href="#2-4-为什么两个对象有相同的-hashcode-值，它们也不一定是相等的？" class="headerlink" title="2.4 为什么两个对象有相同的 hashcode 值，它们也不一定是相等的？"></a>2.4 为什么两个对象有相同的 hashcode 值，它们也不一定是相等的？</h3><p>在这里解释一位小伙伴的问题。以下内容摘自《Head First Java》。</p><p>因为 <code>hashCode()</code> 所使用的杂凑算法也许刚好会让多个对象传回相同的杂凑值。越糟糕的杂凑算法越容易碰撞，但这也与数据值域分布的特性有关（所谓碰撞也就是指的是不同的对象得到相同的 <code>hashCode</code>。</p><p>我们刚刚也提到了 <code>HashSet</code>,如果 <code>HashSet</code> 在对比的时候，同样的 hashcode 有多个对象，它会使用 <code>equals()</code> 来判断是否真的相同。也就是说 <code>hashcode</code> 只是用来缩小查找成本。</p><h2 id="3-Java-面向对象编程三大特性：封装-继承-多态"><a href="#3-Java-面向对象编程三大特性：封装-继承-多态" class="headerlink" title="3.Java 面向对象编程三大特性：封装 继承 多态"></a>3.Java 面向对象编程三大特性：封装 继承 多态</h2><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>封装把一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法，如果属性不想被外界访问，我们大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。</p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承我们能够非常方便地复用以前的代码。</p><p><strong>关于继承如下 3 点请记住：</strong></p><ol><li>子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，<strong>只是拥有</strong>。</li><li>子类可以拥有自己属性和方法，即子类可以对父类进行扩展。</li><li>子类可以用自己的方式实现父类的方法。</li></ol><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>所谓多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。</p><p>在 Java 中有两种形式可以实现多态：继承（多个子类对同一方法的重写）和接口（实现接口并覆盖接口中同一方法）。</p><h2 id="4-JDK-JRE-JVM"><a href="#4-JDK-JRE-JVM" class="headerlink" title="4.JDK JRE JVM"></a>4.JDK JRE JVM</h2><h3 id="4-1-JVM"><a href="#4-1-JVM" class="headerlink" title="4.1 JVM"></a>4.1 JVM</h3><p>Java 虚拟机（JVM）是运行 Java 字节码的虚拟机。JVM 有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。</p><p><strong>什么是字节码?采用字节码的好处是什么?</strong></p><blockquote><p>在 Java 中，JVM 可以理解的代码就叫做<code>字节码</code>（即扩展名为 <code>.class</code> 的文件），它不面向任何特定的处理器，只面向虚拟机。Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以 Java 程序运行时比较高效，而且，由于字节码并不针对一种特定的机器，因此，Java 程序无须重新编译便可在多种不同操作系统的计算机上运行。</p></blockquote><p><strong>Java 程序从源代码到运行一般有下面 3 步：</strong></p><p><img src="https://plutowu-blogimgs.oss-cn-guangzhou.aliyuncs.com/img/20210311101521.png"></p><p>我们需要格外注意的是 .class-&gt;机器码 这一步。在这一步 JVM 类加载器首先加载字节码文件，然后通过解释器逐行解释执行，这种方式的执行速度会相对比较慢。而且，有些方法和代码块是经常需要被调用的(也就是所谓的热点代码)，所以后面引进了 JIT 编译器，而 JIT 属于运行时编译。当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。而我们知道，机器码的运行效率肯定是高于 Java 解释器的。这也解释了我们为什么经常会说 Java 是编译与解释共存的语言。</p><blockquote><p>HotSpot 采用了惰性评估(Lazy Evaluation)的做法，根据二八定律，消耗大部分系统资源的只有那一小部分的代码（热点代码），而这也就是 JIT 所需要编译的部分。JVM 会根据代码每次被执行的情况收集信息并相应地做出一些优化，因此执行的次数越多，它的速度就越快。JDK 9 引入了一种新的编译模式 AOT(Ahead of Time Compilation)，它是直接将字节码编译成机器码，这样就避免了 JIT 预热等各方面的开销。JDK 支持分层编译和 AOT 协作使用。但是 ，AOT 编译器的编译质量是肯定比不上 JIT 编译器的。</p></blockquote><p><strong>总结：</strong></p><p>Java 虚拟机（JVM）是运行 Java 字节码的虚拟机。JVM 有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。字节码和不同系统的 JVM 实现是 Java 语言“一次编译，随处可以运行”的关键所在。</p><h3 id="4-2-JDK-和-JRE"><a href="#4-2-JDK-和-JRE" class="headerlink" title="4.2 JDK 和 JRE"></a>4.2 JDK 和 JRE</h3><p>JDK 是 Java Development Kit，它是功能齐全的 Java SDK。它拥有 JRE 所拥有的一切，还有编译器（javac）和工具（如 javadoc 和 jdb）。它能够创建和编译程序。</p><p>JRE 是 Java 运行时环境。它是运行已编译 Java 程序所需的所有内容的集合，包括 Java 虚拟机（JVM），Java 类库，java 命令和其他的一些基础构件。但是，它不能用于创建新程序。</p><p>如果你只是为了运行一下 Java 程序的话，那么你只需要安装 JRE 就可以了。如果你需要进行一些 Java 编程方面的工作，那么你就需要安装 JDK 了。但是，这不是绝对的。有时，即使您不打算在计算机上进行任何 Java 开发，仍然需要安装 JDK。例如，如果要使用 JSP 部署 Web 应用程序，那么从技术上讲，您只是在应用程序服务器中运行 Java 程序。那你为什么需要 JDK 呢？因为应用程序服务器会将 JSP 转换为 Java servlet，并且需要使用 JDK 来编译 servlet。</p><h2 id="5-String-和-StringBuffer、StringBuilder的区别？String为什么是不可变的？"><a href="#5-String-和-StringBuffer、StringBuilder的区别？String为什么是不可变的？" class="headerlink" title="5.String 和 StringBuffer、StringBuilder的区别？String为什么是不可变的？"></a>5.String 和 StringBuffer、StringBuilder的区别？String为什么是不可变的？</h2><h3 id="三者区别"><a href="#三者区别" class="headerlink" title="三者区别"></a>三者区别</h3><p><strong>可变性</strong></p><p>简单的来说：String 类中使用 final 关键字修饰字符数组来保存字符串，<code>private final char value[]</code>，所以 String 对象是不可变的。而 StringBuilder 与 StringBuffer 都继承自 AbstractStringBuilder 类，在 AbstractStringBuilder 中也是使用字符数组保存字符串<code>char[]value</code> 但是没有用 final 关键字修饰，所以这两种对象都是可变的。</p><p>StringBuilder 与 StringBuffer 的构造方法都是调用父类构造方法也就是 AbstractStringBuilder 实现的。</p><p>AbstractStringBuilder.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractStringBuilder</span> <span class="keyword">implements</span> <span class="title">Appendable</span>, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[] value;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    AbstractStringBuilder() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    AbstractStringBuilder(<span class="keyword">int</span> capacity) &#123;</span><br><span class="line">        value = <span class="keyword">new</span> <span class="keyword">char</span>[capacity];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>线程安全性</strong></p><p>String 中的对象是不可变的，也就可以理解为常量，线程安全。AbstractStringBuilder 是 StringBuilder 与 StringBuffer 的公共父类，定义了一些字符串的基本操作，如 expandCapacity、append、insert、indexOf 等公共方法。StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的。</p><p><strong>性能</strong></p><p>每次对 String 类型进行改变的时候，都会生成一个新的 String 对象，然后将指针指向新的 String 对象。StringBuffer 每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 StringBuilder 相比使用 StringBuffer 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。</p><p><strong>对于三者使用的总结：</strong></p><ol><li>操作少量的数据: 适用 String</li><li>单线程操作字符串缓冲区下操作大量数据: 适用 StringBuilder</li><li>多线程操作字符串缓冲区下操作大量数据: 适用 StringBuffer</li></ol><h3 id="String-为什么是不可变的？"><a href="#String-为什么是不可变的？" class="headerlink" title="String 为什么是不可变的？"></a>String 为什么是不可变的？</h3><p>简单来说就是 String 类利用了 final 修饰的 char 类型数组存储字符，源码如下图所以：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** The value is used for character storage. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];</span><br></pre></td></tr></table></figure><h3 id="String-真的是不可变的吗？"><a href="#String-真的是不可变的吗？" class="headerlink" title="String 真的是不可变的吗？"></a>String 真的是不可变的吗？</h3><p>我觉得如果别人问这个问题的话，回答不可变就可以了。<br>下面只是给大家看两个有代表性的例子：</p><p><strong>1) String 不可变但不代表引用不可以变</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">str = str + <span class="string">&quot; World&quot;</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;str=&quot;</span> + str);</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">str</span>=Hello World</span><br></pre></td></tr></table></figure><p>解析：</p><p>实际上，原来 String 的内容是不变的，只是 str 由原来指向”Hello”的内存地址转为指向”Hello World”的内存地址而已，也就是说多开辟了一块内存区域给”Hello World”字符串。</p><p><strong>2) 通过反射是可以修改所谓的“不可变”对象</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建字符串&quot;Hello World&quot;， 并赋给引用s</span></span><br><span class="line">String s = <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;s = &quot;</span> + s); <span class="comment">// Hello World</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取String类中的value字段</span></span><br><span class="line">Field valueFieldOfString = String.class.getDeclaredField(<span class="string">&quot;value&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改变value属性的访问权限</span></span><br><span class="line">valueFieldOfString.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取s对象上的value属性的值</span></span><br><span class="line"><span class="keyword">char</span>[] value = (<span class="keyword">char</span>[]) valueFieldOfString.get(s);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改变value所引用的数组中的第5个字符</span></span><br><span class="line">value[<span class="number">5</span>] = <span class="string">&#x27;_&#x27;</span>;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;s = &quot;</span> + s); <span class="comment">// Hello_World</span></span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">s</span> = Hello World</span><br><span class="line"><span class="attr">s</span> = Hello_World</span><br></pre></td></tr></table></figure><p>解析：</p><p>用反射可以访问私有成员， 然后反射出 String 对象中的 value 属性， 进而改变通过获得的 value 引用改变数组的结构。但是一般我们不会这么做，这里只是简单提一下有这个东西。</p><h2 id="6-反射机制及其应用场景"><a href="#6-反射机制及其应用场景" class="headerlink" title="6.反射机制及其应用场景"></a>6.反射机制及其应用场景</h2><h3 id="6-1-反射机制介绍"><a href="#6-1-反射机制介绍" class="headerlink" title="6.1 反射机制介绍"></a>6.1 反射机制介绍</h3><p>JAVA 反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为 java 语言的反射机制。</p><h3 id="6-2-静态编译和动态编译"><a href="#6-2-静态编译和动态编译" class="headerlink" title="6.2 静态编译和动态编译"></a>6.2 静态编译和动态编译</h3><ul><li><strong>静态编译：</strong>在编译时确定类型，绑定对象</li><li><strong>动态编译：</strong>运行时确定类型，绑定对象</li></ul><h3 id="6-3-反射机制优缺点"><a href="#6-3-反射机制优缺点" class="headerlink" title="6.3 反射机制优缺点"></a>6.3 反射机制优缺点</h3><ul><li><strong>优点：</strong> 运行期类型的判断，动态加载类，提高代码灵活度。</li><li><strong>缺点：</strong> 性能瓶颈：反射相当于一系列解释操作，通知 JVM 要做的事情，性能比直接的 java 代码要慢很多。</li></ul><h3 id="6-4-反射的应用场景"><a href="#6-4-反射的应用场景" class="headerlink" title="6.4 反射的应用场景"></a>6.4 反射的应用场景</h3><p><strong>反射是框架设计的灵魂。</strong></p><p>在我们平时的项目开发过程中，基本上很少会直接使用到反射机制，但这不能说明反射机制没有用，实际上有很多设计、开发都与反射机制有关，例如模块化的开发，通过反射去调用对应的字节码；动态代理设计模式也采用了反射机制，还有我们日常使用的 Spring／Hibernate 等框架也大量使用到了反射机制。</p><p>举例：① 我们在使用 JDBC 连接数据库时使用 <code>Class.forName()</code>通过反射加载数据库的驱动程序；②Spring 框架也用到很多反射机制，最经典的就是 xml 的配置模式。Spring 通过 XML 配置模式装载 Bean 的过程：</p><ol><li>将程序内所有 XML 或 Properties 配置文件加载入内存中;</li></ol><p>2)Java 类里面解析 xml 或 properties 里面的内容，得到对应实体类的字节码字符串以及相关的属性信息;</p><p> 3)使用反射机制，根据这个字符串获得某个类的 Class 实例; </p><p>4)动态配置实例的属性</p><h2 id="7-字节码及采用字节码的最大好处"><a href="#7-字节码及采用字节码的最大好处" class="headerlink" title="7.字节码及采用字节码的最大好处"></a>7.字节码及采用字节码的最大好处</h2><p><strong>先看下 java 中的编译器和解释器：</strong></p><p>Java 中引入了虚拟机的概念，即在机器和编译程序之间加入了一层抽象的虚拟的机器。这台虚拟的机器在任何平台上都提供给编译程序一个的共同的接口。编译程序只需要面向虚拟机，生成虚拟机能够理解的代码，然后由解释器来将虚拟机代码转换为特定系统的机器码执行。在 Java 中，这种供虚拟机理解的代码叫做<code>字节码</code>（即扩展名为<code>.class</code>的文件），它不面向任何特定的处理器，只面向虚拟机。每一种平台的解释器是不同的，但是实现的虚拟机是相同的。Java 源程序经过编译器编译后变成字节码，字节码由虚拟机解释执行，虚拟机将每一条要执行的字节码送给解释器，解释器将其翻译成特定机器上的机器码，然后在特定的机器上运行。这也就是解释了 Java 的编译与解释并存的特点。</p><p>Java 源代码—-&gt;编译器—-&gt;jvm 可执行的 Java 字节码(即虚拟指令)—-&gt;jvm—-&gt;jvm 中解释器—–&gt;机器可执行的二进制机器码—-&gt;程序运行。</p><p><strong>采用字节码的好处：</strong></p><p>Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以 Java 程序运行时比较高效，而且，由于字节码并不专对一种特定的机器，因此，Java 程序无须重新编译便可在多种不同的计算机上运行。</p><h2 id="8-接口和抽象类的区别"><a href="#8-接口和抽象类的区别" class="headerlink" title="8.接口和抽象类的区别"></a>8.接口和抽象类的区别</h2><ol><li>接口的方法默认是 public，所有方法在接口中不能有实现，抽象类可以有非抽象的方法</li><li>接口中的实例变量默认是 final 类型的，而抽象类中则不一定</li><li>一个类可以实现多个接口，但最多只能实现一个抽象类</li><li>一个类实现接口的话要实现接口的所有方法，而抽象类不一定</li><li>接口不能用 new 实例化，但可以声明，但是必须引用一个实现该接口的对象 从设计层面来说，抽象是对类的抽象，是一种模板设计，接口是行为的抽象，是一种行为的规范。</li></ol><p>注意：Java8 后接口可以有默认实现( default )。</p><h2 id="9-重载与重写的区别"><a href="#9-重载与重写的区别" class="headerlink" title="9.重载与重写的区别"></a>9.重载与重写的区别</h2><h3 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h3><p>发生在同一个类中，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同。</p><p>下面是《Java 核心技术》对重载这个概念的介绍：</p><p><img src="https://plutowu-blogimgs.oss-cn-guangzhou.aliyuncs.com/img/20210311102724.png"></p><h3 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h3><p>重写是子类对父类的允许访问的方法的实现过程进行重新编写,发生在子类中，方法名、参数列表必须相同，返回值范围小于等于父类，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。另外，如果父类方法访问修饰符为 private 则子类就不能重写该方法。<strong>也就是说方法提供的行为改变，而方法的外貌并没有改变。</strong></p><h2 id="10-Java-核心技术-异常"><a href="#10-Java-核心技术-异常" class="headerlink" title="10. Java 核心技术-异常"></a>10. Java 核心技术-异常</h2><h3 id="10-1-Java-异常类层次结构图"><a href="#10-1-Java-异常类层次结构图" class="headerlink" title="10.1 Java 异常类层次结构图"></a>10.1 Java 异常类层次结构图</h3><p><img src="https://plutowu-blogimgs.oss-cn-guangzhou.aliyuncs.com/img/Java%E5%BC%82%E5%B8%B8%E7%B1%BB%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E5%9B%BE.png"></p><p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/2020-12/Java%E5%BC%82%E5%B8%B8%E7%B1%BB%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E5%9B%BE2.png"></p><p>在 Java 中，所有的异常都有一个共同的祖先 <code>java.lang</code> 包中的 <code>Throwable</code> 类。<code>Throwable</code> 类有两个重要的子类 <code>Exception</code>（异常）和 <code>Error</code>（错误）。<code>Exception</code> 能被程序本身处理(<code>try-catch</code>)， <code>Error</code> 是无法处理的(只能尽量避免)。</p><p><code>Exception</code> 和 <code>Error</code> 二者都是 Java 异常处理的重要子类，各自都包含大量子类。</p><ul><li><strong><code>Exception</code></strong> :程序本身可以处理的异常，可以通过 <code>catch</code> 来进行捕获。<code>Exception</code> 又可以分为 受检查异常(必须处理) 和 不受检查异常(可以不处理)。</li><li><strong><code>Error</code></strong> ：<code>Error</code> 属于程序无法处理的错误 ，我们没办法通过 <code>catch</code> 来进行捕获 。例如，Java 虚拟机运行错误（<code>Virtual MachineError</code>）、虚拟机内存不够错误(<code>OutOfMemoryError</code>)、类定义错误（<code>NoClassDefFoundError</code>）等 。这些异常发生时，Java 虚拟机（JVM）一般会选择线程终止。</li></ul><p><strong>受检查异常</strong></p><p>Java 代码在编译过程中，如果受检查异常没有被 <code>catch</code>/<code>throw</code> 处理的话，就没办法通过编译 。比如下面这段 IO 操作的代码。</p><p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/2020-12/check-exception.png" alt="check-exception"></p><p>除了<code>RuntimeException</code>及其子类以外，其他的<code>Exception</code>类及其子类都属于受检查异常 。常见的受检查异常有： IO 相关的异常、<code>ClassNotFoundException</code> 、<code>SQLException</code>…。</p><p><strong>不受检查异常</strong></p><p>Java 代码在编译过程中 ，我们即使不处理不受检查异常也可以正常通过编译。</p><p><code>RuntimeException</code> 及其子类都统称为非受检查异常，例如：<code>NullPointException</code>、<code>NumberFormatException</code>（字符串转换为数字）、<code>ArrayIndexOutOfBoundsException</code>（数组越界）、<code>ClassCastException</code>（类型转换错误）、<code>ArithmeticException</code>（算术错误）等。</p><h3 id="10-2-Throwable-类常用方法"><a href="#10-2-Throwable-类常用方法" class="headerlink" title="10.2. Throwable 类常用方法"></a>10.2. Throwable 类常用方法</h3><ul><li><strong><code>public string getMessage()</code></strong>:返回异常发生时的简要描述</li><li><strong><code>public string toString()</code></strong>:返回异常发生时的详细信息</li><li><strong><code>public string getLocalizedMessage()</code></strong>:返回异常对象的本地化信息。使用 <code>Throwable</code> 的子类覆盖这个方法，可以生成本地化信息。如果子类没有覆盖该方法，则该方法返回的信息与 <code>getMessage（）</code>返回的结果相同</li><li><strong><code>public void printStackTrace()</code></strong>:在控制台上打印 <code>Throwable</code> 对象封装的异常信息</li></ul><h3 id="10-3-try-catch-finally"><a href="#10-3-try-catch-finally" class="headerlink" title="10.3. try-catch-finally"></a>10.3. try-catch-finally</h3><ul><li><strong><code>try</code>块：</strong> 用于捕获异常。其后可接零个或多个 <code>catch</code> 块，如果没有 <code>catch</code> 块，则必须跟一个 <code>finally</code> 块。</li><li><strong><code>catch</code>块：</strong> 用于处理 try 捕获到的异常。</li><li><strong><code>finally</code> 块：</strong> 无论是否捕获或处理异常，<code>finally</code> 块里的语句都会被执行。当在 <code>try</code> 块或 <code>catch</code> 块中遇到 <code>return</code> 语句时，<code>finally</code> 语句块将在方法返回之前被执行。</li></ul><p><strong>在以下 3 种特殊情况下，<code>finally</code> 块不会被执行：</strong></p><ol start="2"><li>在 <code>try</code> 或 <code>finally </code>块中用了 <code>System.exit(int)</code>退出程序。但是，如果 <code>System.exit(int)</code> 在异常语句之后，<code>finally</code> 还是会被执行</li><li>程序所在的线程死亡。</li><li>关闭 CPU。</li></ol><p><strong>注意：</strong> 当 try 语句和 finally 语句中都有 return 语句时，在方法返回之前，finally 语句的内容将被执行，并且 finally 语句的返回值将会覆盖原始的返回值。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> value * value;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (value == <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果调用 <code>f(2)</code>，返回值将是 0，因为 finally 语句的返回值覆盖了 try 语句块的返回值。</p><h3 id="10-4-使用-try-with-resources-来代替try-catch-finally"><a href="#10-4-使用-try-with-resources-来代替try-catch-finally" class="headerlink" title="10.4. 使用 try-with-resources 来代替try-catch-finally"></a>10.4. 使用 <code>try-with-resources</code> 来代替<code>try-catch-finally</code></h3><ol><li><strong>适用范围（资源的定义）：</strong> 任何实现 <code>java.lang.AutoCloseable</code>或者 <code>java.io.Closeable</code> 的对象</li><li><strong>关闭资源和 final 的执行顺序：</strong> 在 <code>try-with-resources</code> 语句中，任何 catch 或 finally 块在声明的资源关闭后运行</li></ol><p>《Effective Java》中明确指出：</p><blockquote><p>面对必须要关闭的资源，我们总是应该优先使用 <code>try-with-resources</code> 而不是<code>try-finally</code>。随之产生的代码更简短，更清晰，产生的异常对我们也更有用。<code>try-with-resources</code>语句让我们更容易编写必须要关闭的资源的代码，若采用<code>try-finally</code>则几乎做不到这点。</p></blockquote><p>Java 中类似于<code>InputStream</code>、<code>OutputStream</code> 、<code>Scanner</code> 、<code>PrintWriter</code>等的资源都需要我们调用<code>close()</code>方法来手动关闭，一般情况下我们都是通过<code>try-catch-finally</code>语句来实现这个需求，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//读取文本文件的内容</span></span><br><span class="line">Scanner scanner = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    scanner = <span class="keyword">new</span> Scanner(<span class="keyword">new</span> File(<span class="string">&quot;D://read.txt&quot;</span>));</span><br><span class="line">    <span class="keyword">while</span> (scanner.hasNext()) &#123;</span><br><span class="line">        System.out.println(scanner.nextLine());</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (scanner != <span class="keyword">null</span>) &#123;</span><br><span class="line">        scanner.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 Java 7 之后的 <code>try-with-resources</code> 语句改造上面的代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (Scanner scanner = <span class="keyword">new</span> Scanner(<span class="keyword">new</span> File(<span class="string">&quot;test.txt&quot;</span>))) &#123;</span><br><span class="line">    <span class="keyword">while</span> (scanner.hasNext()) &#123;</span><br><span class="line">        System.out.println(scanner.nextLine());</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException fnfe) &#123;</span><br><span class="line">    fnfe.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然多个资源需要关闭的时候，使用 <code>try-with-resources</code> 实现起来也非常简单，如果你还是用<code>try-catch-finally</code>可能会带来很多问题。</p><p>通过使用分号分隔，可以在<code>try-with-resources</code>块中声明多个资源。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (BufferedInputStream bin = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(<span class="string">&quot;test.txt&quot;</span>)));</span><br><span class="line">             BufferedOutputStream bout = <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(<span class="string">&quot;out.txt&quot;</span>)))) &#123;</span><br><span class="line">            <span class="keyword">int</span> b;</span><br><span class="line">            <span class="keyword">while</span> ((b = bin.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                bout.write(b);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;基础篇&quot;&gt;&lt;a href=&quot;#基础篇&quot; class=&quot;headerlink&quot; title=&quot;基础篇&quot;&gt;&lt;/a&gt;基础篇&lt;/h1&gt;&lt;h2 id=&quot;1-与-equals&quot;&gt;&lt;a href=&quot;#1-与-equals&quot; class=&quot;headerlink&quot; title=&quot;1.==与 equals&quot;&gt;&lt;/a&gt;1.==与 equals&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;==&lt;/strong&gt; : 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同一个对象。(基本数据类型==比较的是值==，引用数据类型==比较的是内存地址==)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;equals()&lt;/strong&gt; : 它的作用也是判断两个对象是否相等。但它一般有两种使用情况：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;情况 1：类没有覆盖 equals()方法。则通过 equals()比较该类的两个对象时，等价于通过“==”比较这两个对象。&lt;/li&gt;
&lt;li&gt;情况 2：类覆盖了 equals()方法。一般，我们都覆盖 equals()方法来两个对象的内容相等；若它们的内容相等，则返回 true(即，认为这两个对象相等)。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;举个例子：&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;test1&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        String a = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; String(&lt;span class=&quot;string&quot;&gt;&amp;quot;ab&amp;quot;&lt;/span&gt;); &lt;span class=&quot;comment&quot;&gt;// a为一个引用&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        String b = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; String(&lt;span class=&quot;string&quot;&gt;&amp;quot;ab&amp;quot;&lt;/span&gt;); &lt;span class=&quot;comment&quot;&gt;// b为另一个引用,对象的内容一样&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        String aa = &lt;span class=&quot;string&quot;&gt;&amp;quot;ab&amp;quot;&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;// 放在常量池中&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        String bb = &lt;span class=&quot;string&quot;&gt;&amp;quot;ab&amp;quot;&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;// 从常量池中查找&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (aa == bb) &lt;span class=&quot;comment&quot;&gt;// true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            System.out.println(&lt;span class=&quot;string&quot;&gt;&amp;quot;aa==bb&amp;quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (a == b) &lt;span class=&quot;comment&quot;&gt;// false，非同一对象&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            System.out.println(&lt;span class=&quot;string&quot;&gt;&amp;quot;a==b&amp;quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (a.equals(b)) &lt;span class=&quot;comment&quot;&gt;// true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            System.out.println(&lt;span class=&quot;string&quot;&gt;&amp;quot;aEQb&amp;quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;number&quot;&gt;42&lt;/span&gt; == &lt;span class=&quot;number&quot;&gt;42.0&lt;/span&gt;) &amp;#123; &lt;span class=&quot;comment&quot;&gt;// true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            System.out.println(&lt;span class=&quot;string&quot;&gt;&amp;quot;true&amp;quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="面试" scheme="http://plutowu.top/categories/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="Java" scheme="http://plutowu.top/categories/%E9%9D%A2%E8%AF%95/Java/"/>
    
    <category term="笔记" scheme="http://plutowu.top/categories/%E9%9D%A2%E8%AF%95/Java/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="笔记" scheme="http://plutowu.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Java" scheme="http://plutowu.top/tags/Java/"/>
    
    <category term="面试" scheme="http://plutowu.top/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="Java基础" scheme="http://plutowu.top/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Java后端面试笔记-Java8新特性</title>
    <link href="http://plutowu.top/2021/03/10/Java%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AE%B0-Java8%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <id>http://plutowu.top/2021/03/10/Java%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AE%B0-Java8%E6%96%B0%E7%89%B9%E6%80%A7/</id>
    <published>2021-03-10T14:25:10.000Z</published>
    <updated>2021-03-10T14:33:10.835Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java8新特性"><a href="#Java8新特性" class="headerlink" title="Java8新特性"></a>Java8新特性</h1><h3 id="接口的默认方法-Default-Methods-for-Interfaces"><a href="#接口的默认方法-Default-Methods-for-Interfaces" class="headerlink" title="接口的默认方法(Default Methods for Interfaces)"></a>接口的默认方法(Default Methods for Interfaces)</h3><p>Java 8使我们能够通过使用 <code>default</code> 关键字向接口添加非抽象方法实现。 此功能也称为<a href="http://stackoverflow.com/a/24102730">虚拟扩展方法</a>。</p><p>第一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Formula</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">calculate</span><span class="params">(<span class="keyword">int</span> a)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">double</span> <span class="title">sqrt</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Math.sqrt(a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Formula 接口中除了抽象方法计算接口公式还定义了默认方法 <code>sqrt</code>。 实现该接口的类只需要实现抽象方法 <code>calculate</code>。 默认方法<code>sqrt</code> 可以直接使用。当然你也可以直接通过接口创建对象，然后实现接口中的默认方法就可以了，我们通过代码演示一下这种方式。</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 通过匿名内部类方式访问接口</span></span><br><span class="line">    Formula formula = <span class="keyword">new</span> Formula() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">calculate</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> sqrt(a * <span class="number">100</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    System.out.println(formula.calculate(<span class="number">100</span>));     <span class="comment">// 100.0</span></span><br><span class="line">    System.out.println(formula.sqrt(<span class="number">16</span>));           <span class="comment">// 4.0</span></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> formula 是作为匿名对象实现的。该代码非常容易理解，6行代码实现了计算 <code>sqrt(a * 100)</code>。在下一节中，我们将会看到在 Java 8 中实现单个方法对象有一种更好更方便的方法。</p><p><strong>译者注：</strong> 不管是抽象类还是接口，都可以通过匿名内部类的方式访问。不能通过抽象类或者接口直接创建对象。对于上面通过匿名内部类方式访问接口，我们可以这样理解：一个内部类实现了接口里的抽象方法并且返回一个内部类对象，之后我们让接口的引用来指向这个对象。</p><h3 id="Lambda表达式-Lambda-expressions"><a href="#Lambda表达式-Lambda-expressions" class="headerlink" title="Lambda表达式(Lambda expressions)"></a>Lambda表达式(Lambda expressions)</h3><p>首先看看在老版本的Java中是如何排列字符串的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; names = Arrays.asList(<span class="string">&quot;peter&quot;</span>, <span class="string">&quot;anna&quot;</span>, <span class="string">&quot;mike&quot;</span>, <span class="string">&quot;xenia&quot;</span>);</span><br><span class="line"></span><br><span class="line">Collections.sort(names, <span class="keyword">new</span> Comparator&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String a, String b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> b.compareTo(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>只需要给静态方法<code> Collections.sort</code> 传入一个 List 对象以及一个比较器来按指定顺序排列。通常做法都是创建一个匿名的比较器对象然后将其传递给 <code>sort</code> 方法。</p><p>在Java 8 中你就没必要使用这种传统的匿名对象的方式了，Java 8提供了更简洁的语法，lambda表达式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Collections.sort(names, (String a, String b) -&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> b.compareTo(a);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>可以看出，代码变得更段且更具有可读性，但是实际上还可以写得更短：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Collections.sort(names, (String a, String b) -&gt; b.compareTo(a));</span><br></pre></td></tr></table></figure><p>对于函数体只有一行代码的，你可以去掉大括号{}以及return关键字，但是你还可以写得更短点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">names.sort((a, b) -&gt; b.compareTo(a));</span><br></pre></td></tr></table></figure><p>List 类本身就有一个 <code>sort</code> 方法。并且Java编译器可以自动推导出参数类型，所以你可以不用再写一次类型。接下来我们看看lambda表达式还有什么其他用法。</p><h3 id="函数式接口-Functional-Interfaces"><a href="#函数式接口-Functional-Interfaces" class="headerlink" title="函数式接口(Functional Interfaces)"></a>函数式接口(Functional Interfaces)</h3><p><strong>译者注：</strong> 原文对这部分解释不太清楚，故做了修改！</p><p>Java 语言设计者们投入了大量精力来思考如何使现有的函数友好地支持Lambda。最终采取的方法是：增加函数式接口的概念。<strong>“函数式接口”是指仅仅只包含一个抽象方法,但是可以有多个非抽象方法(也就是上面提到的默认方法)的接口。</strong> 像这样的接口，可以被隐式转换为lambda表达式。<code>java.lang.Runnable</code> 与 <code>java.util.concurrent.Callable</code> 是函数式接口最典型的两个例子。Java 8增加了一种特殊的注解<code>@FunctionalInterface</code>,但是这个注解通常不是必须的(某些情况建议使用)，只要接口只包含一个抽象方法，虚拟机会自动判断该接口为函数式接口。一般建议在接口上使用<code>@FunctionalInterface</code> 注解进行声明，这样的话，编译器如果发现你标注了这个注解的接口有多于一个抽象方法的时候会报错的，如下图所示</p><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-2/@FunctionalInterface.png" alt="@FunctionalInterface 注解"></p><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Converter</span>&lt;<span class="title">F</span>, <span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function">T <span class="title">convert</span><span class="params">(F from)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TODO 将数字字符串转换为整数类型</span></span><br><span class="line">Converter&lt;String, Integer&gt; converter = (from) -&gt; Integer.valueOf(from);</span><br><span class="line">Integer converted = converter.convert(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">System.out.println(converted.getClass()); <span class="comment">//class java.lang.Integer</span></span><br></pre></td></tr></table></figure><p><strong>译者注：</strong> 大部分函数式接口都不用我们自己写，Java8都给我们实现好了，这些接口都在java.util.function包里。</p><h3 id="方法和构造函数引用-Method-and-Constructor-References"><a href="#方法和构造函数引用-Method-and-Constructor-References" class="headerlink" title="方法和构造函数引用(Method and Constructor References)"></a>方法和构造函数引用(Method and Constructor References)</h3><p>前一节中的代码还可以通过静态方法引用来表示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Converter&lt;String, Integer&gt; converter = Integer::valueOf;</span><br><span class="line">Integer converted = converter.convert(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">System.out.println(converted.getClass());   <span class="comment">//class java.lang.Integer</span></span><br></pre></td></tr></table></figure><p>Java 8允许您通过<code>::</code>关键字传递方法或构造函数的引用。 上面的示例显示了如何引用静态方法。 但我们也可以引用对象方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Something</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">startsWith</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> String.valueOf(s.charAt(<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Something something = <span class="keyword">new</span> Something();</span><br><span class="line">Converter&lt;String, String&gt; converter = something::startsWith;</span><br><span class="line">String converted = converter.convert(<span class="string">&quot;Java&quot;</span>);</span><br><span class="line">System.out.println(converted);    <span class="comment">// &quot;J&quot;</span></span><br></pre></td></tr></table></figure><p>接下来看看构造函数是如何使用<code>::</code>关键字来引用的，首先我们定义一个包含多个构造函数的简单类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    String firstName;</span><br><span class="line">    String lastName;</span><br><span class="line"></span><br><span class="line">    Person() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    Person(String firstName, String lastName) &#123;</span><br><span class="line">        <span class="keyword">this</span>.firstName = firstName;</span><br><span class="line">        <span class="keyword">this</span>.lastName = lastName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们指定一个用来创建Person对象的对象工厂接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">PersonFactory</span>&lt;<span class="title">P</span> <span class="keyword">extends</span> <span class="title">Person</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">P <span class="title">create</span><span class="params">(String firstName, String lastName)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们使用构造函数引用来将他们关联起来，而不是手动实现一个完整的工厂：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PersonFactory&lt;Person&gt; personFactory = Person::<span class="keyword">new</span>;</span><br><span class="line">Person person = personFactory.create(<span class="string">&quot;Peter&quot;</span>, <span class="string">&quot;Parker&quot;</span>);</span><br></pre></td></tr></table></figure><p>我们只需要使用 <code>Person::new</code> 来获取Person类构造函数的引用，Java编译器会自动根据<code>PersonFactory.create</code>方法的参数类型来选择合适的构造函数。</p><h3 id="Lamda-表达式作用域-Lambda-Scopes"><a href="#Lamda-表达式作用域-Lambda-Scopes" class="headerlink" title="Lamda 表达式作用域(Lambda Scopes)"></a>Lamda 表达式作用域(Lambda Scopes)</h3><h4 id="访问局部变量"><a href="#访问局部变量" class="headerlink" title="访问局部变量"></a>访问局部变量</h4><p>我们可以直接在 lambda 表达式中访问外部的局部变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">Converter&lt;Integer, String&gt; stringConverter =</span><br><span class="line">        (from) -&gt; String.valueOf(from + num);</span><br><span class="line"></span><br><span class="line">stringConverter.convert(<span class="number">2</span>);     <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>但是和匿名对象不同的是，这里的变量num可以不用声明为final，该代码同样正确：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">Converter&lt;Integer, String&gt; stringConverter =</span><br><span class="line">        (from) -&gt; String.valueOf(from + num);</span><br><span class="line"></span><br><span class="line">stringConverter.convert(<span class="number">2</span>);     <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>不过这里的 num 必须不可被后面的代码修改（即隐性的具有final的语义），例如下面的就无法编译：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">Converter&lt;Integer, String&gt; stringConverter =</span><br><span class="line">        (from) -&gt; String.valueOf(from + num);</span><br><span class="line">num = <span class="number">3</span>;<span class="comment">//在lambda表达式中试图修改num同样是不允许的。</span></span><br></pre></td></tr></table></figure><h4 id="访问字段和静态变量"><a href="#访问字段和静态变量" class="headerlink" title="访问字段和静态变量"></a>访问字段和静态变量</h4><p>与局部变量相比，我们对lambda表达式中的实例字段和静态变量都有读写访问权限。 该行为和匿名对象是一致的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lambda4</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> outerStaticNum;</span><br><span class="line">    <span class="keyword">int</span> outerNum;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testScopes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Converter&lt;Integer, String&gt; stringConverter1 = (from) -&gt; &#123;</span><br><span class="line">            outerNum = <span class="number">23</span>;</span><br><span class="line">            <span class="keyword">return</span> String.valueOf(from);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Converter&lt;Integer, String&gt; stringConverter2 = (from) -&gt; &#123;</span><br><span class="line">            outerStaticNum = <span class="number">72</span>;</span><br><span class="line">            <span class="keyword">return</span> String.valueOf(from);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="访问默认接口方法"><a href="#访问默认接口方法" class="headerlink" title="访问默认接口方法"></a>访问默认接口方法</h4><p>还记得第一节中的 formula 示例吗？ <code>Formula</code> 接口定义了一个默认方法<code>sqrt</code>，可以从包含匿名对象的每个 formula 实例访问该方法。 这不适用于lambda表达式。</p><p>无法从 lambda 表达式中访问默认方法,故以下代码无法编译：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Formula formula = (a) -&gt; sqrt(a * <span class="number">100</span>);</span><br></pre></td></tr></table></figure><h3 id="内置函数式接口-Built-in-Functional-Interfaces"><a href="#内置函数式接口-Built-in-Functional-Interfaces" class="headerlink" title="内置函数式接口(Built-in Functional Interfaces)"></a>内置函数式接口(Built-in Functional Interfaces)</h3><p>JDK 1.8 API包含许多内置函数式接口。 其中一些借口在老版本的 Java 中是比较常见的比如： <code>Comparator</code> 或<code>Runnable</code>，这些接口都增加了<code>@FunctionalInterface</code>注解以便能用在 lambda 表达式上。</p><p>但是 Java 8 API 同样还提供了很多全新的函数式接口来让你的编程工作更加方便，有一些接口是来自 <a href="https://code.google.com/p/guava-libraries/">Google Guava</a> 库里的，即便你对这些很熟悉了，还是有必要看看这些是如何扩展到lambda上使用的。</p><h4 id="Predicate"><a href="#Predicate" class="headerlink" title="Predicate"></a>Predicate</h4><p>Predicate 接口是只有一个参数的返回布尔类型值的 <strong>断言型</strong> 接口。该接口包含多种默认方法来将 Predicate 组合成其他复杂的逻辑（比如：与，或，非）：</p><p><strong>译者注：</strong> Predicate 接口源码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.util.function;</span><br><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Predicate</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 该方法是接受一个传入类型,返回一个布尔值.此方法应用于判断.</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">test</span><span class="params">(T t)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//and方法与关系型运算符&quot;&amp;&amp;&quot;相似，两边都成立才返回true</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> Predicate&lt;T&gt; <span class="title">and</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> T&gt; other)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(other);</span><br><span class="line">        <span class="keyword">return</span> (t) -&gt; test(t) &amp;&amp; other.test(t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 与关系运算符&quot;!&quot;相似，对判断进行取反</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> Predicate&lt;T&gt; <span class="title">negate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (t) -&gt; !test(t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//or方法与关系型运算符&quot;||&quot;相似，两边只要有一个成立就返回true</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> Predicate&lt;T&gt; <span class="title">or</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> T&gt; other)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(other);</span><br><span class="line">        <span class="keyword">return</span> (t) -&gt; test(t) || other.test(t);</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">// 该方法接收一个Object对象,返回一个Predicate类型.此方法用于判断第一个test的方法与第二个test方法相同(equal).</span></span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function">Predicate&lt;T&gt; <span class="title">isEqual</span><span class="params">(Object targetRef)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">null</span> == targetRef)</span><br><span class="line">                ? Objects::isNull</span><br><span class="line">                : object -&gt; targetRef.equals(object);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Predicate&lt;String&gt; predicate = (s) -&gt; s.length() &gt; <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">predicate.test(<span class="string">&quot;foo&quot;</span>);              <span class="comment">// true</span></span><br><span class="line">predicate.negate().test(<span class="string">&quot;foo&quot;</span>);     <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">Predicate&lt;Boolean&gt; nonNull = Objects::nonNull;</span><br><span class="line">Predicate&lt;Boolean&gt; isNull = Objects::isNull;</span><br><span class="line"></span><br><span class="line">Predicate&lt;String&gt; isEmpty = String::isEmpty;</span><br><span class="line">Predicate&lt;String&gt; isNotEmpty = isEmpty.negate();</span><br></pre></td></tr></table></figure><h4 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h4><p>Function 接口接受一个参数并生成结果。默认方法可用于将多个函数链接在一起（compose, andThen）：</p><p><strong>译者注：</strong> Function  接口源码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.util.function;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Function</span>&lt;<span class="title">T</span>, <span class="title">R</span>&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将Function对象应用到输入的参数上，然后返回计算结果。</span></span><br><span class="line">    <span class="function">R <span class="title">apply</span><span class="params">(T t)</span></span>;</span><br><span class="line">    <span class="comment">//将两个Function整合，并返回一个能够执行两个Function对象功能的Function对象。</span></span><br><span class="line">    <span class="keyword">default</span> &lt;V&gt; <span class="function">Function&lt;V, R&gt; <span class="title">compose</span><span class="params">(Function&lt;? <span class="keyword">super</span> V, ? extends T&gt; before)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(before);</span><br><span class="line">        <span class="keyword">return</span> (V v) -&gt; apply(before.apply(v));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="keyword">default</span> &lt;V&gt; <span class="function">Function&lt;T, V&gt; <span class="title">andThen</span><span class="params">(Function&lt;? <span class="keyword">super</span> R, ? extends V&gt; after)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(after);</span><br><span class="line">        <span class="keyword">return</span> (T t) -&gt; after.apply(apply(t));</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function">Function&lt;T, T&gt; <span class="title">identity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t -&gt; t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Function&lt;String, Integer&gt; toInteger = Integer::valueOf;</span><br><span class="line">Function&lt;String, String&gt; backToString = toInteger.andThen(String::valueOf);</span><br><span class="line">backToString.apply(<span class="string">&quot;123&quot;</span>);     <span class="comment">// &quot;123&quot;</span></span><br></pre></td></tr></table></figure><h4 id="Supplier"><a href="#Supplier" class="headerlink" title="Supplier"></a>Supplier</h4><p>Supplier 接口产生给定泛型类型的结果。 与 Function 接口不同，Supplier 接口不接受参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Supplier&lt;Person&gt; personSupplier = Person::<span class="keyword">new</span>;</span><br><span class="line">personSupplier.get();   <span class="comment">// new Person</span></span><br></pre></td></tr></table></figure><h4 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h4><p>Consumer 接口表示要对单个输入参数执行的操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Consumer&lt;Person&gt; greeter = (p) -&gt; System.out.println(<span class="string">&quot;Hello, &quot;</span> + p.firstName);</span><br><span class="line">greeter.accept(<span class="keyword">new</span> Person(<span class="string">&quot;Luke&quot;</span>, <span class="string">&quot;Skywalker&quot;</span>));</span><br></pre></td></tr></table></figure><h4 id="Comparator"><a href="#Comparator" class="headerlink" title="Comparator"></a>Comparator</h4><p>Comparator 是老Java中的经典接口， Java 8在此之上添加了多种默认方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Comparator&lt;Person&gt; comparator = (p1, p2) -&gt; p1.firstName.compareTo(p2.firstName);</span><br><span class="line"></span><br><span class="line">Person p1 = <span class="keyword">new</span> Person(<span class="string">&quot;John&quot;</span>, <span class="string">&quot;Doe&quot;</span>);</span><br><span class="line">Person p2 = <span class="keyword">new</span> Person(<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;Wonderland&quot;</span>);</span><br><span class="line"></span><br><span class="line">comparator.compare(p1, p2);             <span class="comment">// &gt; 0</span></span><br><span class="line">comparator.reversed().compare(p1, p2);  <span class="comment">// &lt; 0</span></span><br></pre></td></tr></table></figure><h2 id="Optional"><a href="#Optional" class="headerlink" title="Optional"></a>Optional</h2><p>Optional不是函数式接口，而是用于防止 NullPointerException 的漂亮工具。这是下一节的一个重要概念，让我们快速了解一下Optional的工作原理。</p><p>Optional 是一个简单的容器，其值可能是null或者不是null。在Java 8之前一般某个函数应该返回非空对象但是有时却什么也没有返回，而在Java 8中，你应该返回 Optional 而不是 null。</p><p>译者注：示例中每个方法的作用已经添加。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//of（）：为非null的值创建一个Optional</span></span><br><span class="line">Optional&lt;String&gt; optional = Optional.of(<span class="string">&quot;bam&quot;</span>);</span><br><span class="line"><span class="comment">// isPresent（）： 如果值存在返回true，否则返回false</span></span><br><span class="line">optional.isPresent();           <span class="comment">// true</span></span><br><span class="line"><span class="comment">//get()：如果Optional有值则将其返回，否则抛出NoSuchElementException</span></span><br><span class="line">optional.get();                 <span class="comment">// &quot;bam&quot;</span></span><br><span class="line"><span class="comment">//orElse（）：如果有值则将其返回，否则返回指定的其它值</span></span><br><span class="line">optional.orElse(<span class="string">&quot;fallback&quot;</span>);    <span class="comment">// &quot;bam&quot;</span></span><br><span class="line"><span class="comment">//ifPresent（）：如果Optional实例有值则为其调用consumer，否则不做处理</span></span><br><span class="line">optional.ifPresent((s) -&gt; System.out.println(s.charAt(<span class="number">0</span>)));     <span class="comment">// &quot;b&quot;</span></span><br></pre></td></tr></table></figure><p>推荐阅读：<a href="https://blog.kaaass.net/archives/764">[Java8]如何正确使用Optional</a></p><h2 id="Streams-流"><a href="#Streams-流" class="headerlink" title="Streams(流)"></a>Streams(流)</h2><p><code>java.util.Stream</code> 表示能应用在一组元素上一次执行的操作序列。Stream 操作分为中间操作或者最终操作两种，最终操作返回一特定类型的计算结果，而中间操作返回Stream本身，这样你就可以将多个操作依次串起来。Stream 的创建需要指定一个数据源，比如<code> java.util.Collection</code> 的子类，List 或者 Set， Map 不支持。Stream 的操作可以串行执行或者并行执行。</p><p>首先看看Stream是怎么用，首先创建实例代码的用到的数据List：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; stringList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">stringList.add(<span class="string">&quot;ddd2&quot;</span>);</span><br><span class="line">stringList.add(<span class="string">&quot;aaa2&quot;</span>);</span><br><span class="line">stringList.add(<span class="string">&quot;bbb1&quot;</span>);</span><br><span class="line">stringList.add(<span class="string">&quot;aaa1&quot;</span>);</span><br><span class="line">stringList.add(<span class="string">&quot;bbb3&quot;</span>);</span><br><span class="line">stringList.add(<span class="string">&quot;ccc&quot;</span>);</span><br><span class="line">stringList.add(<span class="string">&quot;bbb2&quot;</span>);</span><br><span class="line">stringList.add(<span class="string">&quot;ddd1&quot;</span>);</span><br></pre></td></tr></table></figure><p>Java 8扩展了集合类，可以通过 Collection.stream() 或者 Collection.parallelStream() 来创建一个Stream。下面几节将详细解释常用的Stream操作：</p><h3 id="Filter-过滤"><a href="#Filter-过滤" class="headerlink" title="Filter(过滤)"></a>Filter(过滤)</h3><p>过滤通过一个predicate接口来过滤并只保留符合条件的元素，该操作属于<strong>中间操作</strong>，所以我们可以在过滤后的结果来应用其他Stream操作（比如forEach）。forEach需要一个函数来对过滤后的元素依次执行。forEach是一个最终操作，所以我们不能在forEach之后来执行其他Stream操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试 Filter(过滤)</span></span><br><span class="line">stringList</span><br><span class="line">        .stream()</span><br><span class="line">        .filter((s) -&gt; s.startsWith(<span class="string">&quot;a&quot;</span>))</span><br><span class="line">        .forEach(System.out::println);<span class="comment">//aaa2 aaa1</span></span><br></pre></td></tr></table></figure><p>forEach 是为 Lambda 而设计的，保持了最紧凑的风格。而且 Lambda 表达式本身是可以重用的，非常方便。</p><h3 id="Sorted-排序"><a href="#Sorted-排序" class="headerlink" title="Sorted(排序)"></a>Sorted(排序)</h3><p>排序是一个 <strong>中间操作</strong>，返回的是排序好后的 Stream。<strong>如果你不指定一个自定义的 Comparator 则会使用默认排序。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试 Sort (排序)</span></span><br><span class="line">stringList</span><br><span class="line">        .stream()</span><br><span class="line">        .sorted()</span><br><span class="line">        .filter((s) -&gt; s.startsWith(<span class="string">&quot;a&quot;</span>))</span><br><span class="line">        .forEach(System.out::println);<span class="comment">// aaa1 aaa2</span></span><br></pre></td></tr></table></figure><p>需要注意的是，排序只创建了一个排列好后的Stream，而不会影响原有的数据源，排序之后原数据stringCollection是不会被修改的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(stringList);<span class="comment">// ddd2, aaa2, bbb1, aaa1, bbb3, ccc, bbb2, ddd1</span></span><br></pre></td></tr></table></figure><h3 id="Map-映射"><a href="#Map-映射" class="headerlink" title="Map(映射)"></a>Map(映射)</h3><p>中间操作 map 会将元素根据指定的 Function 接口来依次将元素转成另外的对象。</p><p>下面的示例展示了将字符串转换为大写字符串。你也可以通过map来将对象转换成其他类型，map返回的Stream类型是根据你map传递进去的函数的返回值决定的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试 Map 操作</span></span><br><span class="line">stringList</span><br><span class="line">        .stream()</span><br><span class="line">        .map(String::toUpperCase)</span><br><span class="line">        .sorted((a, b) -&gt; b.compareTo(a))</span><br><span class="line">        .forEach(System.out::println);<span class="comment">// &quot;DDD2&quot;, &quot;DDD1&quot;, &quot;CCC&quot;, &quot;BBB3&quot;, &quot;BBB2&quot;, &quot;AAA2&quot;, &quot;AAA1&quot;</span></span><br></pre></td></tr></table></figure><h3 id="Match-匹配"><a href="#Match-匹配" class="headerlink" title="Match(匹配)"></a>Match(匹配)</h3><p>Stream提供了多种匹配操作，允许检测指定的Predicate是否匹配整个Stream。所有的匹配操作都是 <strong>最终操作</strong> ，并返回一个 boolean 类型的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试 Match (匹配)操作</span></span><br><span class="line"><span class="keyword">boolean</span> anyStartsWithA =</span><br><span class="line">        stringList</span><br><span class="line">                .stream()</span><br><span class="line">                .anyMatch((s) -&gt; s.startsWith(<span class="string">&quot;a&quot;</span>));</span><br><span class="line">System.out.println(anyStartsWithA);      <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> allStartsWithA =</span><br><span class="line">        stringList</span><br><span class="line">                .stream()</span><br><span class="line">                .allMatch((s) -&gt; s.startsWith(<span class="string">&quot;a&quot;</span>));</span><br><span class="line"></span><br><span class="line">System.out.println(allStartsWithA);      <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> noneStartsWithZ =</span><br><span class="line">        stringList</span><br><span class="line">                .stream()</span><br><span class="line">                .noneMatch((s) -&gt; s.startsWith(<span class="string">&quot;z&quot;</span>));</span><br><span class="line"></span><br><span class="line">System.out.println(noneStartsWithZ);      <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="Count-计数"><a href="#Count-计数" class="headerlink" title="Count(计数)"></a>Count(计数)</h3><p>计数是一个 <strong>最终操作</strong>，返回Stream中元素的个数，<strong>返回值类型是 long</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试 Count (计数)操作</span></span><br><span class="line">  <span class="keyword">long</span> startsWithB =</span><br><span class="line">          stringList</span><br><span class="line">                  .stream()</span><br><span class="line">                  .filter((s) -&gt; s.startsWith(<span class="string">&quot;b&quot;</span>))</span><br><span class="line">                  .count();</span><br><span class="line">  System.out.println(startsWithB);    <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><h3 id="Reduce-规约"><a href="#Reduce-规约" class="headerlink" title="Reduce(规约)"></a>Reduce(规约)</h3><p>这是一个 <strong>最终操作</strong> ，允许通过指定的函数来讲stream中的多个元素规约为一个元素，规约后的结果是通过Optional 接口表示的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试 Reduce (规约)操作</span></span><br><span class="line">Optional&lt;String&gt; reduced =</span><br><span class="line">        stringList</span><br><span class="line">                .stream()</span><br><span class="line">                .sorted()</span><br><span class="line">                .reduce((s1, s2) -&gt; s1 + <span class="string">&quot;#&quot;</span> + s2);</span><br><span class="line"></span><br><span class="line">reduced.ifPresent(System.out::println);<span class="comment">//aaa1#aaa2#bbb1#bbb2#bbb3#ccc#ddd1#ddd2</span></span><br></pre></td></tr></table></figure><p><strong>译者注：</strong> 这个方法的主要作用是把 Stream 元素组合起来。它提供一个起始值（种子），然后依照运算规则（BinaryOperator），和前面 Stream 的第一个、第二个、第 n 个元素组合。从这个意义上说，字符串拼接、数值的 sum、min、max、average 都是特殊的 reduce。例如 Stream 的 sum 就相当于<code>Integer sum = integers.reduce(0, (a, b) -&gt; a+b);</code>也有没有起始值的情况，这时会把 Stream 的前面两个元素组合起来，返回的是 Optional。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字符串连接，concat = &quot;ABCD&quot;</span></span><br><span class="line">String concat = Stream.of(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;D&quot;</span>).reduce(<span class="string">&quot;&quot;</span>, String::concat); </span><br><span class="line"><span class="comment">// 求最小值，minValue = -3.0</span></span><br><span class="line"><span class="keyword">double</span> minValue = Stream.of(-<span class="number">1.5</span>, <span class="number">1.0</span>, -<span class="number">3.0</span>, -<span class="number">2.0</span>).reduce(Double.MAX_VALUE, Double::min); </span><br><span class="line"><span class="comment">// 求和，sumValue = 10, 有起始值</span></span><br><span class="line"><span class="keyword">int</span> sumValue = Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>).reduce(<span class="number">0</span>, Integer::sum);</span><br><span class="line"><span class="comment">// 求和，sumValue = 10, 无起始值</span></span><br><span class="line">sumValue = Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>).reduce(Integer::sum).get();</span><br><span class="line"><span class="comment">// 过滤，字符串连接，concat = &quot;ace&quot;</span></span><br><span class="line">concat = Stream.of(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;D&quot;</span>, <span class="string">&quot;e&quot;</span>, <span class="string">&quot;F&quot;</span>).</span><br><span class="line"> filter(x -&gt; x.compareTo(<span class="string">&quot;Z&quot;</span>) &gt; <span class="number">0</span>).</span><br><span class="line"> reduce(<span class="string">&quot;&quot;</span>, String::concat);</span><br></pre></td></tr></table></figure><p>上面代码例如第一个示例的 reduce()，第一个参数（空白字符）即为起始值，第二个参数（String::concat）为 BinaryOperator。这类有起始值的 reduce() 都返回具体的对象。而对于第四个示例没有起始值的 reduce()，由于可能没有足够的元素，返回的是 Optional，请留意这个区别。更多内容查看： <a href="https://www.ibm.com/developerworks/cn/java/j-lo-java8streamapi/index.html">IBM：Java 8 中的 Streams API 详解</a> </p><h2 id="Parallel-Streams-并行流"><a href="#Parallel-Streams-并行流" class="headerlink" title="Parallel Streams(并行流)"></a>Parallel Streams(并行流)</h2><p>前面提到过Stream有串行和并行两种，串行Stream上的操作是在一个线程中依次完成，而并行Stream则是在多个线程上同时执行。</p><p>下面的例子展示了是如何通过并行Stream来提升性能：</p><p>首先我们创建一个没有重复元素的大表：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> max = <span class="number">1000000</span>;</span><br><span class="line">List&lt;String&gt; values = <span class="keyword">new</span> ArrayList&lt;&gt;(max);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; max; i++) &#123;</span><br><span class="line">    UUID uuid = UUID.randomUUID();</span><br><span class="line">    values.add(uuid.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们分别用串行和并行两种方式对其进行排序，最后看看所用时间的对比。</p><h3 id="Sequential-Sort-串行排序"><a href="#Sequential-Sort-串行排序" class="headerlink" title="Sequential Sort(串行排序)"></a>Sequential Sort(串行排序)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//串行排序</span></span><br><span class="line"><span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line"><span class="keyword">long</span> count = values.stream().sorted().count();</span><br><span class="line">System.out.println(count);</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> millis = TimeUnit.NANOSECONDS.toMillis(t1 - t0);</span><br><span class="line">System.out.println(String.format(<span class="string">&quot;sequential sort took: %d ms&quot;</span>, millis));</span><br></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1000000</span></span><br><span class="line">sequential sort took: <span class="number">709</span> ms<span class="comment">//串行排序所用的时间</span></span><br></pre></td></tr></table></figure><h3 id="Parallel-Sort-并行排序"><a href="#Parallel-Sort-并行排序" class="headerlink" title="Parallel Sort(并行排序)"></a>Parallel Sort(并行排序)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//并行排序</span></span><br><span class="line"><span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> count = values.parallelStream().sorted().count();</span><br><span class="line">System.out.println(count);</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> millis = TimeUnit.NANOSECONDS.toMillis(t1 - t0);</span><br><span class="line">System.out.println(String.format(<span class="string">&quot;parallel sort took: %d ms&quot;</span>, millis));</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1000000</span></span><br><span class="line">parallel sort took: <span class="number">475</span> ms<span class="comment">//串行排序所用的时间</span></span><br></pre></td></tr></table></figure><p>上面两个代码几乎是一样的，但是并行版的快了 50% 左右，唯一需要做的改动就是将 <code>stream()</code> 改为<code>parallelStream()</code>。</p><h2 id="Maps"><a href="#Maps" class="headerlink" title="Maps"></a>Maps</h2><p>前面提到过，Map 类型不支持 streams，不过Map提供了一些新的有用的方法来处理一些日常任务。Map接口本身没有可用的 <code>stream（）</code>方法，但是你可以在键，值上创建专门的流或者通过 <code>map.keySet().stream()</code>,<code>map.values().stream()</code>和<code>map.entrySet().stream()</code>。</p><p>此外,Maps 支持各种新的和有用的方法来执行常见任务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Integer, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    map.putIfAbsent(i, <span class="string">&quot;val&quot;</span> + i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">map.forEach((id, val) -&gt; System.out.println(val));<span class="comment">//val0 val1 val2 val3 val4 val5 val6 val7 val8 val9</span></span><br></pre></td></tr></table></figure><p><code>putIfAbsent</code> 阻止我们在null检查时写入额外的代码;<code>forEach</code>接受一个 consumer 来对 map 中的每个元素操作。</p><p>此示例显示如何使用函数在 map 上计算代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">map.computeIfPresent(<span class="number">3</span>, (num, val) -&gt; val + num);</span><br><span class="line">map.get(<span class="number">3</span>);             <span class="comment">// val33</span></span><br><span class="line"></span><br><span class="line">map.computeIfPresent(<span class="number">9</span>, (num, val) -&gt; <span class="keyword">null</span>);</span><br><span class="line">map.containsKey(<span class="number">9</span>);     <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">map.computeIfAbsent(<span class="number">23</span>, num -&gt; <span class="string">&quot;val&quot;</span> + num);</span><br><span class="line">map.containsKey(<span class="number">23</span>);    <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">map.computeIfAbsent(<span class="number">3</span>, num -&gt; <span class="string">&quot;bam&quot;</span>);</span><br><span class="line">map.get(<span class="number">3</span>);             <span class="comment">// val33</span></span><br></pre></td></tr></table></figure><p>接下来展示如何在Map里删除一个键值全都匹配的项：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">map.remove(<span class="number">3</span>, <span class="string">&quot;val3&quot;</span>);</span><br><span class="line">map.get(<span class="number">3</span>);             <span class="comment">// val33</span></span><br><span class="line">map.remove(<span class="number">3</span>, <span class="string">&quot;val33&quot;</span>);</span><br><span class="line">map.get(<span class="number">3</span>);             <span class="comment">// null</span></span><br></pre></td></tr></table></figure><p>另外一个有用的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map.getOrDefault(<span class="number">42</span>, <span class="string">&quot;not found&quot;</span>);  <span class="comment">// not found</span></span><br></pre></td></tr></table></figure><p>对Map的元素做合并也变得很容易了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">map.merge(<span class="number">9</span>, <span class="string">&quot;val9&quot;</span>, (value, newValue) -&gt; value.concat(newValue));</span><br><span class="line">map.get(<span class="number">9</span>);             <span class="comment">// val9</span></span><br><span class="line">map.merge(<span class="number">9</span>, <span class="string">&quot;concat&quot;</span>, (value, newValue) -&gt; value.concat(newValue));</span><br><span class="line">map.get(<span class="number">9</span>);             <span class="comment">// val9concat</span></span><br></pre></td></tr></table></figure><p>Merge 做的事情是如果键名不存在则插入，否则则对原键对应的值做合并操作并重新插入到map中。</p><h2 id="Date-API-日期相关API"><a href="#Date-API-日期相关API" class="headerlink" title="Date API(日期相关API)"></a>Date API(日期相关API)</h2><p>Java 8在 <code>java.time</code> 包下包含一个全新的日期和时间API。新的Date API与Joda-Time库相似，但它们不一样。以下示例涵盖了此新 API 的最重要部分。译者对这部分内容参考相关书籍做了大部分修改。</p><p><strong>译者注(总结)：</strong></p><ul><li><p>Clock 类提供了访问当前日期和时间的方法，Clock 是时区敏感的，可以用来取代 <code>System.currentTimeMillis()</code> 来获取当前的微秒数。某一个特定的时间点也可以使用 <code>Instant</code> 类来表示，<code>Instant</code> 类也可以用来创建旧版本的<code>java.util.Date</code> 对象。</p></li><li><p>在新API中时区使用 ZoneId 来表示。时区可以很方便的使用静态方法of来获取到。 抽象类<code>ZoneId</code>（在<code>java.time</code>包中）表示一个区域标识符。 它有一个名为<code>getAvailableZoneIds</code>的静态方法，它返回所有区域标识符。</p></li><li><p>jdk1.8中新增了 LocalDate 与 LocalDateTime等类来解决日期处理方法，同时引入了一个新的类DateTimeFormatter 来解决日期格式化问题。可以使用Instant代替 Date，LocalDateTime代替 Calendar，DateTimeFormatter 代替 SimpleDateFormat。</p></li></ul><h3 id="Clock"><a href="#Clock" class="headerlink" title="Clock"></a>Clock</h3><p>Clock 类提供了访问当前日期和时间的方法，Clock 是时区敏感的，可以用来取代 <code>System.currentTimeMillis()</code> 来获取当前的微秒数。某一个特定的时间点也可以使用 <code>Instant</code> 类来表示，<code>Instant</code> 类也可以用来创建旧版本的<code>java.util.Date</code> 对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Clock clock = Clock.systemDefaultZone();</span><br><span class="line"><span class="keyword">long</span> millis = clock.millis();</span><br><span class="line">System.out.println(millis);<span class="comment">//1552379579043</span></span><br><span class="line">Instant instant = clock.instant();</span><br><span class="line">System.out.println(instant);</span><br><span class="line">Date legacyDate = Date.from(instant); <span class="comment">//2019-03-12T08:46:42.588Z</span></span><br><span class="line">System.out.println(legacyDate);<span class="comment">//Tue Mar 12 16:32:59 CST 2019</span></span><br></pre></td></tr></table></figure><h3 id="Timezones-时区"><a href="#Timezones-时区" class="headerlink" title="Timezones(时区)"></a>Timezones(时区)</h3><p>在新API中时区使用 ZoneId 来表示。时区可以很方便的使用静态方法of来获取到。 抽象类<code>ZoneId</code>（在<code>java.time</code>包中）表示一个区域标识符。 它有一个名为<code>getAvailableZoneIds</code>的静态方法，它返回所有区域标识符。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//输出所有区域标识符</span></span><br><span class="line">System.out.println(ZoneId.getAvailableZoneIds());</span><br><span class="line"></span><br><span class="line">ZoneId zone1 = ZoneId.of(<span class="string">&quot;Europe/Berlin&quot;</span>);</span><br><span class="line">ZoneId zone2 = ZoneId.of(<span class="string">&quot;Brazil/East&quot;</span>);</span><br><span class="line">System.out.println(zone1.getRules());<span class="comment">// ZoneRules[currentStandardOffset=+01:00]</span></span><br><span class="line">System.out.println(zone2.getRules());<span class="comment">// ZoneRules[currentStandardOffset=-03:00]</span></span><br></pre></td></tr></table></figure><h3 id="LocalTime-本地时间"><a href="#LocalTime-本地时间" class="headerlink" title="LocalTime(本地时间)"></a>LocalTime(本地时间)</h3><p>LocalTime 定义了一个没有时区信息的时间，例如 晚上10点或者 17:30:15。下面的例子使用前面代码创建的时区创建了两个本地时间。之后比较时间并以小时和分钟为单位计算两个时间的时间差：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">LocalTime now1 = LocalTime.now(zone1);</span><br><span class="line">LocalTime now2 = LocalTime.now(zone2);</span><br><span class="line">System.out.println(now1.isBefore(now2));  <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> hoursBetween = ChronoUnit.HOURS.between(now1, now2);</span><br><span class="line"><span class="keyword">long</span> minutesBetween = ChronoUnit.MINUTES.between(now1, now2);</span><br><span class="line"></span><br><span class="line">System.out.println(hoursBetween);       <span class="comment">// -3</span></span><br><span class="line">System.out.println(minutesBetween);     <span class="comment">// -239</span></span><br></pre></td></tr></table></figure><p>LocalTime 提供了多种工厂方法来简化对象的创建，包括解析时间字符串.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">LocalTime late = LocalTime.of(<span class="number">23</span>, <span class="number">59</span>, <span class="number">59</span>);</span><br><span class="line">System.out.println(late);       <span class="comment">// 23:59:59</span></span><br><span class="line">DateTimeFormatter germanFormatter =</span><br><span class="line">    DateTimeFormatter</span><br><span class="line">        .ofLocalizedTime(FormatStyle.SHORT)</span><br><span class="line">        .withLocale(Locale.GERMAN);</span><br><span class="line"></span><br><span class="line">LocalTime leetTime = LocalTime.parse(<span class="string">&quot;13:37&quot;</span>, germanFormatter);</span><br><span class="line">System.out.println(leetTime);   <span class="comment">// 13:37</span></span><br></pre></td></tr></table></figure><h3 id="LocalDate-本地日期"><a href="#LocalDate-本地日期" class="headerlink" title="LocalDate(本地日期)"></a>LocalDate(本地日期)</h3><p>LocalDate 表示了一个确切的日期，比如 2014-03-11。该对象值是不可变的，用起来和LocalTime基本一致。下面的例子展示了如何给Date对象加减天/月/年。另外要注意的是这些对象是不可变的，操作返回的总是一个新实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">LocalDate today = LocalDate.now();<span class="comment">//获取现在的日期</span></span><br><span class="line">System.out.println(<span class="string">&quot;今天的日期: &quot;</span>+today);<span class="comment">//2019-03-12</span></span><br><span class="line">LocalDate tomorrow = today.plus(<span class="number">1</span>, ChronoUnit.DAYS);</span><br><span class="line">System.out.println(<span class="string">&quot;明天的日期: &quot;</span>+tomorrow);<span class="comment">//2019-03-13</span></span><br><span class="line">LocalDate yesterday = tomorrow.minusDays(<span class="number">2</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;昨天的日期: &quot;</span>+yesterday);<span class="comment">//2019-03-11</span></span><br><span class="line">LocalDate independenceDay = LocalDate.of(<span class="number">2019</span>, Month.MARCH, <span class="number">12</span>);</span><br><span class="line">DayOfWeek dayOfWeek = independenceDay.getDayOfWeek();</span><br><span class="line">System.out.println(<span class="string">&quot;今天是周几:&quot;</span>+dayOfWeek);<span class="comment">//TUESDAY</span></span><br></pre></td></tr></table></figure><p>从字符串解析一个 LocalDate 类型和解析 LocalTime 一样简单,下面是使用  <code>DateTimeFormatter</code> 解析字符串的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="string">&quot;2014==04==12 01时06分09秒&quot;</span>;</span><br><span class="line">    <span class="comment">// 根据需要解析的日期、时间字符串定义解析所用的格式器</span></span><br><span class="line">    DateTimeFormatter fomatter1 = DateTimeFormatter</span><br><span class="line">            .ofPattern(<span class="string">&quot;yyyy==MM==dd HH时mm分ss秒&quot;</span>);</span><br><span class="line"></span><br><span class="line">    LocalDateTime dt1 = LocalDateTime.parse(str1, fomatter1);</span><br><span class="line">    System.out.println(dt1); <span class="comment">// 输出 2014-04-12T01:06:09</span></span><br><span class="line"></span><br><span class="line">    String str2 = <span class="string">&quot;2014$$$四月$$$13 20小时&quot;</span>;</span><br><span class="line">    DateTimeFormatter fomatter2 = DateTimeFormatter</span><br><span class="line">            .ofPattern(<span class="string">&quot;yyy$$$MMM$$$dd HH小时&quot;</span>);</span><br><span class="line">    LocalDateTime dt2 = LocalDateTime.parse(str2, fomatter2);</span><br><span class="line">    System.out.println(dt2); <span class="comment">// 输出 2014-04-13T20:00</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>再来看一个使用 <code>DateTimeFormatter</code> 格式化日期的示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">LocalDateTime rightNow=LocalDateTime.now();</span><br><span class="line">String date=DateTimeFormatter.ISO_LOCAL_DATE_TIME.format(rightNow);</span><br><span class="line">System.out.println(date);<span class="comment">//2019-03-12T16:26:48.29</span></span><br><span class="line">DateTimeFormatter formatter=DateTimeFormatter.ofPattern(<span class="string">&quot;YYYY-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">System.out.println(formatter.format(rightNow));<span class="comment">//2019-03-12 16:26:48</span></span><br></pre></td></tr></table></figure><h3 id="LocalDateTime-本地日期时间"><a href="#LocalDateTime-本地日期时间" class="headerlink" title="LocalDateTime(本地日期时间)"></a>LocalDateTime(本地日期时间)</h3><p>LocalDateTime 同时表示了时间和日期，相当于前两节内容合并到一个对象上了。LocalDateTime 和 LocalTime还有 LocalDate 一样，都是不可变的。LocalDateTime 提供了一些能访问具体字段的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">LocalDateTime sylvester = LocalDateTime.of(<span class="number">2014</span>, Month.DECEMBER, <span class="number">31</span>, <span class="number">23</span>, <span class="number">59</span>, <span class="number">59</span>);</span><br><span class="line"></span><br><span class="line">DayOfWeek dayOfWeek = sylvester.getDayOfWeek();</span><br><span class="line">System.out.println(dayOfWeek);      <span class="comment">// WEDNESDAY</span></span><br><span class="line"></span><br><span class="line">Month month = sylvester.getMonth();</span><br><span class="line">System.out.println(month);          <span class="comment">// DECEMBER</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> minuteOfDay = sylvester.getLong(ChronoField.MINUTE_OF_DAY);</span><br><span class="line">System.out.println(minuteOfDay);    <span class="comment">// 1439</span></span><br></pre></td></tr></table></figure><p>只要附加上时区信息，就可以将其转换为一个时间点Instant对象，Instant时间点对象可以很容易的转换为老式的<code>java.util.Date</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Instant instant = sylvester</span><br><span class="line">        .atZone(ZoneId.systemDefault())</span><br><span class="line">        .toInstant();</span><br><span class="line"></span><br><span class="line">Date legacyDate = Date.from(instant);</span><br><span class="line">System.out.println(legacyDate);     <span class="comment">// Wed Dec 31 23:59:59 CET 2014</span></span><br></pre></td></tr></table></figure><p>格式化LocalDateTime和格式化时间和日期一样的，除了使用预定义好的格式外，我们也可以自己定义格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DateTimeFormatter formatter =</span><br><span class="line">    DateTimeFormatter</span><br><span class="line">        .ofPattern(<span class="string">&quot;MMM dd, yyyy - HH:mm&quot;</span>);</span><br><span class="line">LocalDateTime parsed = LocalDateTime.parse(<span class="string">&quot;Nov 03, 2014 - 07:13&quot;</span>, formatter);</span><br><span class="line">String string = formatter.format(parsed);</span><br><span class="line">System.out.println(string);     <span class="comment">// Nov 03, 2014 - 07:13</span></span><br></pre></td></tr></table></figure><p>和java.text.NumberFormat不一样的是新版的DateTimeFormatter是不可变的，所以它是线程安全的。<br>关于时间日期格式的详细信息在<a href="https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html">这里</a>。</p><h2 id="Annotations-注解"><a href="#Annotations-注解" class="headerlink" title="Annotations(注解)"></a>Annotations(注解)</h2><p>在Java 8中支持多重注解了，先看个例子来理解一下是什么意思。<br>首先定义一个包装类Hints注解用来放置一组具体的Hint注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@interface</span> Hints &#123;</span><br><span class="line">    Hint[] value();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Repeatable(Hints.class)</span></span><br><span class="line"><span class="meta">@interface</span> Hint &#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java 8允许我们把同一个类型的注解使用多次，只需要给该注解标注一下<code>@Repeatable</code>即可。</p><p>例 1: 使用包装类当容器来存多个注解（老方法）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Hints(&#123;@Hint(&quot;hint1&quot;), @Hint(&quot;hint2&quot;)&#125;)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>例 2：使用多重注解（新方法）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Hint(&quot;hint1&quot;)</span></span><br><span class="line"><span class="meta">@Hint(&quot;hint2&quot;)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>第二个例子里java编译器会隐性的帮你定义好@Hints注解，了解这一点有助于你用反射来获取这些信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Hint hint = Person.class.getAnnotation(Hint.class);</span><br><span class="line">System.out.println(hint);                   <span class="comment">// null</span></span><br><span class="line">Hints hints1 = Person.class.getAnnotation(Hints.class);</span><br><span class="line">System.out.println(hints1.value().length);  <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">Hint[] hints2 = Person.class.getAnnotationsByType(Hint.class);</span><br><span class="line">System.out.println(hints2.length);          <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>即便我们没有在 <code>Person</code>类上定义 <code>@Hints</code>注解，我们还是可以通过 <code>getAnnotation(Hints.class) </code>来获取 <code>@Hints</code>注解，更加方便的方法是使用 <code>getAnnotationsByType</code> 可以直接获取到所有的<code>@Hint</code>注解。<br>另外Java 8的注解还增加到两种新的target上了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE_PARAMETER, ElementType.TYPE_USE&#125;)</span></span><br><span class="line"><span class="meta">@interface</span> MyAnnotation &#123;&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Java8新特性&quot;&gt;&lt;a href=&quot;#Java8新特性&quot; class=&quot;headerlink&quot; title=&quot;Java8新特性&quot;&gt;&lt;/a&gt;Java8新特性&lt;/h1&gt;&lt;h3 id=&quot;接口的默认方法-Default-Methods-for-Interfaces&quot;&gt;&lt;a href=&quot;#接口的默认方法-Default-Methods-for-Interfaces&quot; class=&quot;headerlink&quot; title=&quot;接口的默认方法(Default Methods for Interfaces)&quot;&gt;&lt;/a&gt;接口的默认方法(Default Methods for Interfaces)&lt;/h3&gt;&lt;p&gt;Java 8使我们能够通过使用 &lt;code&gt;default&lt;/code&gt; 关键字向接口添加非抽象方法实现。 此功能也称为&lt;a href=&quot;http://stackoverflow.com/a/24102730&quot;&gt;虚拟扩展方法&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;第一个例子：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Formula&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;calculate&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; a)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;default&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;sqrt&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; a)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; Math.sqrt(a);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;Formula 接口中除了抽象方法计算接口公式还定义了默认方法 &lt;code&gt;sqrt&lt;/code&gt;。 实现该接口的类只需要实现抽象方法 &lt;code&gt;calculate&lt;/code&gt;。 默认方法&lt;code&gt;sqrt&lt;/code&gt; 可以直接使用。当然你也可以直接通过接口创建对象，然后实现接口中的默认方法就可以了，我们通过代码演示一下这种方式。&lt;/p&gt;</summary>
    
    
    
    <category term="面试" scheme="http://plutowu.top/categories/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="Java" scheme="http://plutowu.top/categories/%E9%9D%A2%E8%AF%95/Java/"/>
    
    <category term="笔记" scheme="http://plutowu.top/categories/%E9%9D%A2%E8%AF%95/Java/%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>Java后端面试笔记-SQL</title>
    <link href="http://plutowu.top/2021/03/10/Java%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AE%B0-SQL/"/>
    <id>http://plutowu.top/2021/03/10/Java%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AE%B0-SQL/</id>
    <published>2021-03-10T14:24:57.000Z</published>
    <updated>2021-03-11T07:27:40.881Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SQL相关"><a href="#SQL相关" class="headerlink" title="SQL相关"></a>SQL相关</h1><h2 id="1-什么是索引？-MySQL中的索引"><a href="#1-什么是索引？-MySQL中的索引" class="headerlink" title="1.什么是索引？ MySQL中的索引"></a>1.什么是索引？ MySQL中的索引</h2><p><strong>索引是一种用于快速查询和检索数据的数据结构。常见的索引结构有: B 树， B+树和 Hash。</strong></p><p>索引的作用就相当于目录的作用。打个比方: 我们在查字典的时候，如果没有目录，那我们就只能一页一页的去找我们需要查的那个字，速度很慢。如果有目录了，我们只需要先去目录里查找字的位置，然后直接翻到那一页就行了。</p><p>MySQL索引使用的数据结构主要有<strong>BTree索引</strong> 和 <strong>哈希索引</strong> 。对于哈希索引来说，底层的数据结构就是哈希表，因此在绝大多数需求为单条记录查询的时候，可以选择哈希索引，查询性能最快；其余大部分场景，建议选择BTree索引。</p><p>MySQL的BTree索引使用的是B树中的B+Tree，但对于主要的两种存储引擎的实现方式是不同的。</p><ul><li><p><strong>MyISAM:</strong> B+Tree叶节点的data域存放的是数据记录的地址。在索引检索的时候，首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其 data 域的值，然后以 data 域的值为地址读取相应的数据记录。这被称为“非聚簇索引”。</p></li><li><p><strong>InnoDB:</strong> 其数据文件本身就是索引文件。相比MyISAM，索引文件和数据文件是分离的，其表数据文件本身就是按B+Tree组织的一个索引结构，树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。这被称为“聚簇索引（或聚集索引）”。而其余的索引都作为辅助索引，辅助索引的data域存储相应记录主键的值而不是地址，这也是和MyISAM不同的地方。<strong>在根据主索引搜索时，直接找到key所在的节点即可取出数据；在根据辅助索引查找时，则需要先取出主键的值，再走一遍主索引。</strong> <strong>因此，在设计表的时候，不建议使用过长的字段作为主键，也不建议使用非单调的字段作为主键，这样会造成主索引频繁分裂。</strong> </p><a id="more"></a></li></ul><h2 id="2-索引的优缺点"><a href="#2-索引的优缺点" class="headerlink" title="2.索引的优缺点"></a>2.索引的优缺点</h2><h3 id="索引的优点"><a href="#索引的优点" class="headerlink" title="索引的优点"></a>索引的优点</h3><p><strong>可以大大加快 数据的检索速度（大大减少的检索的数据量）, 这也是创建索引的最主要的原因。毕竟大部分系统的读请求总是大于写请求的。</strong> 另外，通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。</p><h3 id="索引的缺点"><a href="#索引的缺点" class="headerlink" title="索引的缺点"></a>索引的缺点</h3><ol><li><strong>创建索引和维护索引需要耗费许多时间</strong>：当对表中的数据进行增删改的时候，如果数据有索引，那么索引也需要动态的修改，会降低 SQL 执行效率。</li><li><strong>占用物理存储空间</strong> ：索引需要使用物理文件存储，也会耗费一定空间。</li></ol><h2 id="3-索引创建的原则"><a href="#3-索引创建的原则" class="headerlink" title="3.索引创建的原则"></a>3.索引创建的原则</h2><h3 id="单列索引"><a href="#单列索引" class="headerlink" title="单列索引"></a>单列索引</h3><p>单列索引即由一列属性组成的索引。</p><h3 id="联合索引-多列索引"><a href="#联合索引-多列索引" class="headerlink" title="联合索引(多列索引)"></a>联合索引(多列索引)</h3><p>联合索引即由多列属性组成索引。</p><h3 id="最左前缀原则"><a href="#最左前缀原则" class="headerlink" title="最左前缀原则"></a>最左前缀原则</h3><p>假设创建的联合索引由三个字段组成:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE table ADD INDEX index_name (num,name,age)</span><br></pre></td></tr></table></figure><p>那么当查询的条件有为:num / (num AND name) / (num AND name AND age)时，索引才生效。所以在创建联合索引时，尽量把查询最频繁的那个字段作为最左(第一个)字段。查询的时候也尽量以这个字段为第一条件。</p><h2 id="4-聚集索引与非聚集索引"><a href="#4-聚集索引与非聚集索引" class="headerlink" title="4.聚集索引与非聚集索引"></a>4.聚集索引与非聚集索引</h2><h3 id="聚集索引"><a href="#聚集索引" class="headerlink" title="聚集索引"></a>聚集索引</h3><p><strong>聚集索引即索引结构和数据一起存放的索引。主键索引属于聚集索引。</strong></p><p>在 Mysql 中，InnoDB 引擎的表的 <code>.ibd</code>文件就包含了该表的索引和数据，对于 InnoDB 引擎表来说，该表的索引(B+树)的每个非叶子节点存储索引，叶子节点存储索引和索引对应的数据。</p><h4 id="聚集索引的优点"><a href="#聚集索引的优点" class="headerlink" title="聚集索引的优点"></a>聚集索引的优点</h4><p>聚集索引的查询速度非常的快，因为整个 B+树本身就是一颗多叉平衡树，叶子节点也都是有序的，定位到索引的节点，就相当于定位到了数据。</p><h4 id="聚集索引的缺点"><a href="#聚集索引的缺点" class="headerlink" title="聚集索引的缺点"></a>聚集索引的缺点</h4><ol><li><strong>依赖于有序的数据</strong> ：因为 B+树是多路平衡树，如果索引的数据不是有序的，那么就需要在插入时排序，如果数据是整型还好，否则类似于字符串或 UUID 这种又长又难比较的数据，插入或查找的速度肯定比较慢。</li><li><strong>更新代价大</strong> ： 如果对索引列的数据被修改时，那么对应的索引也将会被修改，<br>而且况聚集索引的叶子节点还存放着数据，修改代价肯定是较大的，<br>所以对于主键索引来说，主键一般都是不可被修改的。</li></ol><h3 id="非聚集索引"><a href="#非聚集索引" class="headerlink" title="非聚集索引"></a>非聚集索引</h3><p><strong>非聚集索引即索引结构和数据分开存放的索引。</strong></p><p><strong>二级索引属于非聚集索引。</strong></p><blockquote><p>MYISAM 引擎的表的.MYI 文件包含了表的索引，<br>该表的索引(B+树)的每个叶子非叶子节点存储索引，<br>叶子节点存储索引和索引对应数据的指针，指向.MYD 文件的数据。</p><p><strong>非聚集索引的叶子节点并不一定存放数据的指针，<br>因为二级索引的叶子节点就存放的是主键，根据主键再回表查数据。</strong></p></blockquote><h4 id="非聚集索引的优点"><a href="#非聚集索引的优点" class="headerlink" title="非聚集索引的优点"></a>非聚集索引的优点</h4><p><strong>更新代价比聚集索引要小</strong> 。非聚集索引的更新代价就没有聚集索引那么大了，非聚集索引的叶子节点是不存放数据的</p><h4 id="非聚集索引的缺点"><a href="#非聚集索引的缺点" class="headerlink" title="非聚集索引的缺点"></a>非聚集索引的缺点</h4><ol><li>跟聚集索引一样，非聚集索引也依赖于有序的数据</li><li><strong>可能会二次查询(回表)</strong> :这应该是非聚集索引最大的缺点了。 当查到索引对应的指针或主键后，可能还需要根据指针或主键再到数据文件或表中查询。</li></ol><h2 id="5-覆盖索引"><a href="#5-覆盖索引" class="headerlink" title="5.覆盖索引"></a>5.覆盖索引</h2><p>如果一个索引包含（或者说覆盖）所有需要查询的字段的值，我们就称之为“覆盖索引”。我们知道在 InnoDB 存储引擎中，如果不是主键索引，叶子节点存储的是主键+列值。最终还是要“回表”，也就是要通过主键再查找一次。这样就会比较慢覆盖索引就是把要查询出的列和索引是对应的，不做回表操作！</p><p><strong>覆盖索引即需要查询的字段正好是索引的字段，那么直接根据该索引，就可以查到数据了，而无需回表查询。</strong></p><blockquote><p>如主键索引，如果一条 SQL 需要查询主键，那么正好根据主键索引就可以查到主键。</p><p>再如普通索引，如果一条 SQL 需要查询 name，name 字段正好有索引，<br>那么直接根据这个索引就可以查到数据，也无需回表。</p></blockquote><h2 id="6-事务的含义与特性-ACID"><a href="#6-事务的含义与特性-ACID" class="headerlink" title="6.事务的含义与特性(ACID)"></a>6.事务的含义与特性(ACID)</h2><p>事务是逻辑上的一组操作，要么都执行，要么都不执行。</p><p>事务最经典也经常被拿出来说例子就是转账了。假如小明要给小红转账1000元，这个转账会涉及到两个关键操作就是：将小明的余额减少1000元，将小红的余额增加1000元。万一在这两个操作之间突然出现错误比如银行系统崩溃，导致小明余额减少而小红的余额没有增加，这样就不对了。事务就是保证这两个关键操作要么都成功，要么都要失败。</p><p><img src="https://plutowu-blogimgs.oss-cn-guangzhou.aliyuncs.com/img/20210310193336.png"></p><ol><li> <strong>原子性：</strong> 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</li><li> <strong>一致性：</strong> 执行事务前后，数据保持一致，例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的；</li><li> <strong>隔离性：</strong> 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；</li><li> <strong>持久性：</strong> 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</li></ol><h2 id="7-并发事务带来的问题"><a href="#7-并发事务带来的问题" class="headerlink" title="7.并发事务带来的问题"></a>7.并发事务带来的问题</h2><p>在典型的应用程序中，多个事务并发运行，经常会操作相同的数据来完成各自的任务（多个用户对统一数据进行操作）。并发虽然是必须的，但可能会导致以下的问题。</p><ul><li><strong>脏读（Dirty read）:</strong> 当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。</li><li><strong>丢失修改（Lost to modify）:</strong> 指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。    例如：事务1读取某表中的数据A=20，事务2也读取A=20，事务1修改A=A-1，事务2也修改A=A-1，最终结果A=19，事务1的修改被丢失。</li><li><strong>不可重复读（Unrepeatableread）:</strong> 指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。</li><li><strong>幻读（Phantom read）:</strong> 幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。</li></ul><p><strong>不可重复度和幻读区别：</strong></p><p>不可重复读的重点是修改，幻读的重点在于新增或者删除。</p><p>例1（同样的条件, 你读取过的数据, 再次读取出来发现值不一样了）：事务1中的A先生读取自己的工资为1000的操作还没完成，事务2中的B先生就修改了A的工资为2000，导致A再读自己的工资时工资变为  2000；这就是不可重复读。</p><p> 例2（同样的条件, 第1次和第2次读出来的记录数不一样 ）：假某工资单表中工资大于3000的有4人，事务1读取了所有工资大于3000的人，共查到4条记录，这时事务2又插入了一条工资大于3000的记录，事务1再次读取时查到的记录就变为了5条，这样就导致了幻读。</p><h2 id="8-事务隔离级别"><a href="#8-事务隔离级别" class="headerlink" title="8.事务隔离级别"></a>8.事务隔离级别</h2><p><strong>SQL 标准定义了四个隔离级别：</strong></p><ul><li><strong>READ-UNCOMMITTED(读取未提交)：</strong> 最低的隔离级别，允许读取尚未提交的数据变更，<strong>可能会导致脏读、幻读或不可重复读</strong>。</li><li><strong>READ-COMMITTED(读取已提交)：</strong> 允许读取并发事务已经提交的数据，<strong>可以阻止脏读，但是幻读或不可重复读仍有可能发生</strong>。</li><li><strong>REPEATABLE-READ(可重复读)：</strong>  对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，<strong>可以阻止脏读和不可重复读，但幻读仍有可能发生</strong>。</li><li><strong>SERIALIZABLE(可串行化)：</strong> 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，<strong>该级别可以防止脏读、不可重复读以及幻读</strong>。</li></ul><table><thead><tr><th align="center">隔离级别</th><th align="center">脏读</th><th align="center">不可重复读</th><th align="center">幻影读</th></tr></thead><tbody><tr><td align="center">READ-UNCOMMITTED</td><td align="center">√</td><td align="center">√</td><td align="center">√</td></tr><tr><td align="center">READ-COMMITTED</td><td align="center">×</td><td align="center">√</td><td align="center">√</td></tr><tr><td align="center">REPEATABLE-READ</td><td align="center">×</td><td align="center">×</td><td align="center">√</td></tr><tr><td align="center">SERIALIZABLE</td><td align="center">×</td><td align="center">×</td><td align="center">×</td></tr></tbody></table><p>MySQL InnoDB 存储引擎的默认支持的隔离级别是 <strong>REPEATABLE-READ（可重读）</strong></p><p>这里需要注意的是：与 SQL 标准不同的地方在于InnoDB 存储引擎在 <strong>REPEATABLE-READ（可重读）</strong> 事务隔离级别下，允许应用使用 Next-Key Lock 锁算法来避免幻读的产生。这与其他数据库系统(如 SQL Server)是不同的。所以说虽然 InnoDB 存储引擎的默认支持的隔离级别是 <strong>REPEATABLE-READ（可重读）</strong> ，但是可以通过应用加锁读（例如 <code>select * from table for update</code> 语句）来保证不会产生幻读，而这个加锁度使用到的机制就是 Next-Key Lock 锁算法。从而达到了 SQL 标准的 <strong>SERIALIZABLE(可串行化)</strong> 隔离级别。</p><p>因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是<strong>READ-COMMITTED(读取提交内容):**，但是你要知道的是InnoDB 存储引擎默认使用 **REPEATABLE-READ（可重读）</strong> 并不会有任何性能损失。</p><p>InnoDB 存储引擎在 <strong>分布式事务</strong> 的情况下一般会用到<strong>SERIALIZABLE(可串行化)</strong> 隔离级别。</p><h2 id="9-Redis简单介绍"><a href="#9-Redis简单介绍" class="headerlink" title="9.Redis简单介绍"></a>9.Redis简单介绍</h2><p>简单来说 <strong>Redis 就是一个使用 C 语言开发的数据库</strong>，不过与传统数据库不同的是 <strong>Redis 的数据是存在内存中的</strong> ，也就是它是内存数据库，所以读写速度非常快，因此 Redis 被广泛应用于缓存方向。</p><p>另外，<strong>Redis 除了做缓存之外，Redis 也经常用来做分布式锁，甚至是消息队列。</strong></p><p><strong>Redis 提供了多种数据类型来支持不同的业务场景。Redis 还支持事务 、持久化、Lua 脚本、多种集群方案。</strong></p><p><strong>采用Redis或缓存是因为“高性能”和“高并发”</strong></p><h2 id="10-Redis-和-Memcached-的区别和共同点"><a href="#10-Redis-和-Memcached-的区别和共同点" class="headerlink" title="10.Redis 和 Memcached 的区别和共同点"></a>10.Redis 和 Memcached 的区别和共同点</h2><p><strong>共同点</strong> ：</p><ol><li>都是基于内存的数据库，一般都用来当做缓存使用。</li><li>都有过期策略。</li><li>两者的性能都非常高。</li></ol><p><strong>区别</strong> ：</p><ol><li><strong>Redis 支持更丰富的数据类型（支持更复杂的应用场景）</strong>。Redis 不仅仅支持简单的 k/v 类型的数据，同时还提供 list，set，zset，hash 等数据结构的存储。Memcached 只支持最简单的 k/v 数据类型。</li><li><strong>Redis 支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用,而 Memcached 把数据全部存在内存之中。</strong></li><li><strong>Redis 有灾难恢复机制。</strong> 因为可以把缓存中的数据持久化到磁盘上。</li><li><strong>Redis 在服务器内存使用完之后，可以将不用的数据放到磁盘上。但是，Memcached 在服务器内存使用完之后，就会直接报异常。</strong></li><li><strong>Memcached 没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据；但是 Redis 目前是原生支持 cluster 模式的.</strong></li><li><strong>Memcached 是多线程，非阻塞 IO 复用的网络模型；Redis 使用单线程的多路 IO 复用模型。</strong> （Redis 6.0 引入了多线程 IO ）</li><li><strong>Redis 支持发布订阅模型、Lua 脚本、事务等功能，而 Memcached 不支持。并且，Redis 支持更多的编程语言。</strong></li><li><strong>Memcached过期数据的删除策略只用了惰性删除，而 Redis 同时使用了惰性删除与定期删除。</strong></li></ol><h2 id="11-Redis常见数据结构"><a href="#11-Redis常见数据结构" class="headerlink" title="11.Redis常见数据结构"></a>11.Redis常见数据结构</h2><h3 id="11-1-string"><a href="#11-1-string" class="headerlink" title="11.1. string"></a>11.1. string</h3><ol><li><strong>介绍</strong> ：string 数据结构是简单的 key-value 类型。虽然 Redis 是用 C 语言写的，但是 Redis 并没有使用 C 的字符串表示，而是自己构建了一种 <strong>简单动态字符串</strong>（simple dynamic string，<strong>SDS</strong>）。相比于 C 的原生字符串，Redis 的 SDS 不光可以保存文本数据还可以保存二进制数据，并且获取字符串长度复杂度为 O(1)（C 字符串为 O(N)）,除此之外,Redis 的 SDS API 是安全的，不会造成缓冲区溢出。</li><li><strong>常用命令:</strong> <code>set,get,strlen,exists,dect,incr,setex</code> 等等。</li><li><strong>应用场景</strong> ：一般常用在需要计数的场景，比如用户的访问次数、热点文章的点赞转发数量等等。</li></ol><p>下面我们简单看看它的使用！</p><p><strong>普通字符串的基本操作：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> key value <span class="comment">#设置 key-value 类型的值</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get key <span class="comment"># 根据 key 获得对应的 value</span></span><br><span class="line"><span class="string">&quot;value&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; exists key  <span class="comment"># 判断某个 key 是否存在</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; strlen key <span class="comment"># 返回 key 所储存的字符串值的长度。</span></span><br><span class="line">(<span class="built_in">integer</span>) 5</span><br><span class="line">127.0.0.1:6379&gt; del key <span class="comment"># 删除某个 key 对应的值</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; get key</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure><p><strong>批量设置</strong> :</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; mset key1 value1 key2 value2 <span class="comment"># 批量设置 key-value 类型的值</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; mget key1 key2 <span class="comment"># 批量获取多个 key 对应的 value</span></span><br><span class="line">1) <span class="string">&quot;value1&quot;</span></span><br><span class="line">2) <span class="string">&quot;value2&quot;</span></span><br></pre></td></tr></table></figure><p><strong>计数器（字符串的内容为整数的时候可以使用）：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> number 1</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; incr number <span class="comment"># 将 key 中储存的数字值增一</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; get number</span><br><span class="line"><span class="string">&quot;2&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; decr number <span class="comment"># 将 key 中储存的数字值减一</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; get number</span><br><span class="line"><span class="string">&quot;1&quot;</span></span><br></pre></td></tr></table></figure><p><strong>过期</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; expire key  60 <span class="comment"># 数据在 60s 后过期</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; setex key 60 value <span class="comment"># 数据在 60s 后过期 (setex:[set] + [ex]pire)</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; ttl key <span class="comment"># 查看数据还有多久过期</span></span><br><span class="line">(<span class="built_in">integer</span>) 56</span><br></pre></td></tr></table></figure><h3 id="11-2-list"><a href="#11-2-list" class="headerlink" title="11.2. list"></a>11.2. list</h3><ol><li><strong>介绍</strong> ：<strong>list</strong> 即是 <strong>链表</strong>。链表是一种非常常见的数据结构，特点是易于数据元素的插入和删除并且且可以灵活调整链表长度，但是链表的随机访问困难。许多高级编程语言都内置了链表的实现比如 Java 中的 <strong>LinkedList</strong>，但是 C 语言并没有实现链表，所以 Redis 实现了自己的链表数据结构。Redis 的 list 的实现为一个 <strong>双向链表</strong>，即可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销。</li><li><strong>常用命令:</strong> <code>rpush,lpop,lpush,rpop,lrange、llen</code> 等。</li><li><strong>应用场景:</strong> 发布与订阅或者说消息队列、慢查询。</li></ol><p>下面我们简单看看它的使用！</p><p><strong>通过 <code>rpush/lpop</code> 实现队列：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; rpush myList value1 <span class="comment"># 向 list 的头部（右边）添加元素</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; rpush myList value2 value3 <span class="comment"># 向list的头部（最右边）添加多个元素</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; lpop myList <span class="comment"># 将 list的尾部(最左边)元素取出</span></span><br><span class="line"><span class="string">&quot;value1&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; lrange myList 0 1 <span class="comment"># 查看对应下标的list列表， 0 为 start,1为 end</span></span><br><span class="line">1) <span class="string">&quot;value2&quot;</span></span><br><span class="line">2) <span class="string">&quot;value3&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; lrange myList 0 -1 <span class="comment"># 查看列表中的所有元素，-1表示倒数第一</span></span><br><span class="line">1) <span class="string">&quot;value2&quot;</span></span><br><span class="line">2) <span class="string">&quot;value3&quot;</span></span><br></pre></td></tr></table></figure><p><strong>通过 <code>rpush/rpop</code> 实现栈：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; rpush myList2 value1 value2 value3</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; rpop myList2 <span class="comment"># 将 list的头部(最右边)元素取出</span></span><br><span class="line"><span class="string">&quot;value3&quot;</span></span><br></pre></td></tr></table></figure><p>我专门花了一个图方便小伙伴们来理解：</p><p><img src="https://plutowu-blogimgs.oss-cn-guangzhou.aliyuncs.com/img/redis-list.png" alt="redis list"></p><p><strong>通过 <code>lrange</code> 查看对应下标范围的列表元素：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; rpush myList value1 value2 value3</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; lrange myList 0 1 <span class="comment"># 查看对应下标的list列表， 0 为 start,1为 end</span></span><br><span class="line">1) <span class="string">&quot;value1&quot;</span></span><br><span class="line">2) <span class="string">&quot;value2&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; lrange myList 0 -1 <span class="comment"># 查看列表中的所有元素，-1表示倒数第一</span></span><br><span class="line">1) <span class="string">&quot;value1&quot;</span></span><br><span class="line">2) <span class="string">&quot;value2&quot;</span></span><br><span class="line">3) <span class="string">&quot;value3&quot;</span></span><br></pre></td></tr></table></figure><p>通过 <code>lrange</code> 命令，你可以基于 list 实现分页查询，性能非常高！</p><p><strong>通过 <code>llen</code> 查看链表长度：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; llen myList</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br></pre></td></tr></table></figure><h3 id="11-3-hash"><a href="#11-3-hash" class="headerlink" title="11.3. hash"></a>11.3. hash</h3><ol><li><strong>介绍</strong> ：hash 类似于 JDK1.8 前的 HashMap，内部实现也差不多(数组 + 链表)。不过，Redis 的 hash 做了更多优化。另外，hash 是一个 string 类型的 field 和 value 的映射表，<strong>特别适合用于存储对象</strong>，后续操作的时候，你可以直接仅仅修改这个对象中的某个字段的值。 比如我们可以 hash 数据结构来存储用户信息，商品信息等等。</li><li><strong>常用命令：</strong> <code>hset,hmset,hexists,hget,hgetall,hkeys,hvals</code> 等。</li><li><strong>应用场景:</strong> 系统中对象数据的存储。</li></ol><p>下面我们简单看看它的使用！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hset userInfoKey name <span class="string">&quot;guide&quot;</span> description <span class="string">&quot;dev&quot;</span> age <span class="string">&quot;24&quot;</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; hexists userInfoKey name <span class="comment"># 查看 key 对应的 value中指定的字段是否存在。</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; hget userInfoKey name <span class="comment"># 获取存储在哈希表中指定字段的值。</span></span><br><span class="line"><span class="string">&quot;guide&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; hget userInfoKey age</span><br><span class="line"><span class="string">&quot;24&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; hgetall userInfoKey <span class="comment"># 获取在哈希表中指定 key 的所有字段和值</span></span><br><span class="line">1) <span class="string">&quot;name&quot;</span></span><br><span class="line">2) <span class="string">&quot;guide&quot;</span></span><br><span class="line">3) <span class="string">&quot;description&quot;</span></span><br><span class="line">4) <span class="string">&quot;dev&quot;</span></span><br><span class="line">5) <span class="string">&quot;age&quot;</span></span><br><span class="line">6) <span class="string">&quot;24&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; hkeys userInfoKey <span class="comment"># 获取 key 列表</span></span><br><span class="line">1) <span class="string">&quot;name&quot;</span></span><br><span class="line">2) <span class="string">&quot;description&quot;</span></span><br><span class="line">3) <span class="string">&quot;age&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; hvals userInfoKey <span class="comment"># 获取 value 列表</span></span><br><span class="line">1) <span class="string">&quot;guide&quot;</span></span><br><span class="line">2) <span class="string">&quot;dev&quot;</span></span><br><span class="line">3) <span class="string">&quot;24&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; hset userInfoKey name <span class="string">&quot;GuideGeGe&quot;</span> <span class="comment"># 修改某个字段对应的值</span></span><br><span class="line">127.0.0.1:6379&gt; hget userInfoKey name</span><br><span class="line"><span class="string">&quot;GuideGeGe&quot;</span></span><br></pre></td></tr></table></figure><h3 id="11-4-set"><a href="#11-4-set" class="headerlink" title="11.4. set"></a>11.4. set</h3><ol><li><strong>介绍 ：</strong> set 类似于 Java 中的 <code>HashSet</code> 。Redis 中的 set 类型是一种无序集合，集合中的元素没有先后顺序。当你需要存储一个列表数据，又不希望出现重复数据时，set 是一个很好的选择，并且 set 提供了判断某个成员是否在一个 set 集合内的重要接口，这个也是 list 所不能提供的。可以基于 set 轻易实现交集、并集、差集的操作。比如：你可以将一个用户所有的关注人存在一个集合中，将其所有粉丝存在一个集合。Redis 可以非常方便的实现如共同关注、共同粉丝、共同喜好等功能。这个过程也就是求交集的过程。</li><li><strong>常用命令：</strong> <code>sadd,spop,smembers,sismember,scard,sinterstore,sunion</code> 等。</li><li><strong>应用场景:</strong> 需要存放的数据不能重复以及需要获取多个数据源交集和并集等场景</li></ol><p>下面我们简单看看它的使用！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sadd mySet value1 value2 <span class="comment"># 添加元素进去</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; sadd mySet value1 <span class="comment"># 不允许有重复元素</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; smembers mySet <span class="comment"># 查看 set 中所有的元素</span></span><br><span class="line">1) <span class="string">&quot;value1&quot;</span></span><br><span class="line">2) <span class="string">&quot;value2&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; scard mySet <span class="comment"># 查看 set 的长度</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; sismember mySet value1 <span class="comment"># 检查某个元素是否存在set 中，只能接收单个元素</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd mySet2 value2 value3</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; sinterstore mySet3 mySet mySet2 <span class="comment"># 获取 mySet 和 mySet2 的交集并存放在 mySet3 中</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; smembers mySet3</span><br><span class="line">1) <span class="string">&quot;value2&quot;</span></span><br></pre></td></tr></table></figure><h3 id="11-5-sorted-set"><a href="#11-5-sorted-set" class="headerlink" title="11.5. sorted set"></a>11.5. sorted set</h3><ol><li><strong>介绍：</strong> 和 set 相比，sorted set 增加了一个权重参数 score，使得集合中的元素能够按 score 进行有序排列，还可以通过 score 的范围来获取元素的列表。有点像是 Java 中 HashMap 和 TreeSet 的结合体。</li><li><strong>常用命令：</strong> <code>zadd,zcard,zscore,zrange,zrevrange,zrem</code> 等。</li><li><strong>应用场景：</strong> 需要对数据根据某个权重进行排序的场景。比如在直播系统中，实时排行信息包含直播间在线用户列表，各种礼物排行榜，弹幕消息（可以理解为按消息维度的消息排行榜）等信息。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zadd myZset 3.0 value1 <span class="comment"># 添加元素到 sorted set 中 3.0 为权重</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; zadd myZset 2.0 value2 1.0 value3 <span class="comment"># 一次添加多个元素</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; zcard myZset <span class="comment"># 查看 sorted set 中的元素数量</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; zscore myZset value1 <span class="comment"># 查看某个 value 的权重</span></span><br><span class="line"><span class="string">&quot;3&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; zrange  myZset 0 -1 <span class="comment"># 顺序输出某个范围区间的元素，0 -1 表示输出所有元素</span></span><br><span class="line">1) <span class="string">&quot;value3&quot;</span></span><br><span class="line">2) <span class="string">&quot;value2&quot;</span></span><br><span class="line">3) <span class="string">&quot;value1&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; zrange  myZset 0 1 <span class="comment"># 顺序输出某个范围区间的元素，0 为 start  1 为 stop</span></span><br><span class="line">1) <span class="string">&quot;value3&quot;</span></span><br><span class="line">2) <span class="string">&quot;value2&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; zrevrange  myZset 0 1 <span class="comment"># 逆序输出某个范围区间的元素，0 为 start  1 为 stop</span></span><br><span class="line">1) <span class="string">&quot;value1&quot;</span></span><br><span class="line">2) <span class="string">&quot;value2&quot;</span></span><br></pre></td></tr></table></figure><h2 id="12-Redis-内存淘汰机制"><a href="#12-Redis-内存淘汰机制" class="headerlink" title="12. Redis 内存淘汰机制"></a>12. Redis 内存淘汰机制</h2><blockquote><p>相关问题：MySQL 里有 2000w 数据，Redis 中只存 20w 的数据，如何保证 Redis 中的数据都是热点数据?</p></blockquote><p>Redis 提供 6 种数据淘汰策略：</p><ol><li><strong>volatile-lru（least recently used）</strong>：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰</li><li><strong>volatile-ttl</strong>：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰</li><li><strong>volatile-random</strong>：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰</li><li><strong>allkeys-lru（least recently used）</strong>：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 key（这个是最常用的）</li><li><strong>allkeys-random</strong>：从数据集（server.db[i].dict）中任意选择数据淘汰</li><li><strong>no-eviction</strong>：禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。这个应该没人使用吧！</li></ol><p>4.0 版本后增加以下两种：</p><ol start="7"><li><strong>volatile-lfu（least frequently used）</strong>：从已设置过期时间的数据集(server.db[i].expires)中挑选最不经常使用的数据淘汰</li><li><strong>allkeys-lfu（least frequently used）</strong>：当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的 key</li></ol><h2 id="13-缓存穿透"><a href="#13-缓存穿透" class="headerlink" title="13.缓存穿透"></a>13.缓存穿透</h2><h3 id="13-1-什么是缓存穿透？"><a href="#13-1-什么是缓存穿透？" class="headerlink" title="13.1. 什么是缓存穿透？"></a>13.1. 什么是缓存穿透？</h3><p>缓存穿透说简单点就是大量请求的 key 根本不存在于缓存中，导致请求直接到了数据库上，根本没有经过缓存这一层。举个例子：某个黑客故意制造我们缓存中不存在的 key 发起大量请求，导致大量请求落到数据库。</p><h3 id="13-2-缓存穿透情况的处理流程是怎样的？"><a href="#13-2-缓存穿透情况的处理流程是怎样的？" class="headerlink" title="13.2. 缓存穿透情况的处理流程是怎样的？"></a>13.2. 缓存穿透情况的处理流程是怎样的？</h3><p>如下图所示，用户的请求最终都要跑到数据库中查询一遍。</p><p><img src="https://plutowu-blogimgs.oss-cn-guangzhou.aliyuncs.com/img/%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E6%83%85%E5%86%B5.png" alt="缓存穿透情况"></p><h3 id="13-3-有哪些解决办法？"><a href="#13-3-有哪些解决办法？" class="headerlink" title="13.3. 有哪些解决办法？"></a>13.3. 有哪些解决办法？</h3><p>最基本的就是首先做好参数校验，一些不合法的参数请求直接抛出异常信息返回给客户端。比如查询的数据库 id 不能小于 0、传入的邮箱格式不对的时候直接返回错误消息给客户端等等。</p><p><strong>1）缓存无效 key</strong></p><p>如果缓存和数据库都查不到某个 key 的数据就写一个到 Redis 中去并设置过期时间，具体命令如下： <code>SET key value EX 10086</code> 。这种方式可以解决请求的 key 变化不频繁的情况，如果黑客恶意攻击，每次构建不同的请求 key，会导致 Redis 中缓存大量无效的 key 。很明显，这种方案并不能从根本上解决此问题。如果非要用这种方式来解决穿透问题的话，尽量将无效的 key 的过期时间设置短一点比如 1 分钟。</p><p>另外，这里多说一嘴，一般情况下我们是这样设计 key 的： <code>表名:列名:主键名:主键值</code> 。</p><p>如果用 Java 代码展示的话，差不多是下面这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getObjectInclNullById</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从缓存中获取数据</span></span><br><span class="line">    Object cacheValue = cache.get(id);</span><br><span class="line">    <span class="comment">// 缓存为空</span></span><br><span class="line">    <span class="keyword">if</span> (cacheValue == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 从数据库中获取</span></span><br><span class="line">        Object storageValue = storage.get(key);</span><br><span class="line">        <span class="comment">// 缓存空对象</span></span><br><span class="line">        cache.set(key, storageValue);</span><br><span class="line">        <span class="comment">// 如果存储数据为空，需要设置一个过期时间(300秒)</span></span><br><span class="line">        <span class="keyword">if</span> (storageValue == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 必须设置过期时间，否则有被攻击的风险</span></span><br><span class="line">            cache.expire(key, <span class="number">60</span> * <span class="number">5</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> storageValue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cacheValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2）布隆过滤器</strong></p><p>布隆过滤器是一个非常神奇的数据结构，通过它我们可以非常方便地判断一个给定数据是否存在于海量数据中。我们需要的就是判断 key 是否合法，有没有感觉布隆过滤器就是我们想要找的那个“人”。</p><p>具体是这样做的：把所有可能存在的请求的值都存放在布隆过滤器中，当用户请求过来，先判断用户发来的请求的值是否存在于布隆过滤器中。不存在的话，直接返回请求参数错误信息给客户端，存在的话才会走下面的流程。</p><p>加入布隆过滤器之后的缓存处理流程图如下。</p><p><img src="https://plutowu-blogimgs.oss-cn-guangzhou.aliyuncs.com/img/%E5%8A%A0%E5%85%A5%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E5%90%8E%E7%9A%84%E7%BC%93%E5%AD%98%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B.png" alt="image"></p><p>但是，需要注意的是布隆过滤器可能会存在误判的情况。总结来说就是： <strong>布隆过滤器说某个元素存在，小概率会误判。布隆过滤器说某个元素不在，那么这个元素一定不在。</strong></p><p><em>为什么会出现误判的情况呢? 我们还要从布隆过滤器的原理来说！</em></p><p>我们先来看一下，<strong>当一个元素加入布隆过滤器中的时候，会进行哪些操作：</strong></p><ol><li>使用布隆过滤器中的哈希函数对元素值进行计算，得到哈希值（有几个哈希函数得到几个哈希值）。</li><li>根据得到的哈希值，在位数组中把对应下标的值置为 1。</li></ol><p>我们再来看一下，<strong>当我们需要判断一个元素是否存在于布隆过滤器的时候，会进行哪些操作：</strong></p><ol><li>对给定元素再次进行相同的哈希计算；</li><li>得到值之后判断位数组中的每个元素是否都为 1，如果值都为 1，那么说明这个值在布隆过滤器中，如果存在一个值不为 1，说明该元素不在布隆过滤器中。</li></ol><p>然后，一定会出现这样一种情况：<strong>不同的字符串可能哈希出来的位置相同。</strong> （可以适当增加位数组大小或者调整我们的哈希函数来降低概率）</p><h2 id="14-缓存雪崩"><a href="#14-缓存雪崩" class="headerlink" title="14. 缓存雪崩"></a>14. 缓存雪崩</h2><h3 id="14-1-什么是缓存雪崩？"><a href="#14-1-什么是缓存雪崩？" class="headerlink" title="14.1. 什么是缓存雪崩？"></a>14.1. 什么是缓存雪崩？</h3><p>实际上，缓存雪崩描述的就是这样一个简单的场景：<strong>缓存在同一时间大面积的失效，后面的请求都直接落到了数据库上，造成数据库短时间内承受大量请求。</strong> 这就好比雪崩一样，摧枯拉朽之势，数据库的压力可想而知，可能直接就被这么多请求弄宕机了。</p><p>举个例子：系统的缓存模块出了问题比如宕机导致不可用。造成系统的所有访问，都要走数据库。</p><p>还有一种缓存雪崩的场景是：<strong>有一些被大量访问数据（热点缓存）在某一时刻大面积失效，导致对应的请求直接落到了数据库上。</strong> 这样的情况，有下面几种解决办法：</p><p>举个例子 ：秒杀开始 12 个小时之前，我们统一存放了一批商品到 Redis 中，设置的缓存过期时间也是 12 个小时，那么秒杀开始的时候，这些秒杀的商品的访问直接就失效了。导致的情况就是，相应的请求直接就落到了数据库上，就像雪崩一样可怕。</p><h3 id="14-2-有哪些解决办法？"><a href="#14-2-有哪些解决办法？" class="headerlink" title="14.2. 有哪些解决办法？"></a>14.2. 有哪些解决办法？</h3><p><strong>针对 Redis 服务不可用的情况：</strong></p><ol><li>采用 Redis 集群，避免单机出现问题整个缓存服务都没办法使用。</li><li>限流，避免同时处理大量的请求。</li></ol><p><strong>针对热点缓存失效的情况：</strong></p><ol><li>设置不同的失效时间比如随机设置缓存的失效时间。</li><li>缓存永不失效。</li></ol><h2 id="15-MySQL的内连接和外连接"><a href="#15-MySQL的内连接和外连接" class="headerlink" title="15.MySQL的内连接和外连接"></a>15.MySQL的内连接和外连接</h2><blockquote><p>内连接</p></blockquote><p><img src="https://plutowu-blogimgs.oss-cn-guangzhou.aliyuncs.com/img/986203-20170328114511029-1891784394.png" alt="img"></p><blockquote><p>左外连接</p></blockquote><p><img src="https://plutowu-blogimgs.oss-cn-guangzhou.aliyuncs.com/img/986203-20170328114619748-1184886553.png" alt="img"></p><blockquote><p>右外连接</p></blockquote><p><img src="https://plutowu-blogimgs.oss-cn-guangzhou.aliyuncs.com/img/986203-20170328114729811-38208863.png" alt="img"></p><blockquote><p>全连接（全外连接）</p></blockquote><p><strong>MySQL目前不支持此方式</strong></p><h2 id="16-悲观锁与乐观锁"><a href="#16-悲观锁与乐观锁" class="headerlink" title="16.悲观锁与乐观锁"></a>16.悲观锁与乐观锁</h2><blockquote><p>乐观锁对应于生活中乐观的人总是想着事情往好的方向发展，悲观锁对应于生活中悲观的人总是想着事情往坏的方向发展。这两种人各有优缺点，不能不以场景而定说一种人好于另外一种人。</p></blockquote><h4 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h4><p>总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（<strong>共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程</strong>）。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。Java中<code>synchronized</code>和<code>ReentrantLock</code>等独占锁就是悲观锁思想的实现。</p><h4 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h4><p>总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和CAS算法实现。<strong>乐观锁适用于多读的应用类型，这样可以提高吞吐量</strong>，像数据库提供的类似于<strong>write_condition机制</strong>，其实都是提供的乐观锁。在Java中<code>java.util.concurrent.atomic</code>包下面的原子变量类就是使用了乐观锁的一种实现方式<strong>CAS</strong>实现的。</p><h4 id="两种锁的使用场景"><a href="#两种锁的使用场景" class="headerlink" title="两种锁的使用场景"></a>两种锁的使用场景</h4><p>从上面对两种锁的介绍，我们知道两种锁各有优缺点，不可认为一种好于另一种，像<strong>乐观锁适用于写比较少的情况下（多读场景）</strong>，即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。但如果是多写的情况，一般会经常产生冲突，这就会导致上层应用会不断的进行retry，这样反倒是降低了性能，所以<strong>一般多写的场景下用悲观锁就比较合适。</strong></p><h2 id="17-乐观锁常见的两种实现方式"><a href="#17-乐观锁常见的两种实现方式" class="headerlink" title="17.乐观锁常见的两种实现方式"></a>17.乐观锁常见的两种实现方式</h2><blockquote><p><strong>乐观锁一般会使用版本号机制或CAS算法实现。</strong></p></blockquote><h4 id="1-版本号机制"><a href="#1-版本号机制" class="headerlink" title="1. 版本号机制"></a>1. 版本号机制</h4><p>一般是在数据表中加上一个数据版本号version字段，表示数据被修改的次数，当数据被修改时，version值会加一。当线程A要更新数据值时，在读取数据的同时也会读取version值，在提交更新时，若刚才读取到的version值为当前数据库中的version值相等时才更新，否则重试更新操作，直到更新成功。</p><p><strong>举一个简单的例子：</strong><br>假设数据库中帐户信息表中有一个 version 字段，当前值为 1 ；而当前帐户余额字段（ balance ）为 $100 。</p><ol><li>操作员 A 此时将其读出（ version=1 ），并从其帐户余额中扣除 $50（ $100-$50 ）。</li><li>在操作员 A 操作的过程中，操作员B 也读入此用户信息（ version=1 ），并从其帐户余额中扣除 $20 （ $100-$20 ）。</li><li>操作员 A 完成了修改工作，将数据版本号（ version=1 ），连同帐户扣除后余额（ balance=$50 ），提交至数据库更新，此时由于提交数据版本等于数据库记录当前版本，数据被更新，数据库记录 version 更新为 2 。</li><li>操作员 B 完成了操作，也将版本号（ version=1 ）试图向数据库提交数据（ balance=$80 ），但此时比对数据库记录版本时发现，操作员 B 提交的数据版本号为 1 ，数据库记录当前版本也为 2 ，不满足 “ 提交版本必须等于当前版本才能执行更新 “ 的乐观锁策略，因此，操作员 B 的提交被驳回。</li></ol><p>这样，就避免了操作员 B 用基于 version=1 的旧数据修改的结果覆盖操作员A 的操作结果的可能。</p><h4 id="2-CAS算法"><a href="#2-CAS算法" class="headerlink" title="2. CAS算法"></a>2. CAS算法</h4><p>即<strong>compare and swap（比较与交换）</strong>，是一种有名的<strong>无锁算法</strong>。无锁编程，即不使用锁的情况下实现多线程之间的变量同步，也就是在没有线程被阻塞的情况下实现变量的同步，所以也叫非阻塞同步（Non-blocking Synchronization）。<strong>CAS算法</strong>涉及到三个操作数</p><ul><li>需要读写的内存值 V </li><li>进行比较的值 A </li><li>拟写入的新值 B</li></ul><p>当且仅当 V 的值等于 A时，CAS通过原子方式用新值B来更新V的值，否则不会执行任何操作（比较和替换是一个原子操作）。一般情况下是一个<strong>自旋操作</strong>，即<strong>不断的重试</strong>。</p><h2 id="18-乐观锁的缺点"><a href="#18-乐观锁的缺点" class="headerlink" title="18.乐观锁的缺点"></a>18.乐观锁的缺点</h2><blockquote><p> ABA 问题是乐观锁一个常见的问题</p></blockquote><h4 id="1-ABA-问题"><a href="#1-ABA-问题" class="headerlink" title="1 ABA 问题"></a>1 ABA 问题</h4><p>如果一个变量V初次读取的时候是A值，并且在准备赋值的时候检查到它仍然是A值，那我们就能说明它的值没有被其他线程修改过了吗？很明显是不能的，因为在这段时间它的值可能被改为其他值，然后又改回A，那CAS操作就会误认为它从来没有被修改过。这个问题被称为CAS操作的 <strong>“ABA”问题。</strong></p><p>JDK 1.5 以后的 <code>AtomicStampedReference 类</code>就提供了此种能力，其中的 <code>compareAndSet 方法</code>就是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。</p><h4 id="2-循环时间长开销大"><a href="#2-循环时间长开销大" class="headerlink" title="2 循环时间长开销大"></a>2 循环时间长开销大</h4><p><strong>自旋CAS（也就是不成功就一直循环执行直到成功）如果长时间不成功，会给CPU带来非常大的执行开销。</strong> 如果JVM能支持处理器提供的pause指令那么效率会有一定的提升，pause指令有两个作用，第一它可以延迟流水线执行指令（de-pipeline）,使CPU不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。第二它可以避免在退出循环的时候因内存顺序冲突（memory order violation）而引起CPU流水线被清空（CPU pipeline flush），从而提高CPU的执行效率。</p><h4 id="3-只能保证一个共享变量的原子操作"><a href="#3-只能保证一个共享变量的原子操作" class="headerlink" title="3 只能保证一个共享变量的原子操作"></a>3 只能保证一个共享变量的原子操作</h4><p>CAS 只对单个共享变量有效，当操作涉及跨多个共享变量时 CAS 无效。但是从 JDK 1.5开始，提供了<code>AtomicReference类</code>来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行 CAS 操作.所以我们可以使用锁或者利用<code>AtomicReference类</code>把多个共享变量合并成一个共享变量来操作。</p><h2 id="19-CAS与synchronized的使用情景"><a href="#19-CAS与synchronized的使用情景" class="headerlink" title="19.CAS与synchronized的使用情景"></a>19.CAS与<code>synchronized</code>的使用情景</h2><blockquote><p><strong>简单的来说CAS适用于写比较少的情况下（多读场景，冲突一般较少），synchronized适用于写比较多的情况下（多写场景，冲突一般较多）</strong></p></blockquote><ol><li>对于资源竞争较少（线程冲突较轻）的情况，使用<code>synchronized</code>同步锁进行线程阻塞和唤醒切换以及用户态内核态间的切换操作额外浪费消耗CPU资源；而CAS基于硬件实现，不需要进入内核，不需要切换线程，操作自旋几率较少，因此可以获得更高的性能。</li><li>对于资源竞争严重（线程冲突严重）的情况，CAS自旋的概率会比较大，从而浪费更多的CPU资源，效率低于synchronized。</li></ol><p>补充： Java并发编程这个领域中<code>synchronized</code>关键字一直都是元老级的角色，很久之前很多人都会称它为 <strong>“重量级锁”</strong> 。但是，在JavaSE 1.6之后进行了主要包括为了减少获得锁和释放锁带来的性能消耗而引入的 <strong>偏向锁</strong> 和 <strong>轻量级锁</strong> 以及其它<strong>各种优化</strong>之后变得在某些情况下并不是那么重了。<code>synchronized</code>的底层实现主要依靠 <strong>Lock-Free</strong> 的队列，基本思路是 <strong>自旋后阻塞</strong>，<strong>竞争切换后继续竞争锁</strong>，<strong>稍微牺牲了公平性，但获得了高吞吐量</strong>。在线程冲突较少的情况下，可以获得和CAS类似的性能；而线程冲突严重的情况下，性能远高于CAS。</p><h2 id="20-Redis-哨兵-Sentinel-模式"><a href="#20-Redis-哨兵-Sentinel-模式" class="headerlink" title="20. Redis 哨兵(Sentinel)模式"></a>20. Redis 哨兵(Sentinel)模式</h2><p><strong>主从切换技术的方法是：当主服务器宕机后，需要手动把一台从服务器切换为主服务器，这就需要人工干预，费事费力，还会造成一段时间内服务不可用。</strong>这不是一种推荐的方式，更多时候，我们优先考虑<strong>哨兵模式</strong>。</p><h3 id="哨兵模式概述"><a href="#哨兵模式概述" class="headerlink" title="哨兵模式概述"></a>哨兵模式概述</h3><p>哨兵模式是一种特殊的模式，首先Redis提供了哨兵的命令，哨兵是一个独立的进程，作为进程，它会独立运行。其原理是<strong>哨兵通过发送命令，等待Redis服务器响应，从而监控运行的多个Redis实例。</strong></p><p><img src="https://plutowu-blogimgs.oss-cn-guangzhou.aliyuncs.com/img/11320039-57a77ca2757d0924.png" alt="img"></p><p>这里的哨兵有两个作用</p><ul><li>通过发送命令，让Redis服务器返回监控其运行状态，包括主服务器和从服务器。</li><li>当哨兵监测到master宕机，会自动将slave切换成master，然后通过<strong>发布订阅模式</strong>通知其他的从服务器，修改配置文件，让它们切换主机。</li></ul><p>然而一个哨兵进程对Redis服务器进行监控，可能会出现问题，为此，我们可以使用多个哨兵进行监控。各个哨兵之间还会进行监控，这样就形成了多哨兵模式。</p><p>用文字描述一下<strong>故障切换（failover）</strong>的过程。假设主服务器宕机，哨兵1先检测到这个结果，系统并不会马上进行failover过程，仅仅是哨兵1主观的认为主服务器不可用，这个现象成为<strong>主观下线</strong>。当后面的哨兵也检测到主服务器不可用，并且数量达到一定值时，那么哨兵之间就会进行一次投票，投票的结果由一个哨兵发起，进行failover操作。切换成功后，就会通过发布订阅模式，让各个哨兵把自己监控的从服务器实现切换主机，这个过程称为<strong>客观下线</strong>。这样对于客户端而言，一切都是透明的。</p><h3 id="Redis配置哨兵模式"><a href="#Redis配置哨兵模式" class="headerlink" title="Redis配置哨兵模式"></a>Redis配置哨兵模式</h3><p>配置3个哨兵和1主2从的Redis服务器来演示这个过程。</p><table><thead><tr><th>服务类型</th><th>是否是主服务器</th><th>IP地址</th><th>端口</th></tr></thead><tbody><tr><td>Redis</td><td>是</td><td>192.168.11.128</td><td>6379</td></tr><tr><td>Redis</td><td>否</td><td>192.168.11.129</td><td>6379</td></tr><tr><td>Redis</td><td>否</td><td>192.168.11.130</td><td>6379</td></tr><tr><td>Sentinel</td><td>-</td><td>192.168.11.128</td><td>26379</td></tr><tr><td>Sentinel</td><td>-</td><td>192.168.11.129</td><td>26379</td></tr><tr><td>Sentinel</td><td>-</td><td>192.168.11.130</td><td>26379</td></tr></tbody></table><p><img src="https://plutowu-blogimgs.oss-cn-guangzhou.aliyuncs.com/img/11320039-3f40b17c0412116c.png" alt="img"></p><p>首先配置Redis的主从服务器，修改redis.conf文件如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使得Redis服务器可以跨网络访问</span></span><br><span class="line"><span class="built_in">bind</span> 0.0.0.0</span><br><span class="line"><span class="comment"># 设置密码</span></span><br><span class="line">requirepass <span class="string">&quot;123456&quot;</span></span><br><span class="line"><span class="comment"># 指定主服务器，注意：有关slaveof的配置只是配置从服务器，主服务器不需要配置</span></span><br><span class="line">slaveof 192.168.11.128 6379</span><br><span class="line"><span class="comment"># 主服务器密码，注意：有关slaveof的配置只是配置从服务器，主服务器不需要配置</span></span><br><span class="line">masterauth 123456</span><br></pre></td></tr></table></figure><p>上述内容主要是配置Redis服务器，从服务器比主服务器多一个slaveof的配置和密码。</p><p>配置3个哨兵，每个哨兵的配置都是一样的。在Redis安装目录下有一个sentinel.conf文件，copy一份进行修改</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 禁止保护模式</span><br><span class="line"><span class="selector-tag">protected-mode</span> <span class="selector-tag">no</span></span><br><span class="line"># 配置监听的主服务器，这里<span class="selector-tag">sentinel</span> <span class="selector-tag">monitor</span>代表监控，<span class="selector-tag">mymaster</span>代表服务器的名称，可以自定义，192<span class="selector-class">.168</span><span class="selector-class">.11</span><span class="selector-class">.128</span>代表监控的主服务器，6379代表端口，2代表只有两个或两个以上的哨兵认为主服务器不可用的时候，才会进行<span class="selector-tag">failover</span>操作。</span><br><span class="line"><span class="selector-tag">sentinel</span> <span class="selector-tag">monitor</span> <span class="selector-tag">mymaster</span> 192<span class="selector-class">.168</span><span class="selector-class">.11</span><span class="selector-class">.128</span> 6379 2</span><br><span class="line"># <span class="selector-tag">sentinel</span> <span class="selector-tag">author-pass</span>定义服务的密码，<span class="selector-tag">mymaster</span>是服务名称，123456是<span class="selector-tag">Redis</span>服务器密码</span><br><span class="line"># <span class="selector-tag">sentinel</span> <span class="selector-tag">auth-pass</span> &lt;<span class="selector-tag">master-name</span>&gt; &lt;<span class="selector-tag">password</span>&gt;</span><br><span class="line"><span class="selector-tag">sentinel</span> <span class="selector-tag">auth-pass</span> <span class="selector-tag">mymaster</span> 123456</span><br></pre></td></tr></table></figure><p>上述关闭了保护模式，便于测试。</p><p>有了上述的修改，我们可以进入Redis的安装目录的src目录，通过下面的命令启动服务器和哨兵</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动Redis服务器进程</span></span><br><span class="line">./redis-server ../redis.conf</span><br><span class="line"><span class="comment"># 启动哨兵进程</span></span><br><span class="line">./redis-sentinel ../sentinel.conf</span><br></pre></td></tr></table></figure><p>注意启动的顺序。<strong>首先是主机（192.168.11.128）的Redis服务进程，然后启动从机的服务进程，最后启动3个哨兵的服务进程。</strong></p><h3 id="Java中使用哨兵模式"><a href="#Java中使用哨兵模式" class="headerlink" title="Java中使用哨兵模式"></a>Java中使用哨兵模式</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试Redis哨兵模式</span></span><br><span class="line"><span class="comment"> * @author liu</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestSentinels</span> &#123;</span><br><span class="line">    @SuppressWarnings(<span class="string">&quot;resource&quot;</span>)</span><br><span class="line">    @Test</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSentinel</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        JedisPoolConfig jedisPoolConfig = <span class="keyword">new</span> JedisPoolConfig();</span><br><span class="line">        jedisPoolConfig.setMaxTotal(<span class="number">10</span>);</span><br><span class="line">        jedisPoolConfig.setMaxIdle(<span class="number">5</span>);</span><br><span class="line">        jedisPoolConfig.setMinIdle(<span class="number">5</span>);</span><br><span class="line">        <span class="comment">// 哨兵信息</span></span><br><span class="line">        Set&lt;String&gt; sentinels = <span class="keyword">new</span> HashSet&lt;&gt;(Arrays.asList(<span class="string">&quot;192.168.11.128:26379&quot;</span>,</span><br><span class="line">                <span class="string">&quot;192.168.11.129:26379&quot;</span>,<span class="string">&quot;192.168.11.130:26379&quot;</span>));</span><br><span class="line">        <span class="comment">// 创建连接池</span></span><br><span class="line">        JedisSentinelPool pool = <span class="keyword">new</span> JedisSentinelPool(<span class="string">&quot;mymaster&quot;</span>, sentinels,jedisPoolConfig,<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取客户端</span></span><br><span class="line">        Jedis jedis = pool.getResource();</span><br><span class="line">        <span class="comment">// 执行两个命令</span></span><br><span class="line">        jedis.<span class="keyword">set</span>(<span class="string">&quot;mykey&quot;</span>, <span class="string">&quot;myvalue&quot;</span>);</span><br><span class="line">        String <span class="keyword">value</span> = jedis.<span class="keyword">get</span>(<span class="string">&quot;mykey&quot;</span>);</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="keyword">value</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面是通过Jedis进行使用的，同样也可以使用Spring进行配置RedisTemplate使用。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id = <span class="string">&quot;poolConfig&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;redis.clients.jedis.JedisPoolConfig&quot;</span>&gt;</span><br><span class="line">    &lt;!-- 最大空闲数 --&gt;</span><br><span class="line">    &lt;property name=<span class="string">&quot;maxIdle&quot;</span> value=<span class="string">&quot;50&quot;</span>&gt;&lt;/property&gt;</span><br><span class="line">    &lt;!-- 最大连接数 --&gt;</span><br><span class="line">    &lt;property name=<span class="string">&quot;maxTotal&quot;</span> value=<span class="string">&quot;100&quot;</span>&gt;&lt;/property&gt;</span><br><span class="line">    &lt;!-- 最大等待时间 --&gt;</span><br><span class="line">    &lt;property name=<span class="string">&quot;maxWaitMillis&quot;</span> value=<span class="string">&quot;20000&quot;</span>&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id=<span class="string">&quot;connectionFactory&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;org.springframework.data.redis.connection.jedis.JedisConnectionFactory&quot;</span>&gt;</span><br><span class="line">    &lt;<span class="title">constructor</span>-<span class="title">arg</span> <span class="title">name</span>=&quot;<span class="title">poolConfig</span>&quot; <span class="title">ref</span>=&quot;<span class="title">poolConfig</span>&quot;&gt;&lt;/<span class="title">constructor</span>-<span class="title">arg</span>&gt;</span><br><span class="line">    &lt;<span class="title">constructor</span>-<span class="title">arg</span> <span class="title">name</span>=&quot;<span class="title">sentinelConfig</span>&quot; <span class="title">ref</span>=&quot;<span class="title">sentinelConfig</span>&quot;&gt;&lt;/<span class="title">constructor</span>-<span class="title">arg</span>&gt;</span><br><span class="line">    &lt;<span class="title">property</span> <span class="title">name</span>=&quot;<span class="title">password</span>&quot; <span class="title">value</span>=&quot;123456&quot;&gt;&lt;/<span class="title">property</span>&gt;</span><br><span class="line">&lt;/<span class="title">bean</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- <span class="title">JDK</span>序列化器 --&gt;</span><br><span class="line">&lt;<span class="title">bean</span> <span class="title">id</span>=&quot;<span class="title">jdkSerializationRedisSerializer</span>&quot; <span class="title">class</span>=&quot;<span class="title">org</span>.<span class="title">springframework</span>.<span class="title">data</span>.<span class="title">redis</span>.<span class="title">serializer</span>.<span class="title">JdkSerializationRedisSerializer</span>&quot;&gt;&lt;/<span class="title">bean</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- <span class="title">String</span>序列化器 --&gt;</span><br><span class="line">&lt;<span class="title">bean</span> <span class="title">id</span>=&quot;<span class="title">stringRedisSerializer</span>&quot; <span class="title">class</span>=&quot;<span class="title">org</span>.<span class="title">springframework</span>.<span class="title">data</span>.<span class="title">redis</span>.<span class="title">serializer</span>.<span class="title">StringRedisSerializer</span>&quot;&gt;&lt;/<span class="title">bean</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;<span class="title">bean</span> <span class="title">id</span>=&quot;<span class="title">redisTemplate</span>&quot; <span class="title">class</span>=&quot;<span class="title">org</span>.<span class="title">springframework</span>.<span class="title">data</span>.<span class="title">redis</span>.<span class="title">core</span>.<span class="title">RedisTemplate</span>&quot;&gt;</span><br><span class="line">    &lt;<span class="title">property</span> <span class="title">name</span>=&quot;<span class="title">connectionFactory</span>&quot; <span class="title">ref</span>=&quot;<span class="title">connectionFactory</span>&quot;&gt;&lt;/<span class="title">property</span>&gt;</span><br><span class="line">    &lt;<span class="title">property</span> <span class="title">name</span>=&quot;<span class="title">keySerializer</span>&quot; <span class="title">ref</span>=&quot;<span class="title">stringRedisSerializer</span>&quot;&gt;&lt;/<span class="title">property</span>&gt;</span><br><span class="line">    &lt;<span class="title">property</span> <span class="title">name</span>=&quot;<span class="title">defaultSerializer</span>&quot; <span class="title">ref</span>=&quot;<span class="title">stringRedisSerializer</span>&quot;&gt;&lt;/<span class="title">property</span>&gt;</span><br><span class="line">    &lt;<span class="title">property</span> <span class="title">name</span>=&quot;<span class="title">valueSerializer</span>&quot; <span class="title">ref</span>=&quot;<span class="title">jdkSerializationRedisSerializer</span>&quot;&gt;&lt;/<span class="title">property</span>&gt;</span><br><span class="line">&lt;/<span class="title">bean</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 哨兵配置 --&gt;</span><br><span class="line">&lt;<span class="title">bean</span> <span class="title">id</span>=&quot;<span class="title">sentinelConfig</span>&quot; <span class="title">class</span>=&quot;<span class="title">org</span>.<span class="title">springframework</span>.<span class="title">data</span>.<span class="title">redis</span>.<span class="title">connection</span>.<span class="title">RedisSentinelConfiguration</span>&quot;&gt;</span><br><span class="line">    &lt;!-- 服务名称 --&gt;</span><br><span class="line">    &lt;<span class="title">property</span> <span class="title">name</span>=&quot;<span class="title">master</span>&quot;&gt;</span><br><span class="line">        &lt;<span class="title">bean</span> <span class="title">class</span>=&quot;<span class="title">org</span>.<span class="title">springframework</span>.<span class="title">data</span>.<span class="title">redis</span>.<span class="title">connection</span>.<span class="title">RedisNode</span>&quot;&gt;</span><br><span class="line">            &lt;<span class="title">property</span> <span class="title">name</span>=&quot;<span class="title">name</span>&quot; <span class="title">value</span>=&quot;<span class="title">mymaster</span>&quot;&gt;&lt;/<span class="title">property</span>&gt;</span><br><span class="line">        &lt;/<span class="title">bean</span>&gt;</span><br><span class="line">    &lt;/<span class="title">property</span>&gt;</span><br><span class="line">    &lt;!-- 哨兵服务<span class="title">IP</span>和端口 --&gt;</span><br><span class="line">    &lt;<span class="title">property</span> <span class="title">name</span>=&quot;<span class="title">sentinels</span>&quot;&gt;</span><br><span class="line">        &lt;<span class="title">set</span>&gt;</span><br><span class="line">            &lt;<span class="title">bean</span> <span class="title">class</span>=&quot;<span class="title">org</span>.<span class="title">springframework</span>.<span class="title">data</span>.<span class="title">redis</span>.<span class="title">connection</span>.<span class="title">RedisNode</span>&quot;&gt;</span><br><span class="line">                &lt;<span class="title">constructor</span>-<span class="title">arg</span> <span class="title">name</span>=&quot;<span class="title">host</span>&quot; <span class="title">value</span>=&quot;192.168.11.128&quot;&gt;&lt;/<span class="title">constructor</span>-<span class="title">arg</span>&gt;</span><br><span class="line">                &lt;<span class="title">constructor</span>-<span class="title">arg</span> <span class="title">name</span>=&quot;<span class="title">port</span>&quot; <span class="title">value</span>=&quot;26379&quot;&gt;&lt;/<span class="title">constructor</span>-<span class="title">arg</span>&gt;</span><br><span class="line">            &lt;/<span class="title">bean</span>&gt;</span><br><span class="line">            &lt;<span class="title">bean</span> <span class="title">class</span>=&quot;<span class="title">org</span>.<span class="title">springframework</span>.<span class="title">data</span>.<span class="title">redis</span>.<span class="title">connection</span>.<span class="title">RedisNode</span>&quot;&gt;</span><br><span class="line">                &lt;<span class="title">constructor</span>-<span class="title">arg</span> <span class="title">name</span>=&quot;<span class="title">host</span>&quot; <span class="title">value</span>=&quot;192.168.11.129&quot;&gt;&lt;/<span class="title">constructor</span>-<span class="title">arg</span>&gt;</span><br><span class="line">                &lt;<span class="title">constructor</span>-<span class="title">arg</span> <span class="title">name</span>=&quot;<span class="title">port</span>&quot; <span class="title">value</span>=&quot;26379&quot;&gt;&lt;/<span class="title">constructor</span>-<span class="title">arg</span>&gt;</span><br><span class="line">            &lt;/<span class="title">bean</span>&gt;</span><br><span class="line">            &lt;<span class="title">bean</span> <span class="title">class</span>=&quot;<span class="title">org</span>.<span class="title">springframework</span>.<span class="title">data</span>.<span class="title">redis</span>.<span class="title">connection</span>.<span class="title">RedisNode</span>&quot;&gt;</span><br><span class="line">                &lt;<span class="title">constructor</span>-<span class="title">arg</span> <span class="title">name</span>=&quot;<span class="title">host</span>&quot; <span class="title">value</span>=&quot;192.168.11.130&quot;&gt;&lt;/<span class="title">constructor</span>-<span class="title">arg</span>&gt;</span><br><span class="line">                &lt;<span class="title">constructor</span>-<span class="title">arg</span> <span class="title">name</span>=&quot;<span class="title">port</span>&quot; <span class="title">value</span>=&quot;26379&quot;&gt;&lt;/<span class="title">constructor</span>-<span class="title">arg</span>&gt;</span><br><span class="line">            &lt;/<span class="title">bean</span>&gt;</span><br><span class="line">        &lt;/<span class="title">set</span>&gt;</span><br><span class="line">    &lt;/<span class="title">property</span>&gt;</span><br><span class="line">&lt;/<span class="title">bean</span>&gt;</span><br></pre></td></tr></table></figure><h3 id="哨兵模式的其他配置项"><a href="#哨兵模式的其他配置项" class="headerlink" title="哨兵模式的其他配置项"></a>哨兵模式的其他配置项</h3><table><thead><tr><th>配置项</th><th>参数类型</th><th>作用</th></tr></thead><tbody><tr><td>port</td><td>整数</td><td>启动哨兵进程端口</td></tr><tr><td>dir</td><td>文件夹目录</td><td>哨兵进程服务临时文件夹，默认为/tmp，要保证有可写入的权限</td></tr><tr><td>sentinel down-after-milliseconds</td><td>&lt;服务名称&gt;&lt;毫秒数（整数）&gt;</td><td>指定哨兵在监控Redis服务时，当Redis服务在一个默认毫秒数内都无法回答时，单个哨兵认为的主观下线时间，默认为30000（30秒）</td></tr><tr><td>sentinel parallel-syncs</td><td>&lt;服务名称&gt;&lt;服务器数（整数）&gt;</td><td>指定可以有多少个Redis服务同步新的主机，一般而言，这个数字越小同步时间越长，而越大，则对网络资源要求越高</td></tr><tr><td>sentinel failover-timeout</td><td>&lt;服务名称&gt;&lt;毫秒数（整数）&gt;</td><td>指定故障切换允许的毫秒数，超过这个时间，就认为故障切换失败，默认为3分钟</td></tr><tr><td>sentinel notification-script</td><td>&lt;服务名称&gt;&lt;脚本路径&gt;</td><td>指定sentinel检测到该监控的redis实例指向的实例异常时，调用的报警脚本。该配置项可选，比较常用</td></tr></tbody></table><p>sentinel down-after-milliseconds配置项只是一个哨兵在超过规定时间依旧没有得到响应后，会自己认为主机不可用。对于其他哨兵而言，并不是这样认为。哨兵会记录这个消息，当拥有认为主观下线的哨兵达到sentinel monitor所配置的数量时，就会发起一次投票，进行failover，此时哨兵会重写Redis的哨兵配置文件，以适应新场景的需要。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;SQL相关&quot;&gt;&lt;a href=&quot;#SQL相关&quot; class=&quot;headerlink&quot; title=&quot;SQL相关&quot;&gt;&lt;/a&gt;SQL相关&lt;/h1&gt;&lt;h2 id=&quot;1-什么是索引？-MySQL中的索引&quot;&gt;&lt;a href=&quot;#1-什么是索引？-MySQL中的索引&quot; class=&quot;headerlink&quot; title=&quot;1.什么是索引？ MySQL中的索引&quot;&gt;&lt;/a&gt;1.什么是索引？ MySQL中的索引&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;索引是一种用于快速查询和检索数据的数据结构。常见的索引结构有: B 树， B+树和 Hash。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;索引的作用就相当于目录的作用。打个比方: 我们在查字典的时候，如果没有目录，那我们就只能一页一页的去找我们需要查的那个字，速度很慢。如果有目录了，我们只需要先去目录里查找字的位置，然后直接翻到那一页就行了。&lt;/p&gt;
&lt;p&gt;MySQL索引使用的数据结构主要有&lt;strong&gt;BTree索引&lt;/strong&gt; 和 &lt;strong&gt;哈希索引&lt;/strong&gt; 。对于哈希索引来说，底层的数据结构就是哈希表，因此在绝大多数需求为单条记录查询的时候，可以选择哈希索引，查询性能最快；其余大部分场景，建议选择BTree索引。&lt;/p&gt;
&lt;p&gt;MySQL的BTree索引使用的是B树中的B+Tree，但对于主要的两种存储引擎的实现方式是不同的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;MyISAM:&lt;/strong&gt; B+Tree叶节点的data域存放的是数据记录的地址。在索引检索的时候，首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其 data 域的值，然后以 data 域的值为地址读取相应的数据记录。这被称为“非聚簇索引”。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;InnoDB:&lt;/strong&gt; 其数据文件本身就是索引文件。相比MyISAM，索引文件和数据文件是分离的，其表数据文件本身就是按B+Tree组织的一个索引结构，树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。这被称为“聚簇索引（或聚集索引）”。而其余的索引都作为辅助索引，辅助索引的data域存储相应记录主键的值而不是地址，这也是和MyISAM不同的地方。&lt;strong&gt;在根据主索引搜索时，直接找到key所在的节点即可取出数据；在根据辅助索引查找时，则需要先取出主键的值，再走一遍主索引。&lt;/strong&gt; &lt;strong&gt;因此，在设计表的时候，不建议使用过长的字段作为主键，也不建议使用非单调的字段作为主键，这样会造成主索引频繁分裂。&lt;/strong&gt; &lt;/p&gt;</summary>
    
    
    
    <category term="面试" scheme="http://plutowu.top/categories/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="SQL" scheme="http://plutowu.top/categories/%E9%9D%A2%E8%AF%95/SQL/"/>
    
    <category term="笔记" scheme="http://plutowu.top/categories/%E9%9D%A2%E8%AF%95/SQL/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="笔记" scheme="http://plutowu.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Java" scheme="http://plutowu.top/tags/Java/"/>
    
    <category term="面试" scheme="http://plutowu.top/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="SQL" scheme="http://plutowu.top/tags/SQL/"/>
    
    <category term="MySQL" scheme="http://plutowu.top/tags/MySQL/"/>
    
    <category term="Redis" scheme="http://plutowu.top/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Java后端面试笔记-框架</title>
    <link href="http://plutowu.top/2021/03/10/Java%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AE%B0-%E6%A1%86%E6%9E%B6/"/>
    <id>http://plutowu.top/2021/03/10/Java%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AE%B0-%E6%A1%86%E6%9E%B6/</id>
    <published>2021-03-10T14:24:50.000Z</published>
    <updated>2021-03-22T02:28:24.532Z</updated>
    
    <content type="html"><![CDATA[<h1 id="框架相关"><a href="#框架相关" class="headerlink" title="框架相关"></a>框架相关</h1><h2 id="1-SpringBoot-自动装配原理"><a href="#1-SpringBoot-自动装配原理" class="headerlink" title="1.SpringBoot 自动装配原理"></a>1.SpringBoot 自动装配原理</h2><h3 id="什么是-SpringBoot-自动装配？"><a href="#什么是-SpringBoot-自动装配？" class="headerlink" title="什么是 SpringBoot 自动装配？"></a>什么是 SpringBoot 自动装配？</h3><p>我们现在提到自动装配的时候，一般会和 Spring Boot 联系在一起。但是，实际上 Spring Framework 早就实现了这个功能。Spring Boot 只是在其基础上，通过 SPI 的方式，做了进一步优化。</p><blockquote><p>SpringBoot 定义了一套接口规范，这套规范规定：SpringBoot 在启动时会扫描外部引用 jar 包中的<code>META-INF/spring.factories</code>文件，将文件中配置的类型信息加载到 Spring 容器（此处涉及到 JVM 类加载机制与 Spring 的容器知识），并执行类中定义的各种操作。对于外部 jar 来说，只需要按照 SpringBoot 定义的标准，就能将自己的功能装置进 SpringBoot。</p></blockquote><p>没有 Spring Boot 的情况下，如果我们需要引入第三方依赖，需要手动配置，非常麻烦。但是，Spring Boot 中，我们直接引入一个 starter 即可。比如你想要在项目中使用 redis 的话，直接在项目中引入对应的 starter 即可。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>引入 starter 之后，我们通过少量注解和一些简单的配置就能使用第三方组件提供的功能了。</p><p>在我看来，自动装配可以简单理解为：<strong>通过注解或者一些简单的配置就能在 Spring Boot 的帮助下实现某块功能。</strong></p><a id="more"></a><h3 id="SpringBoot-是如何实现自动装配的？如何实现按需加载？"><a href="#SpringBoot-是如何实现自动装配的？如何实现按需加载？" class="headerlink" title="SpringBoot 是如何实现自动装配的？如何实现按需加载？"></a>SpringBoot 是如何实现自动装配的？如何实现按需加载？</h3><p>我们先看一下 SpringBoot 的核心注解 <code>SpringBootApplication</code> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line">&lt;<span class="number">1.</span>&gt;<span class="meta">@SpringBootConfiguration</span></span><br><span class="line">&lt;<span class="number">2.</span>&gt;<span class="meta">@ComponentScan</span></span><br><span class="line">&lt;<span class="number">3.</span>&gt;<span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootApplication &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Configuration</span> <span class="comment">//实际上它也是一个配置类</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootConfiguration &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大概可以把 <code>@SpringBootApplication</code>看作是 <code>@Configuration</code>、<code>@EnableAutoConfiguration</code>、<code>@ComponentScan</code> 注解的集合。根据 SpringBoot 官网，这三个注解的作用分别是：</p><ul><li><code>@EnableAutoConfiguration</code>：启用 SpringBoot 的自动配置机制</li><li><code>@Configuration</code>：允许在上下文中注册额外的 bean 或导入其他配置类</li><li><code>@ComponentScan</code>： 扫描被<code>@Component</code> (<code>@Service</code>,<code>@Controller</code>)注解的 bean，注解默认会扫描启动类所在的包下所有的类 ，可以自定义不扫描某些 bean。如下图所示，容器中将排除<code>TypeExcludeFilter</code>和<code>AutoConfigurationExcludeFilter</code>。</li></ul><p><img src="https://plutowu-blogimgs.oss-cn-guangzhou.aliyuncs.com/img/20210310151024.png"></p><p><code>EnableAutoConfiguration</code> 是实现自动装配的重要注解，我们以这个注解入手。</p><h3 id="EnableAutoConfiguration-实现自动装配的核心注解"><a href="#EnableAutoConfiguration-实现自动装配的核心注解" class="headerlink" title="@EnableAutoConfiguration:实现自动装配的核心注解"></a>@EnableAutoConfiguration:实现自动装配的核心注解</h3><p><code>EnableAutoConfiguration</code> 只是一个简单地注解，自动装配核心功能的实现实际是通过 <code>AutoConfigurationImportSelector</code>类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@AutoConfigurationPackage</span> <span class="comment">//作用：将main包下的所欲组件注册到容器中</span></span><br><span class="line"><span class="meta">@Import(&#123;AutoConfigurationImportSelector.class&#125;)</span> <span class="comment">//加载自动装配类 xxxAutoconfiguration</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAutoConfiguration &#123;</span><br><span class="line">    String ENABLED_OVERRIDE_PROPERTY = <span class="string">&quot;spring.boot.enableautoconfiguration&quot;</span>;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt;[] exclude() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    String[] excludeName() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们现在重点分析下<code>AutoConfigurationImportSelector</code> 类到底做了什么？</p><h3 id="AutoConfigurationImportSelector-加载自动装配类"><a href="#AutoConfigurationImportSelector-加载自动装配类" class="headerlink" title="AutoConfigurationImportSelector:加载自动装配类"></a>AutoConfigurationImportSelector:加载自动装配类</h3><p><code>AutoConfigurationImportSelector</code>类的继承体系如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AutoConfigurationImportSelector</span> <span class="keyword">implements</span> <span class="title">DeferredImportSelector</span>, <span class="title">BeanClassLoaderAware</span>, <span class="title">ResourceLoaderAware</span>, <span class="title">BeanFactoryAware</span>, <span class="title">EnvironmentAware</span>, <span class="title">Ordered</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DeferredImportSelector</span> <span class="keyword">extends</span> <span class="title">ImportSelector</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ImportSelector</span> </span>&#123;</span><br><span class="line">    String[] selectImports(AnnotationMetadata var1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，<code>AutoConfigurationImportSelector</code> 类实现了 <code>ImportSelector</code>接口，也就实现了这个接口中的 <code>selectImports</code>方法，该方法主要用于<strong>获取所有符合条件的类的全限定类名，这些类需要被加载到 IoC 容器中</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] NO_IMPORTS = <span class="keyword">new</span> String[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String[] selectImports(AnnotationMetadata annotationMetadata) &#123;</span><br><span class="line">        <span class="comment">// &lt;1&gt;.判断自动装配开关是否打开</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.isEnabled(annotationMetadata)) &#123;</span><br><span class="line">            <span class="keyword">return</span> NO_IMPORTS;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">//&lt;2&gt;.获取所有需要装配的bean</span></span><br><span class="line">            AutoConfigurationMetadata autoConfigurationMetadata = AutoConfigurationMetadataLoader.loadMetadata(<span class="keyword">this</span>.beanClassLoader);</span><br><span class="line">            AutoConfigurationImportSelector.AutoConfigurationEntry autoConfigurationEntry = <span class="keyword">this</span>.getAutoConfigurationEntry(autoConfigurationMetadata, annotationMetadata);</span><br><span class="line">            <span class="keyword">return</span> StringUtils.toStringArray(autoConfigurationEntry.getConfigurations());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里我们需要重点关注一下<code>getAutoConfigurationEntry()</code>方法，这个方法主要负责加载自动配置类的。</p><p>该方法调用链如下：</p><p><img src="https://plutowu-blogimgs.oss-cn-guangzhou.aliyuncs.com/img/20210310151300.png"></p><p>现在我们结合<code>getAutoConfigurationEntry()</code>的源码来详细分析一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AutoConfigurationEntry EMPTY_ENTRY = <span class="keyword">new</span> AutoConfigurationEntry();</span><br><span class="line"></span><br><span class="line"><span class="function">AutoConfigurationEntry <span class="title">getAutoConfigurationEntry</span><span class="params">(AutoConfigurationMetadata autoConfigurationMetadata, AnnotationMetadata annotationMetadata)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//&lt;1&gt;.</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.isEnabled(annotationMetadata)) &#123;</span><br><span class="line">            <span class="keyword">return</span> EMPTY_ENTRY;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//&lt;2&gt;.</span></span><br><span class="line">            AnnotationAttributes attributes = <span class="keyword">this</span>.getAttributes(annotationMetadata);</span><br><span class="line">            <span class="comment">//&lt;3&gt;.</span></span><br><span class="line">            List&lt;String&gt; configurations = <span class="keyword">this</span>.getCandidateConfigurations(annotationMetadata, attributes);</span><br><span class="line">            <span class="comment">//&lt;4&gt;.</span></span><br><span class="line">            configurations = <span class="keyword">this</span>.removeDuplicates(configurations);</span><br><span class="line">            Set&lt;String&gt; exclusions = <span class="keyword">this</span>.getExclusions(annotationMetadata, attributes);</span><br><span class="line">            <span class="keyword">this</span>.checkExcludedClasses(configurations, exclusions);</span><br><span class="line">            configurations.removeAll(exclusions);</span><br><span class="line">            configurations = <span class="keyword">this</span>.filter(configurations, autoConfigurationMetadata);</span><br><span class="line">            <span class="keyword">this</span>.fireAutoConfigurationImportEvents(configurations, exclusions);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> AutoConfigurationImportSelector.AutoConfigurationEntry(configurations, exclusions);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>第 1 步</strong>:</p><p>判断自动装配开关是否打开。默认<code>spring.boot.enableautoconfiguration=true</code>，可在 <code>application.properties</code> 或 <code>application.yml</code> 中设置</p><p><img src="https://plutowu-blogimgs.oss-cn-guangzhou.aliyuncs.com/img/20210310151411.png"></p><p><strong>第 2 步</strong> ：</p><p>用于获取<code>EnableAutoConfiguration</code>注解中的 <code>exclude</code> 和 <code>excludeName</code></p><p><img src="https://plutowu-blogimgs.oss-cn-guangzhou.aliyuncs.com/img/20210310151439.png"></p><p><strong>第 3 步</strong></p><p>获取需要自动装配的所有配置类，读取<code>META-INF/spring.factories</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring-boot/spring-boot-project/spring-boot-autoconfigure/src/main/resources/META-INF/spring.factories</span><br></pre></td></tr></table></figure><p><img src="https://plutowu-blogimgs.oss-cn-guangzhou.aliyuncs.com/img/20210310151533.png"></p><p>从下图可以看到这个文件的配置内容都被我们读取到了。<code>XXXAutoConfiguration</code>的作用就是按需加载组件。</p><p><img src="https://plutowu-blogimgs.oss-cn-guangzhou.aliyuncs.com/img/20210310151540.png"></p><p>不光是这个依赖下的<code>META-INF/spring.factories</code>被读取到，所有 Spring Boot Starter 下的<code>META-INF/spring.factories</code>都会被读取到。</p><p>所以，你可以清楚滴看到， druid 数据库连接池的 Spring Boot Starter 就创建了<code>META-INF/spring.factories</code>文件。</p><p>如果，我们自己要创建一个 Spring Boot Starter，这一步是必不可少的。</p><p><img src="https://plutowu-blogimgs.oss-cn-guangzhou.aliyuncs.com/img/20210310151708.png"></p><p><strong>第 4 步</strong> ：</p><p>到这里可能面试官会问你:“<code>spring.factories</code>中这么多配置，每次启动都要全部加载么？”。</p><p>很明显，这是不现实的。我们 debug 到后面你会发现，<code>configurations</code> 的值变小了。</p><p><img src="https://plutowu-blogimgs.oss-cn-guangzhou.aliyuncs.com/img/20210310151550.png"></p><p>因为，这一步有经历了一遍筛选，<code>@ConditionalOnXXX</code> 中的所有条件都满足，该类才会生效。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="comment">// 检查相关的类：RabbitTemplate 和 Channel是否存在</span></span><br><span class="line"><span class="comment">// 存在才会加载</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(&#123; RabbitTemplate.class, Channel.class &#125;)</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(RabbitProperties.class)</span></span><br><span class="line"><span class="meta">@Import(RabbitAnnotationDrivenConfiguration.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitAutoConfiguration</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> Spring Boot 提供的条件注解</p><ul><li><code>@ConditionalOnBean</code>：当容器里有指定 Bean 的条件下</li><li><code>@ConditionalOnMissingBean</code>：当容器里没有指定 Bean 的情况下</li><li><code>@ConditionalOnSingleCandidate</code>：当指定 Bean 在容器中只有一个，或者虽然有多个但是指定首选 Bean</li><li><code>@ConditionalOnClass</code>：当类路径下有指定类的条件下</li><li><code>@ConditionalOnMissingClass</code>：当类路径下没有指定类的条件下</li><li><code>@ConditionalOnProperty</code>：指定的属性是否有指定的值</li><li><code>@ConditionalOnResource</code>：类路径是否有指定的值</li><li><code>@ConditionalOnExpression</code>：基于 SpEL 表达式作为判断条件</li><li><code>@ConditionalOnJava</code>：基于 Java 版本作为判断条件</li><li><code>@ConditionalOnJndi</code>：在 JNDI 存在的条件下差在指定的位置</li><li><code>@ConditionalOnNotWebApplication</code>：当前项目不是 Web 项目的条件下</li><li><code>@ConditionalOnWebApplication</code>：当前项目是 Web 项目的条件下</li></ul><h3 id="如何实现一个-Starter？"><a href="#如何实现一个-Starter？" class="headerlink" title="如何实现一个 Starter？"></a>如何实现一个 Starter？</h3><p>撸一个 starter，实现自定义线程池</p><p>第一步，创建<code>threadpool-spring-boot-starter</code>工程</p><p><img src="https://plutowu-blogimgs.oss-cn-guangzhou.aliyuncs.com/img/20210310151933.png"></p><p>第二步，引入 Spring Boot 相关依赖</p><p><img src="https://plutowu-blogimgs.oss-cn-guangzhou.aliyuncs.com/img/20210310151955.png"></p><p>第三步，创建<code>ThreadPoolAutoConfiguration</code></p><p><img src="https://plutowu-blogimgs.oss-cn-guangzhou.aliyuncs.com/img/20210310152017.png"></p><p>第四步，在<code>threadpool-spring-boot-starter</code>工程的 resources 包下创建<code>META-INF/spring.factories</code>文件</p><p><img src="https://plutowu-blogimgs.oss-cn-guangzhou.aliyuncs.com/img/20210310152042.png"></p><p>最后新建工程引入<code>threadpool-spring-boot-starter</code></p><p><img src="https://plutowu-blogimgs.oss-cn-guangzhou.aliyuncs.com/img/20210310152103.png"></p><p>测试通过</p><p><img src="https://plutowu-blogimgs.oss-cn-guangzhou.aliyuncs.com/img/20210310152130.png"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Spring Boot 通过<code>@EnableAutoConfiguration</code>开启自动装配，通过 SpringFactoriesLoader 最终加载<code>META-INF/spring.factories</code>中的自动配置类实现自动装配，自动配置类其实就是通过<code>@Conditional</code>按需加载的配置类，想要其生效必须引入<code>spring-boot-starter-xxx</code>包实现起步依赖</p><h2 id="2-SpringBoot-的启动流程"><a href="#2-SpringBoot-的启动流程" class="headerlink" title="2.SpringBoot 的启动流程"></a>2.SpringBoot 的启动流程</h2><h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h3><p><img src="https://plutowu-blogimgs.oss-cn-guangzhou.aliyuncs.com/img/20210310190123.png"></p><h3 id="源码及过程解析"><a href="#源码及过程解析" class="headerlink" title="源码及过程解析"></a>源码及过程解析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ConfigurableApplicationContext <span class="title">run</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 1.初始化stopWatcch(计数器),调用其start方法开始计时</span></span><br><span class="line">StopWatch stopWatch = <span class="keyword">new</span> StopWatch();</span><br><span class="line">stopWatch.start();</span><br><span class="line">ConfigurableApplicationContext context = <span class="keyword">null</span>;</span><br><span class="line">FailureAnalyzers analyzers = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">// 2.设置系统属性java.awt.headless,这里设置为true,表示运行在服务器端，在没有显示器和鼠标键盘的模式下工作，模拟输入输出设备功能</span></span><br><span class="line">configureHeadlessProperty();</span><br><span class="line"><span class="comment">// 3.调用springApplicationRunListeners#starting</span></span><br><span class="line">SpringApplicationRunListeners listeners = getRunListeners(args);</span><br><span class="line">listeners.starting();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 4.创建一个defaultApplicationArguments对象，他持有args参数（main函数中传入），调用prepareEnvironment方法</span></span><br><span class="line">ApplicationArguments applicationArguments = <span class="keyword">new</span> DefaultApplicationArguments(args);</span><br><span class="line">ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments);</span><br><span class="line"><span class="comment">// 5.打印banner</span></span><br><span class="line">Banner printedBanner = printBanner(environment);</span><br><span class="line"><span class="comment">// 6.创建springboot上下文</span></span><br><span class="line">context = createApplicationContext();</span><br><span class="line"><span class="comment">// 7.初始化FailureAnalyzers</span></span><br><span class="line">analyzers = <span class="keyword">new</span> FailureAnalyzers(context);</span><br><span class="line"><span class="comment">// 8.调用prepareContext</span></span><br><span class="line">prepareContext(context, environment, listeners, applicationArguments, printedBanner);</span><br><span class="line"><span class="comment">// 9.调用AbstractApplicationContext#refresh</span></span><br><span class="line">refreshContext(context);</span><br><span class="line"><span class="comment">// 10.在容器完成刷新后，依次调用注册的Runners</span></span><br><span class="line">afterRefresh(context, applicationArguments);</span><br><span class="line"><span class="comment">// 11.调用SpringApplicationRunListeners#finished</span></span><br><span class="line">listeners.finished(context, <span class="keyword">null</span>);</span><br><span class="line"><span class="comment">// 12.停止计时</span></span><br><span class="line">stopWatch.stop();</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.logStartupInfo) &#123;</span><br><span class="line"><span class="keyword">new</span> StartupInfoLogger(<span class="keyword">this</span>.mainApplicationClass).logStarted(getApplicationLog(), stopWatch);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> context;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="comment">// 13.初始化过程中出现异常时调用handelRunFailure进行处理，抛出IllegalStateException</span></span><br><span class="line">handleRunFailure(context, listeners, analyzers, ex);</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上代码就是SpringBoot的启动流程了，其中注释也非常详细，主要步骤也已经标注，现将主要步骤总结如下：</p><ol><li>从<code>spring.factories</code>配置文件中<strong>加载<code>EventPublishingRunListener</code>对象</strong>，该对象拥有<code>SimpleApplicationEventMulticaster</code>属性，即在SpringBoot启动过程的不同阶段用来发射内置的生命周期事件;</li><li><strong>准备环境变量</strong>，包括系统变量，环境变量，命令行参数，默认变量，<code>servlet</code>相关配置变量，随机值以及配置文件（比如<code>application.properties</code>）等;</li><li>控制台<strong>打印SpringBoot的<code>bannner</code>标志</strong>；</li><li><strong>根据不同类型环境创建不同类型的<code>applicationcontext</code>容器</strong>，因为这里是<code>servlet</code>环境，所以创建的是<code>AnnotationConfigServletWebServerApplicationContext</code>容器对象；</li><li>从<code>spring.factories</code>配置文件中<strong>加载<code>FailureAnalyzers</code>对象</strong>,用来报告SpringBoot启动过程中的异常；</li><li><strong>为刚创建的容器对象做一些初始化工作</strong>，准备一些容器属性值等，对<code>ApplicationContext</code>应用一些相关的后置处理和调用各个<code>ApplicationContextInitializer</code>的初始化方法来执行一些初始化逻辑等；</li><li><strong>刷新容器</strong>，这一步至关重要。比如调用<code>bean factory</code>的后置处理器，注册<code>BeanPostProcessor</code>后置处理器，初始化事件广播器且广播事件，初始化剩下的单例<code>bean</code>和SpringBoot创建内嵌的<code>Tomcat</code>服务器等等重要且复杂的逻辑都在这里实现，主要步骤可见代码的注释，关于这里的逻辑会在以后的spring源码分析专题详细分析；</li><li><strong>执行刷新容器后的后置处理逻辑</strong>，注意这里为空方法；</li><li><strong>调用<code>ApplicationRunner</code>和<code>CommandLineRunner</code>的run方法</strong>，我们实现这两个接口可以在spring容器启动后需要的一些东西比如加载一些业务数据等;</li><li><strong>报告启动异常</strong>，即若启动过程中抛出异常，此时用<code>FailureAnalyzers</code>来报告异常;</li><li>最终<strong>返回容器对象</strong>，这里调用方法没有声明对象来接收。</li></ol><p>当然在SpringBoot启动过程中，每个不同的启动阶段会分别发射不同的内置生命周期事件，比如在准备<code>environment</code>前会发射<code>ApplicationStartingEvent</code>事件，在<code>environment</code>准备好后会发射<code>ApplicationEnvironmentPreparedEvent</code>事件，在刷新容器前会发射<code>ApplicationPreparedEvent</code>事件等，总之SpringBoot总共内置了7个生命周期事件，除了标志SpringBoot的不同启动阶段外，同时一些监听器也会监听相应的生命周期事件从而执行一些启动初始化逻辑。</p><h2 id="3-Spring-IOC-amp-AOP"><a href="#3-Spring-IOC-amp-AOP" class="headerlink" title="3.Spring IOC &amp; AOP"></a>3.Spring IOC &amp; AOP</h2><h3 id="IoC"><a href="#IoC" class="headerlink" title="IoC"></a>IoC</h3><p>IoC（Inverse of Control:控制反转）是一种<strong>设计思想</strong>，就是 <strong>将原本在程序中手动创建对象的控制权，交由Spring框架来管理。</strong>  IoC 在其他语言中也有应用，并非 Spring 特有。 <strong>IoC 容器是 Spring 用来实现 IoC 的载体，  IoC 容器实际上就是个Map（key，value）,Map 中存放的是各种对象。</strong></p><p>将对象之间的相互依赖关系交给 IoC 容器来管理，并由 IoC 容器完成对象的注入。这样可以很大程度上简化应用的开发，把应用从复杂的依赖关系中解放出来。  <strong>IoC 容器就像是一个工厂一样，当我们需要创建一个对象的时候，只需要配置好配置文件/注解即可，完全不用考虑对象是如何被创建出来的。</strong> 在实际项目中一个 Service 类可能有几百甚至上千个类作为它的底层，假如我们需要实例化这个 Service，你可能要每次都要搞清这个 Service 所有底层类的构造函数，这可能会把人逼疯。如果利用 IoC 的话，你只需要配置好，然后在需要的地方引用就行了，这大大增加了项目的可维护性且降低了开发难度。</p><p>Spring 时代我们一般通过 XML 文件来配置 Bean，后来开发人员觉得 XML 文件来配置不太好，于是 SpringBoot 注解配置就慢慢开始流行起来。</p><p><strong>Spring IoC的初始化过程：</strong> </p><p><img src="https://plutowu-blogimgs.oss-cn-guangzhou.aliyuncs.com/img/20210310202931.png"></p><h3 id="依赖注入-DI"><a href="#依赖注入-DI" class="headerlink" title="依赖注入(DI)"></a>依赖注入(DI)</h3><p><strong>DI（Dependency Injection）</strong>，Spring IoC 不是一种技术，而是一种思想，通过这种思想，能够指导我们设计出松耦合的程序代码。而Spring IoC这个思想的作用体现在两个方面，一是如何将Bean装配到容器中去以及如何从容器中获取Bean，二是如何解决Bean之间的依赖关系，换句话说，就是如果由IoC容器来管理依赖关系，当一个Bean需要依赖另外一个Bean时，IoC容器如何实现这样的依赖关系。</p><p>解决Spring中Bean之间的依赖的实现方式，在Spring的概念中就被称之为<strong>依赖注入（Dependency Injection，DI）</strong>。普遍认为的Spring依赖注入的实现方式有三种：构造方法注入、setter方法注入、注解注入。但，就我而言，我认为应该划分为两种形式——基于XML注入和基于注解注入，然后再细分为下面的形式：</p><p><img src="https://plutowu-blogimgs.oss-cn-guangzhou.aliyuncs.com/img/1218435-20200805195048562-1750995069.png"></p><hr><h3 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h3><p>AOP( Aspect-Oriented Programming : 面向切面编程 ) 能够将那些与业务无关，<strong>却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来</strong>，便于<strong>减少系统的重复代码</strong>，<strong>降低模块间的耦合度</strong>，并<strong>有利于未来的可拓展性和可维护性</strong>。</p><p><strong>Spring AOP就是基于动态代理的</strong>，如果要代理的对象，实现了某个接口，那么Spring AOP会使用<strong>JDK Proxy</strong>，去创建代理对象，而对于没有实现接口的对象，就无法使用 JDK Proxy 去进行代理了，这时候Spring AOP会使用<strong>Cglib</strong> ，这时候Spring AOP会使用 <strong>Cglib</strong> 生成一个被代理对象的子类来作为代理，如下图所示：</p><p><img src="https://plutowu-blogimgs.oss-cn-guangzhou.aliyuncs.com/img/SpringAOPProcess.jpg" alt="SpringAOPProcess"></p><p>当然你也可以使用 AspectJ ,Spring AOP 已经集成了AspectJ  ，AspectJ  应该算的上是 Java 生态系统中最完整的 AOP 框架了。</p><p>使用 AOP 之后我们可以把一些通用功能抽象出来，在需要用到的地方直接使用即可，这样大大简化了代码量。我们需要增加新功能时也方便，这样也提高了系统扩展性。日志功能、事务管理等等场景都用到了 AOP 。</p><h2 id="4-Spring-框架中的设计模式"><a href="#4-Spring-框架中的设计模式" class="headerlink" title="4.Spring 框架中的设计模式"></a>4.Spring 框架中的设计模式</h2><ul><li><strong>工厂设计模式</strong> : Spring使用工厂模式通过 <code>BeanFactory</code>、<code>ApplicationContext</code> 创建 bean 对象。</li><li><strong>代理设计模式</strong> : Spring AOP 功能的实现。</li><li><strong>单例设计模式</strong> : Spring 中的 Bean 默认都是单例的。</li><li><strong>模板方法模式</strong> : Spring 中 <code>jdbcTemplate</code>、<code>hibernateTemplate</code> 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。</li><li><strong>包装器设计模式</strong> : 我们的项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们可以根据客户的需求能够动态切换不同的数据源。</li><li><strong>观察者模式:</strong> Spring 事件驱动模型就是观察者模式很经典的一个应用。</li><li><strong>适配器模式</strong> :Spring AOP 的增强或通知(Advice)使用到了适配器模式、spring MVC 中也是用到了适配器模式适配<code>Controller</code>。</li><li>……</li></ul><h2 id="5-Spring-bean"><a href="#5-Spring-bean" class="headerlink" title="5. Spring bean"></a>5. Spring bean</h2><h3 id="5-1-Spring-中的-bean-的作用域有哪些"><a href="#5-1-Spring-中的-bean-的作用域有哪些" class="headerlink" title="5.1 Spring 中的 bean 的作用域有哪些?"></a>5.1 Spring 中的 bean 的作用域有哪些?</h3><ul><li>singleton : 唯一 bean 实例，Spring 中的 bean 默认都是单例的。</li><li>prototype : 每次请求都会创建一个新的 bean 实例。</li><li>request : 每一次HTTP请求都会产生一个新的bean，该bean仅在当前HTTP request内有效。</li><li>session : 每一次HTTP请求都会产生一个新的 bean，该bean仅在当前 HTTP session 内有效。</li><li>global-session： 全局session作用域，仅仅在基于portlet的web应用中才有意义，Spring5已经没有了。Portlet是能够生成语义代码(例如：HTML)片段的小型Java Web插件。它们基于portlet容器，可以像servlet一样处理HTTP请求。但是，与 servlet 不同，每个 portlet 都有不同的会话</li></ul><h3 id="5-2-Spring-中的单例-bean-的线程安全问题了解吗？"><a href="#5-2-Spring-中的单例-bean-的线程安全问题了解吗？" class="headerlink" title="5.2 Spring 中的单例 bean 的线程安全问题了解吗？"></a>5.2 Spring 中的单例 bean 的线程安全问题了解吗？</h3><p>的确是存在安全问题的。因为，当多个线程操作同一个对象的时候，对这个对象的成员变量的写操作会存在线程安全问题。</p><p>但是，一般情况下，我们常用的 <code>Controller</code>、<code>Service</code>、<code>Dao</code> 这些 Bean 是无状态的。无状态的 Bean 不能保存数据，因此是线程安全的。</p><p>常见的有 2 种解决办法：</p><ol start="2"><li>在类中定义一个 <code>ThreadLocal</code> 成员变量，将需要的可变成员变量保存在  <code>ThreadLocal</code>  中（推荐的一种方式）。</li><li>改变 Bean 的作用域为 “prototype”：每次请求都会创建一个新的 bean 实例，自然不会存在线程安全问题。</li></ol><h3 id="5-3-Component-和-Bean-的区别是什么？"><a href="#5-3-Component-和-Bean-的区别是什么？" class="headerlink" title="5.3 @Component 和 @Bean 的区别是什么？"></a>5.3 @Component 和 @Bean 的区别是什么？</h3><ol><li>作用对象不同: <code>@Component</code> 注解作用于类，而<code>@Bean</code>注解作用于方法。</li><li><code>@Component</code>通常是通过类路径扫描来自动侦测以及自动装配到Spring容器中（我们可以使用 <code>@ComponentScan</code> 注解定义要扫描的路径从中找出标识了需要装配的类自动装配到 Spring 的 bean 容器中）。<code>@Bean</code> 注解通常是我们在标有该注解的方法中定义产生这个 bean,<code>@Bean</code>告诉了Spring这是某个类的示例，当我需要用它的时候还给我。</li><li><code>@Bean</code> 注解比 <code>Component</code> 注解的自定义性更强，而且很多地方我们只能通过 <code>@Bean</code> 注解来注册bean。比如当我们引用第三方库中的类需要装配到 <code>Spring</code>容器时，则只能通过 <code>@Bean</code>来实现。</li></ol><p><code>@Bean</code>注解使用示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TransferService <span class="title">transferService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TransferServiceImpl();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 上面的代码相当于下面的 xml 配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transferService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.acme.TransferServiceImpl&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>下面这个例子是通过 <code>@Component</code> 无法实现的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> OneService <span class="title">getService</span><span class="params">(status)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> (status)  &#123;</span><br><span class="line">        when <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> serviceImpl1();</span><br><span class="line">        when <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> serviceImpl2();</span><br><span class="line">        when <span class="number">3</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> serviceImpl3();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-4-将一个类声明为Spring的-bean-的注解有哪些"><a href="#5-4-将一个类声明为Spring的-bean-的注解有哪些" class="headerlink" title="5.4 将一个类声明为Spring的 bean 的注解有哪些?"></a>5.4 将一个类声明为Spring的 bean 的注解有哪些?</h3><p>我们一般使用 <code>@Autowired</code> 注解自动装配 bean，要想把类标识成可用于 <code>@Autowired</code> 注解自动装配的 bean 的类,采用以下注解可实现：</p><ul><li><code>@Component</code> ：通用的注解，可标注任意类为 <code>Spring</code> 组件。如果一个Bean不知道属于哪个层，可以使用<code>@Component</code> 注解标注。</li><li><code>@Repository</code> : 对应持久层即 Dao 层，主要用于数据库相关操作。</li><li><code>@Service</code> : 对应服务层，主要涉及一些复杂的逻辑，需要用到 Dao层。</li><li><code>@Controller</code> : 对应 Spring MVC 控制层，主要用于接受用户请求并调用 Service 层返回数据给前端页面。</li></ul><h3 id="5-5-Spring-中的-bean-生命周期"><a href="#5-5-Spring-中的-bean-生命周期" class="headerlink" title="5.5 Spring 中的 bean 生命周期?"></a>5.5 Spring 中的 bean 生命周期?</h3><ul><li>Bean 容器找到配置文件中 Spring Bean 的定义。</li><li>Bean 容器利用 Java Reflection API 创建一个Bean的实例。</li><li>如果涉及到一些属性值 利用 <code>set()</code>方法设置一些属性值。</li><li>如果 Bean 实现了 <code>BeanNameAware</code> 接口，调用 <code>setBeanName()</code>方法，传入Bean的名字。</li><li>如果 Bean 实现了 <code>BeanClassLoaderAware</code> 接口，调用 <code>setBeanClassLoader()</code>方法，传入 <code>ClassLoader</code>对象的实例。</li><li>与上面的类似，如果实现了其他 <code>*.Aware</code>接口，就调用相应的方法。</li><li>如果有和加载这个 Bean 的 Spring 容器相关的 <code>BeanPostProcessor</code> 对象，执行<code>postProcessBeforeInitialization()</code> 方法</li><li>如果Bean实现了<code>InitializingBean</code>接口，执行<code>afterPropertiesSet()</code>方法。</li><li>如果 Bean 在配置文件中的定义包含  init-method 属性，执行指定的方法。</li><li>如果有和加载这个 Bean的 Spring 容器相关的 <code>BeanPostProcessor</code> 对象，执行<code>postProcessAfterInitialization()</code> 方法</li><li>当要销毁 Bean 的时候，如果 Bean 实现了 <code>DisposableBean</code> 接口，执行 <code>destroy()</code> 方法。</li><li>当要销毁 Bean 的时候，如果 Bean 在配置文件中的定义包含 destroy-method 属性，执行指定的方法。</li></ul><p>图示：</p><p><img src="https://plutowu-blogimgs.oss-cn-guangzhou.aliyuncs.com/img/48376272.jpg" alt="Spring Bean 生命周期"></p><p>与之比较类似的中文版本:</p><p><img src="https://plutowu-blogimgs.oss-cn-guangzhou.aliyuncs.com/img/5496407.jpg" alt="Spring Bean 生命周期"></p><h2 id="6-SpringBoot-的常用注解"><a href="#6-SpringBoot-的常用注解" class="headerlink" title="6. SpringBoot 的常用注解"></a>6. SpringBoot 的常用注解</h2><h3 id="1-SpringBootApplication"><a href="#1-SpringBootApplication" class="headerlink" title="1. @SpringBootApplication"></a>1. <code>@SpringBootApplication</code></h3><p>这里先单独拎出<code>@SpringBootApplication</code> 注解说一下，虽然我们一般不会主动去使用它。</p><p><em>这个注解是 Spring Boot 项目的基石，创建 SpringBoot 项目之后会默认在主类加上。</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringSecurityJwtGuideApplication</span> </span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(SpringSecurityJwtGuideApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以把 <code>@SpringBootApplication</code>看作是 <code>@Configuration</code>、<code>@EnableAutoConfiguration</code>、<code>@ComponentScan</code> 注解的集合。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.boot.autoconfigure;</span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan(excludeFilters = &#123;</span></span><br><span class="line"><span class="meta">@Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),</span></span><br><span class="line"><span class="meta">@Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootApplication &#123;</span><br><span class="line">   ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> org.springframework.boot;</span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootConfiguration &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据 SpringBoot 官网，这三个注解的作用分别是：</p><ul><li><code>@EnableAutoConfiguration</code>：启用 SpringBoot 的自动配置机制</li><li><code>@ComponentScan</code>： 扫描被<code>@Component</code> (<code>@Service</code>,<code>@Controller</code>)注解的 bean，注解默认会扫描该类所在的包下所有的类。</li><li><code>@Configuration</code>：允许在 Spring 上下文中注册额外的 bean 或导入其他配置类</li></ul><h3 id="2-Spring-Bean-相关"><a href="#2-Spring-Bean-相关" class="headerlink" title="2. Spring Bean 相关"></a>2. Spring Bean 相关</h3><h4 id="2-1-Autowired"><a href="#2-1-Autowired" class="headerlink" title="2.1. @Autowired"></a>2.1. <code>@Autowired</code></h4><p>自动导入对象到类中，被注入进的类同样要被 Spring 容器管理比如：Service 类注入到 Controller 类中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/users&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Autowired</span></span><br><span class="line">   <span class="keyword">private</span> UserService userService;</span><br><span class="line">   ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-Component-Repository-Service-Controller"><a href="#2-2-Component-Repository-Service-Controller" class="headerlink" title="2.2. @Component,@Repository,@Service, @Controller"></a>2.2. <code>@Component</code>,<code>@Repository</code>,<code>@Service</code>, <code>@Controller</code></h4><p>我们一般使用 <code>@Autowired</code> 注解让 Spring 容器帮我们自动装配 bean。要想把类标识成可用于 <code>@Autowired</code> 注解自动装配的 bean 的类,可以采用以下注解实现：</p><ul><li><code>@Component</code> ：通用的注解，可标注任意类为 <code>Spring</code> 组件。如果一个 Bean 不知道属于哪个层，可以使用<code>@Component</code> 注解标注。</li><li><code>@Repository</code> : 对应持久层即 Dao 层，主要用于数据库相关操作。</li><li><code>@Service</code> : 对应服务层，主要涉及一些复杂的逻辑，需要用到 Dao 层。</li><li><code>@Controller</code> : 对应 Spring MVC 控制层，主要用于接受用户请求并调用 Service 层返回数据给前端页面。</li></ul><h4 id="2-3-RestController"><a href="#2-3-RestController" class="headerlink" title="2.3. @RestController"></a>2.3. <code>@RestController</code></h4><p><code>@RestController</code>注解是<code>@Controller和</code>@<code>ResponseBody</code>的合集,表示这是个控制器 bean,并且是将函数的返回值直 接填入 HTTP 响应体中,是 REST 风格的控制器。</p><p><em>Guide 哥：现在都是前后端分离，说实话我已经很久没有用过<code>@Controller</code>。如果你的项目太老了的话，就当我没说。</em></p><p>单独使用 <code>@Controller</code> 不加 <code>@ResponseBody</code>的话一般使用在要返回一个视图的情况，这种情况属于比较传统的 Spring MVC 的应用，对应于前后端不分离的情况。<code>@Controller</code> +<code>@ResponseBody</code> 返回 JSON 或 XML 形式数据</p><p>关于<code>@RestController</code> 和 <code>@Controller</code>的对比，请看这篇文章：<a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485544&idx=1&sn=3cc95b88979e28fe3bfe539eb421c6d8&chksm=cea247a3f9d5ceb5e324ff4b8697adc3e828ecf71a3468445e70221cce768d1e722085359907&token=1725092312&lang=zh_CN#rd">@RestController vs @Controller</a>。</p><h4 id="2-4-Scope"><a href="#2-4-Scope" class="headerlink" title="2.4. @Scope"></a>2.4. <code>@Scope</code></h4><p>声明 Spring Bean 的作用域，使用方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Scope(&quot;singleton&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Person <span class="title">personSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Person();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>四种常见的 Spring Bean 的作用域：</strong></p><ul><li>singleton : 唯一 bean 实例，Spring 中的 bean 默认都是单例的。</li><li>prototype : 每次请求都会创建一个新的 bean 实例。</li><li>request : 每一次 HTTP 请求都会产生一个新的 bean，该 bean 仅在当前 HTTP request 内有效。</li><li>session : 每一次 HTTP 请求都会产生一个新的 bean，该 bean 仅在当前 HTTP session 内有效。</li></ul><h4 id="2-5-Configuration"><a href="#2-5-Configuration" class="headerlink" title="2.5. @Configuration"></a>2.5. <code>@Configuration</code></h4><p>一般用来声明配置类，可以使用 <code>@Component</code>注解替代，不过使用<code>@Configuration</code>注解声明配置类更加语义化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TransferService <span class="title">transferService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TransferServiceImpl();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-处理常见的-HTTP-请求类型"><a href="#3-处理常见的-HTTP-请求类型" class="headerlink" title="3. 处理常见的 HTTP 请求类型"></a>3. 处理常见的 HTTP 请求类型</h3><p><strong>5 种常见的请求类型:</strong></p><ul><li><strong>GET</strong> ：请求从服务器获取特定资源。举个例子：<code>GET /users</code>（获取所有学生）</li><li><strong>POST</strong> ：在服务器上创建一个新的资源。举个例子：<code>POST /users</code>（创建学生）</li><li><strong>PUT</strong> ：更新服务器上的资源（客户端提供更新后的整个资源）。举个例子：<code>PUT /users/12</code>（更新编号为 12 的学生）</li><li><strong>DELETE</strong> ：从服务器删除特定的资源。举个例子：<code>DELETE /users/12</code>（删除编号为 12 的学生）</li><li><strong>PATCH</strong> ：更新服务器上的资源（客户端提供更改的属性，可以看做作是部分更新），使用的比较少，这里就不举例子了。</li></ul><h4 id="3-1-GET-请求"><a href="#3-1-GET-请求" class="headerlink" title="3.1. GET 请求"></a>3.1. GET 请求</h4><p><code>@GetMapping(&quot;users&quot;)</code> 等价于<code>@RequestMapping(value=&quot;/users&quot;,method=RequestMethod.GET)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/users&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ResponseEntity&lt;List&lt;User&gt;&gt; getAllUsers() &#123;</span><br><span class="line"> <span class="keyword">return</span> userRepository.findAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-POST-请求"><a href="#3-2-POST-请求" class="headerlink" title="3.2. POST 请求"></a>3.2. POST 请求</h4><p><code>@PostMapping(&quot;users&quot;)</code> 等价于<code>@RequestMapping(value=&quot;/users&quot;,method=RequestMethod.POST)</code></p><p>关于<code>@RequestBody</code>注解的使用，在下面的“前后端传值”这块会讲到。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/users&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ResponseEntity&lt;User&gt; <span class="title">createUser</span><span class="params">(<span class="meta">@Valid</span> <span class="meta">@RequestBody</span> UserCreateRequest userCreateRequest)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> userRespository.save(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-3-PUT-请求"><a href="#3-3-PUT-请求" class="headerlink" title="3.3. PUT 请求"></a>3.3. PUT 请求</h4><p><code>@PutMapping(&quot;/users/&#123;userId&#125;&quot;)</code> 等价于<code>@RequestMapping(value=&quot;/users/&#123;userId&#125;&quot;,method=RequestMethod.PUT)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PutMapping(&quot;/users/&#123;userId&#125;&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ResponseEntity&lt;User&gt; <span class="title">updateUser</span><span class="params">(<span class="meta">@PathVariable(value = &quot;userId&quot;)</span> Long userId,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="meta">@Valid</span> <span class="meta">@RequestBody</span> UserUpdateRequest userUpdateRequest)</span> </span>&#123;</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-4-DELETE-请求"><a href="#3-4-DELETE-请求" class="headerlink" title="3.4. DELETE 请求"></a>3.4. <strong>DELETE 请求</strong></h4><p><code>@DeleteMapping(&quot;/users/&#123;userId&#125;&quot;)</code>等价于<code>@RequestMapping(value=&quot;/users/&#123;userId&#125;&quot;,method=RequestMethod.DELETE)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@DeleteMapping(&quot;/users/&#123;userId&#125;&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ResponseEntity <span class="title">deleteUser</span><span class="params">(<span class="meta">@PathVariable(value = &quot;userId&quot;)</span> Long userId)</span></span>&#123;</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-5-PATCH-请求"><a href="#3-5-PATCH-请求" class="headerlink" title="3.5. PATCH 请求"></a>3.5. <strong>PATCH 请求</strong></h4><p>一般实际项目中，我们都是 PUT 不够用了之后才用 PATCH 请求去更新数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PatchMapping(&quot;/profile&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ResponseEntity <span class="title">updateStudent</span><span class="params">(<span class="meta">@RequestBody</span> StudentUpdateRequest studentUpdateRequest)</span> </span>&#123;</span><br><span class="line">      studentRepository.updateDetail(studentUpdateRequest);</span><br><span class="line">      <span class="keyword">return</span> ResponseEntity.ok().build();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="4-前后端传值"><a href="#4-前后端传值" class="headerlink" title="4. 前后端传值"></a>4. 前后端传值</h3><h4 id="4-1-PathVariable-和-RequestParam"><a href="#4-1-PathVariable-和-RequestParam" class="headerlink" title="4.1. @PathVariable 和 @RequestParam"></a>4.1. <code>@PathVariable</code> 和 <code>@RequestParam</code></h4><p><code>@PathVariable</code>用于获取路径参数，<code>@RequestParam</code>用于获取查询参数。</p><p>举个简单的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/klasses/&#123;klassId&#125;/teachers&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Teacher&gt; <span class="title">getKlassRelatedTeachers</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">         <span class="meta">@PathVariable(&quot;klassId&quot;)</span> Long klassId,</span></span></span><br><span class="line"><span class="function"><span class="params">         <span class="meta">@RequestParam(value = &quot;type&quot;, required = false)</span> String type )</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们请求的 url 是：<code>/klasses/&#123;123456&#125;/teachers?type=web</code></p><p>那么我们服务获取到的数据就是：<code>klassId=123456,type=web</code>。</p><h4 id="4-2-RequestBody"><a href="#4-2-RequestBody" class="headerlink" title="4.2. @RequestBody"></a>4.2. <code>@RequestBody</code></h4><p>用于读取 Request 请求（可能是 POST,PUT,DELETE,GET 请求）的 body 部分并且<strong>Content-Type 为 application/json</strong> 格式的数据，接收到数据之后会自动将数据绑定到 Java 对象上去。系统会使用<code>HttpMessageConverter</code>或者自定义的<code>HttpMessageConverter</code>将请求的 body 中的 json 字符串转换为 java 对象。</p><p>我用一个简单的例子来给演示一下基本使用！</p><p>我们有一个注册的接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/sign-up&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ResponseEntity <span class="title">signUp</span><span class="params">(<span class="meta">@RequestBody</span> <span class="meta">@Valid</span> UserRegisterRequest userRegisterRequest)</span> </span>&#123;</span><br><span class="line">  userService.save(userRegisterRequest);</span><br><span class="line">  <span class="keyword">return</span> ResponseEntity.ok().build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>UserRegisterRequest</code>对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserRegisterRequest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@NotBlank</span></span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="meta">@NotBlank</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="meta">@NotBlank</span></span><br><span class="line">    <span class="keyword">private</span> String fullName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们发送 post 请求到这个接口，并且 body 携带 JSON 数据：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">&quot;userName&quot;</span>:<span class="string">&quot;coder&quot;</span>,<span class="attr">&quot;fullName&quot;</span>:<span class="string">&quot;shuangkou&quot;</span>,<span class="attr">&quot;password&quot;</span>:<span class="string">&quot;123456&quot;</span>&#125;</span><br></pre></td></tr></table></figure><p>这样我们的后端就可以直接把 json 格式的数据映射到我们的 <code>UserRegisterRequest</code> 类上。</p><p><img src="https://plutowu-blogimgs.oss-cn-guangzhou.aliyuncs.com/img/@RequestBody.png"></p><p>👉 需要注意的是：**一个请求方法只可以有一个<code>@RequestBody</code>，但是可以有多个<code>@RequestParam</code>和<code>@PathVariable</code>**。 如果你的方法必须要用两个 <code>@RequestBody</code>来接受数据的话，大概率是你的数据库设计或者系统设计出问题了！</p><h3 id="5-读取配置信息"><a href="#5-读取配置信息" class="headerlink" title="5. 读取配置信息"></a>5. 读取配置信息</h3><p><strong>很多时候我们需要将一些常用的配置信息比如阿里云 oss、发送短信、微信认证的相关配置信息等等放到配置文件中。</strong></p><p><strong>下面我们来看一下 Spring 为我们提供了哪些方式帮助我们从配置文件中读取这些配置信息。</strong></p><p>我们的数据源<code>application.yml</code>内容如下：：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">wuhan2020:</span> <span class="number">2020</span><span class="string">年初武汉爆发了新型冠状病毒，疫情严重，但是，我相信一切都会过去！武汉加油！中国加油！</span></span><br><span class="line"></span><br><span class="line"><span class="attr">my-profile:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">Pluto</span></span><br><span class="line">  <span class="attr">email:</span> <span class="string">p1utowu@qq.com</span></span><br><span class="line"></span><br><span class="line"><span class="attr">library:</span></span><br><span class="line">  <span class="attr">location:</span> <span class="string">湖北武汉加油中国加油</span></span><br><span class="line">  <span class="attr">books:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">天才基本法</span></span><br><span class="line">      <span class="attr">description:</span> <span class="string">二十二岁的林朝夕在父亲确诊阿尔茨海默病这天，得知自己暗恋多年的校园男神裴之即将出国深造的消息——对方考取的学校，恰是父亲当年为她放弃的那所。</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">时间的秩序</span></span><br><span class="line">      <span class="attr">description:</span> <span class="string">为什么我们记得过去，而非未来？时间“流逝”意味着什么？是我们存在于时间之内，还是时间存在于我们之中？卡洛·罗韦利用诗意的文字，邀请我们思考这一亘古难题——时间的本质。</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">了不起的我</span></span><br><span class="line">      <span class="attr">description:</span> <span class="string">如何养成一个新习惯？如何让心智变得更成熟？如何拥有高质量的关系？</span> <span class="string">如何走出人生的艰难时刻？</span></span><br></pre></td></tr></table></figure><h4 id="5-1-value-常用"><a href="#5-1-value-常用" class="headerlink" title="5.1. @value(常用)"></a>5.1. <code>@value</code>(常用)</h4><p>使用 <code>@Value(&quot;$&#123;property&#125;&quot;)</code> 读取比较简单的配置信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Value(&quot;$&#123;wuhan2020&#125;&quot;)</span></span><br><span class="line">String wuhan2020;</span><br></pre></td></tr></table></figure><h4 id="5-2-ConfigurationProperties-常用"><a href="#5-2-ConfigurationProperties-常用" class="headerlink" title="5.2. @ConfigurationProperties(常用)"></a>5.2. <code>@ConfigurationProperties</code>(常用)</h4><p>通过<code>@ConfigurationProperties</code>读取配置信息并与 bean 绑定。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;library&quot;)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LibraryProperties</span> </span>&#123;</span><br><span class="line">    <span class="meta">@NotEmpty</span></span><br><span class="line">    <span class="keyword">private</span> String location;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Book&gt; books;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Setter</span></span><br><span class="line">    <span class="meta">@Getter</span></span><br><span class="line">    <span class="meta">@ToString</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Book</span> </span>&#123;</span><br><span class="line">        String name;</span><br><span class="line">        String description;</span><br><span class="line">    &#125;</span><br><span class="line">  省略getter/setter</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可以像使用普通的 Spring bean 一样，将其注入到类中使用。</p><h4 id="5-3-PropertySource（不常用）"><a href="#5-3-PropertySource（不常用）" class="headerlink" title="5.3. PropertySource（不常用）"></a>5.3. <code>PropertySource</code>（不常用）</h4><p><code>@PropertySource</code>读取指定 properties 文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;classpath:website.properties&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WebSite</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;url&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line"></span><br><span class="line">  省略getter/setter</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-参数校验"><a href="#6-参数校验" class="headerlink" title="6. 参数校验"></a>6. 参数校验</h3><p><strong>数据的校验的重要性就不用说了，即使在前端对数据进行校验的情况下，我们还是要对传入后端的数据再进行一遍校验，避免用户绕过浏览器直接通过一些 HTTP 工具直接向后端请求一些违法数据。</strong></p><p><strong>JSR(Java Specification Requests）</strong> 是一套 JavaBean 参数校验的标准，它定义了很多常用的校验注解，我们可以直接将这些注解加在我们 JavaBean 的属性上面，这样就可以在需要校验的时候进行校验了，非常方便！</p><p>校验的时候我们实际用的是 <strong>Hibernate Validator</strong> 框架。Hibernate Validator 是 Hibernate 团队最初的数据校验框架，Hibernate Validator 4.x 是 Bean Validation 1.0（JSR 303）的参考实现，Hibernate Validator 5.x 是 Bean Validation 1.1（JSR 349）的参考实现，目前最新版的 Hibernate Validator 6.x 是 Bean Validation 2.0（JSR 380）的参考实现。</p><p>SpringBoot 项目的 spring-boot-starter-web 依赖中已经有 hibernate-validator 包，不需要引用相关依赖。如下图所示（通过 idea 插件—Maven Helper 生成）：</p><p><img src="https://cdn.jsdelivr.net/gh/javaguide-tech/blog-images/2020-08/c7bacd12-1c1a-4e41-aaaf-4cad840fc073.png"></p><p>👉 需要注意的是： <strong>所有的注解，推荐使用 JSR 注解，即<code>javax.validation.constraints</code>，而不是<code>org.hibernate.validator.constraints</code></strong></p><h4 id="6-1-一些常用的字段验证的注解"><a href="#6-1-一些常用的字段验证的注解" class="headerlink" title="6.1. 一些常用的字段验证的注解"></a>6.1. 一些常用的字段验证的注解</h4><ul><li><code>@NotEmpty</code> 被注释的字符串的不能为 null 也不能为空</li><li><code>@NotBlank</code> 被注释的字符串非 null，并且必须包含一个非空白字符</li><li><code>@Null</code> 被注释的元素必须为 null</li><li><code>@NotNull</code> 被注释的元素必须不为 null</li><li><code>@AssertTrue</code> 被注释的元素必须为 true</li><li><code>@AssertFalse</code> 被注释的元素必须为 false</li><li><code>@Pattern(regex=,flag=)</code>被注释的元素必须符合指定的正则表达式</li><li><code>@Email</code> 被注释的元素必须是 Email 格式。</li><li><code>@Min(value)</code>被注释的元素必须是一个数字，其值必须大于等于指定的最小值</li><li><code>@Max(value)</code>被注释的元素必须是一个数字，其值必须小于等于指定的最大值</li><li><code>@DecimalMin(value)</code>被注释的元素必须是一个数字，其值必须大于等于指定的最小值</li><li><code>@DecimalMax(value)</code> 被注释的元素必须是一个数字，其值必须小于等于指定的最大值</li><li><code>@Size(max=, min=)</code>被注释的元素的大小必须在指定的范围内</li><li><code>@Digits (integer, fraction)</code>被注释的元素必须是一个数字，其值必须在可接受的范围内</li><li><code>@Past</code>被注释的元素必须是一个过去的日期</li><li><code>@Future</code> 被注释的元素必须是一个将来的日期</li><li>……</li></ul><h4 id="6-2-验证请求体-RequestBody"><a href="#6-2-验证请求体-RequestBody" class="headerlink" title="6.2. 验证请求体(RequestBody)"></a>6.2. 验证请求体(RequestBody)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull(message = &quot;classId 不能为空&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String classId;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Size(max = 33)</span></span><br><span class="line">    <span class="meta">@NotNull(message = &quot;name 不能为空&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pattern(regexp = &quot;((^Man$|^Woman$|^UGM$))&quot;, message = &quot;sex 值不在可选范围&quot;)</span></span><br><span class="line">    <span class="meta">@NotNull(message = &quot;sex 不能为空&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String sex;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Email(message = &quot;email 格式不正确&quot;)</span></span><br><span class="line">    <span class="meta">@NotNull(message = &quot;email 不能为空&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在需要验证的参数上加上了<code>@Valid</code>注解，如果验证失败，它将抛出<code>MethodArgumentNotValidException</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/api&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/person&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResponseEntity&lt;Person&gt; <span class="title">getPerson</span><span class="params">(<span class="meta">@RequestBody</span> <span class="meta">@Valid</span> Person person)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.ok().body(person);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-3-验证请求参数-Path-Variables-和-Request-Parameters"><a href="#6-3-验证请求参数-Path-Variables-和-Request-Parameters" class="headerlink" title="6.3. 验证请求参数(Path Variables 和 Request Parameters)"></a>6.3. 验证请求参数(Path Variables 和 Request Parameters)</h4><p><strong>一定一定不要忘记在类上加上 <code>Validated</code> 注解了，这个参数可以告诉 Spring 去校验方法参数。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/api&quot;)</span></span><br><span class="line"><span class="meta">@Validated</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/person/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResponseEntity&lt;Integer&gt; <span class="title">getPersonByID</span><span class="params">(<span class="meta">@Valid</span> <span class="meta">@PathVariable(&quot;id&quot;)</span> <span class="meta">@Max(value = 5,message = &quot;超过 id 的范围了&quot;)</span> Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.ok().body(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-全局处理-Controller-层异常"><a href="#7-全局处理-Controller-层异常" class="headerlink" title="7. 全局处理 Controller 层异常"></a>7. 全局处理 Controller 层异常</h3><p>介绍一下我们 Spring 项目必备的全局处理 Controller 层异常。</p><p><strong>相关注解：</strong></p><ol><li><code>@ControllerAdvice</code> :注解定义全局异常处理类</li><li><code>@ExceptionHandler</code> :注解声明异常处理方法</li></ol><p>如何使用呢？拿我们在第 5 节参数校验这块来举例子。如果方法参数不对的话就会抛出<code>MethodArgumentNotValidException</code>，我们来处理这个异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlobalExceptionHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 请求参数异常处理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(MethodArgumentNotValidException.class)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;?&gt; handleMethodArgumentNotValidException(MethodArgumentNotValidException ex, HttpServletRequest request) &#123;</span><br><span class="line">       ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-JPA-相关"><a href="#8-JPA-相关" class="headerlink" title="8. JPA 相关"></a>8. JPA 相关</h3><h4 id="8-1-创建表"><a href="#8-1-创建表" class="headerlink" title="8.1. 创建表"></a>8.1. 创建表</h4><p><code>@Entity</code>声明一个类对应一个数据库实体。</p><p><code>@Table</code> 设置表名</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table(name = &quot;role&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Role</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String description;</span><br><span class="line">    省略getter/setter......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-2-创建主键"><a href="#8-2-创建主键" class="headerlink" title="8.2. 创建主键"></a>8.2. 创建主键</h4><p><code>@Id</code> ：声明一个字段为主键。</p><p>使用<code>@Id</code>声明之后，我们还需要定义主键的生成策略。我们可以使用 <code>@GeneratedValue</code> 指定主键生成策略。</p><p><strong>1.通过 <code>@GeneratedValue</code>直接使用 JPA 内置提供的四种主键生成策略来指定主键生成策略。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Id</span></span><br><span class="line"><span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line"><span class="keyword">private</span> Long id;</span><br></pre></td></tr></table></figure><p>JPA 使用枚举定义了 4 中常见的主键生成策略，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">GenerationType</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用一个特定的数据库表格来保存主键</span></span><br><span class="line"><span class="comment">     * 持久化引擎通过关系数据库的一张特定的表格来生成主键,</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    TABLE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *在某些数据库中,不支持主键自增长,比如Oracle、PostgreSQL其提供了一种叫做&quot;序列(sequence)&quot;的机制生成主键</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    SEQUENCE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 主键自增长</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    IDENTITY,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *把主键生成策略交给持久化引擎(persistence engine),</span></span><br><span class="line"><span class="comment">     *持久化引擎会根据数据库在以上三种主键生成 策略中选择其中一种</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    AUTO</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>@GeneratedValue</code>注解默认使用的策略是<code>GenerationType.AUTO</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> GeneratedValue &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">GenerationType <span class="title">strategy</span><span class="params">()</span> <span class="keyword">default</span> AUTO</span>;</span><br><span class="line">    <span class="function">String <span class="title">generator</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般使用 MySQL 数据库的话，使用<code>GenerationType.IDENTITY</code>策略比较普遍一点（分布式系统的话需要另外考虑使用分布式 ID）。</p><p><strong>2.通过 <code>@GenericGenerator</code>声明一个主键策略，然后 <code>@GeneratedValue</code>使用这个策略</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Id</span></span><br><span class="line"><span class="meta">@GeneratedValue(generator = &quot;IdentityIdGenerator&quot;)</span></span><br><span class="line"><span class="meta">@GenericGenerator(name = &quot;IdentityIdGenerator&quot;, strategy = &quot;identity&quot;)</span></span><br><span class="line"><span class="keyword">private</span> Long id;</span><br></pre></td></tr></table></figure><p>等价于：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Id</span></span><br><span class="line"><span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line"><span class="keyword">private</span> Long id;</span><br></pre></td></tr></table></figure><p>jpa 提供的主键生成策略有如下几种：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultIdentifierGeneratorFactory</span></span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">MutableIdentifierGeneratorFactory</span>, <span class="title">Serializable</span>, <span class="title">ServiceRegistryAwareService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;deprecation&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DefaultIdentifierGeneratorFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">register( <span class="string">&quot;uuid2&quot;</span>, UUIDGenerator.class );</span><br><span class="line">register( <span class="string">&quot;guid&quot;</span>, GUIDGenerator.class );<span class="comment">// can be done with UUIDGenerator + strategy</span></span><br><span class="line">register( <span class="string">&quot;uuid&quot;</span>, UUIDHexGenerator.class );<span class="comment">// &quot;deprecated&quot; for new use</span></span><br><span class="line">register( <span class="string">&quot;uuid.hex&quot;</span>, UUIDHexGenerator.class ); <span class="comment">// uuid.hex is deprecated</span></span><br><span class="line">register( <span class="string">&quot;assigned&quot;</span>, Assigned.class );</span><br><span class="line">register( <span class="string">&quot;identity&quot;</span>, IdentityGenerator.class );</span><br><span class="line">register( <span class="string">&quot;select&quot;</span>, SelectGenerator.class );</span><br><span class="line">register( <span class="string">&quot;sequence&quot;</span>, SequenceStyleGenerator.class );</span><br><span class="line">register( <span class="string">&quot;seqhilo&quot;</span>, SequenceHiLoGenerator.class );</span><br><span class="line">register( <span class="string">&quot;increment&quot;</span>, IncrementGenerator.class );</span><br><span class="line">register( <span class="string">&quot;foreign&quot;</span>, ForeignGenerator.class );</span><br><span class="line">register( <span class="string">&quot;sequence-identity&quot;</span>, SequenceIdentityGenerator.class );</span><br><span class="line">register( <span class="string">&quot;enhanced-sequence&quot;</span>, SequenceStyleGenerator.class );</span><br><span class="line">register( <span class="string">&quot;enhanced-table&quot;</span>, TableGenerator.class );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(String strategy, Class generatorClass)</span> </span>&#123;</span><br><span class="line">LOG.debugf( <span class="string">&quot;Registering IdentifierGenerator strategy [%s] -&gt; [%s]&quot;</span>, strategy, generatorClass.getName() );</span><br><span class="line"><span class="keyword">final</span> Class previous = generatorStrategyToClassNameMap.put( strategy, generatorClass );</span><br><span class="line"><span class="keyword">if</span> ( previous != <span class="keyword">null</span> ) &#123;</span><br><span class="line">LOG.debugf( <span class="string">&quot;    - overriding [%s]&quot;</span>, previous.getName() );</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-3-设置字段类型"><a href="#8-3-设置字段类型" class="headerlink" title="8.3. 设置字段类型"></a>8.3. 设置字段类型</h4><p><code>@Column</code> 声明字段。</p><p><strong>示例：</strong></p><p>设置属性 userName 对应的数据库字段名为 user_name，长度为 32，非空</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Column(name = &quot;user_name&quot;, nullable = false, length=32)</span></span><br><span class="line"><span class="keyword">private</span> String userName;</span><br></pre></td></tr></table></figure><p>设置字段类型并且加默认值，这个还是挺常用的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Column(columnDefinition = <span class="string">&quot;tinyint(1) default 1&quot;</span>)</span><br><span class="line"><span class="keyword">private</span> Boolean enabled;</span><br></pre></td></tr></table></figure><h4 id="8-4-指定不持久化特定字段"><a href="#8-4-指定不持久化特定字段" class="headerlink" title="8.4. 指定不持久化特定字段"></a>8.4. 指定不持久化特定字段</h4><p><code>@Transient</code> ：声明不需要与数据库映射的字段，在保存的时候不需要保存进数据库 。</p><p>如果我们想让<code>secrect</code> 这个字段不被持久化，可以使用 <code>@Transient</code>关键字声明。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Entity(name=<span class="string">&quot;USER&quot;</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    <span class="meta">@Transient</span></span><br><span class="line">    <span class="keyword">private</span> String secrect; <span class="comment">// not persistent because of @Transient</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了 <code>@Transient</code>关键字声明， 还可以采用下面几种方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> String secrect; <span class="comment">// not persistent because of static</span></span><br><span class="line"><span class="keyword">final</span> String secrect = “Satish”; <span class="comment">// not persistent because of final</span></span><br><span class="line"><span class="keyword">transient</span> String secrect; <span class="comment">// not persistent because of transient</span></span><br></pre></td></tr></table></figure><p>一般使用注解的方式比较多。</p><h4 id="8-5-声明大字段"><a href="#8-5-声明大字段" class="headerlink" title="8.5. 声明大字段"></a>8.5. 声明大字段</h4><p><code>@Lob</code>:声明某个字段为大字段。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Lob</span></span><br><span class="line"><span class="keyword">private</span> String content;</span><br></pre></td></tr></table></figure><p>更详细的声明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Lob</span></span><br><span class="line"><span class="comment">//指定 Lob 类型数据的获取策略， FetchType.EAGER 表示非延迟 加载，而 FetchType. LAZY 表示延迟加载 ；</span></span><br><span class="line"><span class="meta">@Basic(fetch = FetchType.EAGER)</span></span><br><span class="line"><span class="comment">//columnDefinition 属性指定数据表对应的 Lob 字段类型</span></span><br><span class="line"><span class="meta">@Column(name = &quot;content&quot;, columnDefinition = &quot;LONGTEXT NOT NULL&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String content;</span><br></pre></td></tr></table></figure><h4 id="8-6-创建枚举类型的字段"><a href="#8-6-创建枚举类型的字段" class="headerlink" title="8.6. 创建枚举类型的字段"></a>8.6. 创建枚举类型的字段</h4><p>可以使用枚举类型的字段，不过枚举字段要用<code>@Enumerated</code>注解修饰。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Gender</span> </span>&#123;</span><br><span class="line">    MALE(<span class="string">&quot;男性&quot;</span>),</span><br><span class="line">    FEMALE(<span class="string">&quot;女性&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String value;</span><br><span class="line">    Gender(String str)&#123;</span><br><span class="line">        value=str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table(name = &quot;role&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Role</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String description;</span><br><span class="line">    <span class="meta">@Enumerated(EnumType.STRING)</span></span><br><span class="line">    <span class="keyword">private</span> Gender gender;</span><br><span class="line">    省略getter/setter......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数据库里面对应存储的是 MAIL/FEMAIL。</p><h4 id="8-7-增加审计功能"><a href="#8-7-增加审计功能" class="headerlink" title="8.7. 增加审计功能"></a>8.7. 增加审计功能</h4><p>只要继承了 <code>AbstractAuditBase</code>的类都会默认加上下面四个字段。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@MappedSuperclass</span></span><br><span class="line"><span class="meta">@EntityListeners(value = AuditingEntityListener.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractAuditBase</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@CreatedDate</span></span><br><span class="line">    <span class="meta">@Column(updatable = false)</span></span><br><span class="line">    <span class="meta">@JsonIgnore</span></span><br><span class="line">    <span class="keyword">private</span> Instant createdAt;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@LastModifiedDate</span></span><br><span class="line">    <span class="meta">@JsonIgnore</span></span><br><span class="line">    <span class="keyword">private</span> Instant updatedAt;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@CreatedBy</span></span><br><span class="line">    <span class="meta">@Column(updatable = false)</span></span><br><span class="line">    <span class="meta">@JsonIgnore</span></span><br><span class="line">    <span class="keyword">private</span> String createdBy;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@LastModifiedBy</span></span><br><span class="line">    <span class="meta">@JsonIgnore</span></span><br><span class="line">    <span class="keyword">private</span> String updatedBy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们对应的审计功能对应地配置类可能是下面这样的（Spring Security 项目）:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableJpaAuditing</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuditSecurityConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">AuditorAware&lt;String&gt; <span class="title">auditorAware</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> () -&gt; Optional.ofNullable(SecurityContextHolder.getContext())</span><br><span class="line">                .map(SecurityContext::getAuthentication)</span><br><span class="line">                .filter(Authentication::isAuthenticated)</span><br><span class="line">                .map(Authentication::getName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单介绍一下上面设计到的一些注解：</p><ol><li><p><code>@CreatedDate</code>: 表示该字段为创建时间时间字段，在这个实体被 insert 的时候，会设置值</p></li><li><p><code>@CreatedBy</code> :表示该字段为创建人，在这个实体被 insert 的时候，会设置值</p><p><code>@LastModifiedDate</code>、<code>@LastModifiedBy</code>同理。</p></li></ol><p><code>@EnableJpaAuditing</code>：开启 JPA 审计功能。</p><h4 id="8-8-删除-修改数据"><a href="#8-8-删除-修改数据" class="headerlink" title="8.8. 删除/修改数据"></a>8.8. 删除/修改数据</h4><p><code>@Modifying</code> 注解提示 JPA 该操作是修改操作,注意还要配合<code>@Transactional</code>注解使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">User</span>, <span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Modifying</span></span><br><span class="line">    <span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deleteByUserName</span><span class="params">(String userName)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-9-关联关系"><a href="#8-9-关联关系" class="headerlink" title="8.9. 关联关系"></a>8.9. 关联关系</h4><ul><li><code>@OneToOne</code> 声明一对一关系</li><li><code>@OneToMany</code> 声明一对多关系</li><li><code>@ManyToOne</code>声明多对一关系</li><li><code>MangToMang</code>声明多对多关系</li></ul><h3 id="9-事务-Transactional"><a href="#9-事务-Transactional" class="headerlink" title="9. 事务 @Transactional"></a>9. 事务 <code>@Transactional</code></h3><p>在要开启事务的方法上使用<code>@Transactional</code>注解即可!</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们知道 Exception 分为运行时异常 RuntimeException 和非运行时异常。在<code>@Transactional</code>注解中如果不配置<code>rollbackFor</code>属性,那么事物只会在遇到<code>RuntimeException</code>的时候才会回滚,加上<code>rollbackFor=Exception.class</code>,可以让事物在遇到非运行时异常时也回滚。</p><p><code>@Transactional</code> 注解一般用在可以作用在<code>类</code>或者<code>方法</code>上。</p><ul><li><strong>作用于类</strong>：当把<code>@Transactional 注解放在类上时，表示所有该类的</code>public 方法都配置相同的事务属性信息。</li><li><strong>作用于方法</strong>：当类配置了<code>@Transactional</code>，方法也配置了<code>@Transactional</code>，方法的事务会覆盖类的事务配置信息。</li></ul><h3 id="10-json-数据处理"><a href="#10-json-数据处理" class="headerlink" title="10. json 数据处理"></a>10. json 数据处理</h3><h4 id="10-1-过滤-json-数据"><a href="#10-1-过滤-json-数据" class="headerlink" title="10.1. 过滤 json 数据"></a>10.1. 过滤 json 数据</h4><p><strong><code>@JsonIgnoreProperties</code> 作用在类上用于过滤掉特定字段不返回或者不解析。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//生成json时将userRoles属性过滤</span></span><br><span class="line"><span class="meta">@JsonIgnoreProperties(&#123;&quot;userRoles&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="keyword">private</span> String fullName;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="meta">@JsonIgnore</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;UserRole&gt; userRoles = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>@JsonIgnore</code>一般用于类的属性上，作用和上面的<code>@JsonIgnoreProperties</code> 一样。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="keyword">private</span> String fullName;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">   <span class="comment">//生成json时将userRoles属性过滤</span></span><br><span class="line">    <span class="meta">@JsonIgnore</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;UserRole&gt; userRoles = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="10-2-格式化-json-数据"><a href="#10-2-格式化-json-数据" class="headerlink" title="10.2. 格式化 json 数据"></a>10.2. 格式化 json 数据</h4><p><code>@JsonFormat</code>一般用来格式化 json 数据。：</p><p>比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JsonFormat(shape=JsonFormat.Shape.STRING, pattern=&quot;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSS&#x27;Z&#x27;&quot;, timezone=&quot;GMT&quot;)</span></span><br><span class="line"><span class="keyword">private</span> Date date;</span><br></pre></td></tr></table></figure><h4 id="10-3-扁平化对象"><a href="#10-3-扁平化对象" class="headerlink" title="10.3. 扁平化对象"></a>10.3. 扁平化对象</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line">    <span class="meta">@JsonUnwrapped</span></span><br><span class="line">    <span class="keyword">private</span> Location location;</span><br><span class="line">    <span class="meta">@JsonUnwrapped</span></span><br><span class="line">    <span class="keyword">private</span> PersonInfo personInfo;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Getter</span></span><br><span class="line">  <span class="meta">@Setter</span></span><br><span class="line">  <span class="meta">@ToString</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Location</span> </span>&#123;</span><br><span class="line">     <span class="keyword">private</span> String provinceName;</span><br><span class="line">     <span class="keyword">private</span> String countyName;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Getter</span></span><br><span class="line">  <span class="meta">@Setter</span></span><br><span class="line">  <span class="meta">@ToString</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonInfo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="keyword">private</span> String fullName;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>未扁平化之前：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;location&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;provinceName&quot;</span>:<span class="string">&quot;广东&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;countyName&quot;</span>:<span class="string">&quot;广州&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;personInfo&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;userName&quot;</span>: <span class="string">&quot;pluto&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;fullName&quot;</span>: <span class="string">&quot;plutowu&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>@JsonUnwrapped</code> 扁平对象之后：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line">    <span class="meta">@JsonUnwrapped</span></span><br><span class="line">    <span class="keyword">private</span> Location location;</span><br><span class="line">    <span class="meta">@JsonUnwrapped</span></span><br><span class="line">    <span class="keyword">private</span> PersonInfo personInfo;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;provinceName&quot;</span>:<span class="string">&quot;广东&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;countyName&quot;</span>:<span class="string">&quot;广州&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;userName&quot;</span>: <span class="string">&quot;pluto&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;fullName&quot;</span>: <span class="string">&quot;plutowu&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="11-测试相关"><a href="#11-测试相关" class="headerlink" title="11. 测试相关"></a>11. 测试相关</h3><p><strong><code>@ActiveProfiles</code>一般作用于测试类上， 用于声明生效的 Spring 配置文件。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest(webEnvironment = RANDOM_PORT)</span></span><br><span class="line"><span class="meta">@ActiveProfiles(&quot;test&quot;)</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBase</span> </span>&#123;</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>@Test</code>声明一个方法为测试方法</strong></p><p><strong><code>@Transactional</code>被声明的测试方法的数据会回滚，避免污染测试数据。</strong></p><p><strong><code>@WithMockUser</code> Spring Security 提供的，用来模拟一个真实用户，并且可以赋予权限。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="meta">@WithMockUser(username = &quot;user-id-18163138155&quot;, authorities = &quot;ROLE_TEACHER&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">should_import_student_success</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;框架相关&quot;&gt;&lt;a href=&quot;#框架相关&quot; class=&quot;headerlink&quot; title=&quot;框架相关&quot;&gt;&lt;/a&gt;框架相关&lt;/h1&gt;&lt;h2 id=&quot;1-SpringBoot-自动装配原理&quot;&gt;&lt;a href=&quot;#1-SpringBoot-自动装配原理&quot; class=&quot;headerlink&quot; title=&quot;1.SpringBoot 自动装配原理&quot;&gt;&lt;/a&gt;1.SpringBoot 自动装配原理&lt;/h2&gt;&lt;h3 id=&quot;什么是-SpringBoot-自动装配？&quot;&gt;&lt;a href=&quot;#什么是-SpringBoot-自动装配？&quot; class=&quot;headerlink&quot; title=&quot;什么是 SpringBoot 自动装配？&quot;&gt;&lt;/a&gt;什么是 SpringBoot 自动装配？&lt;/h3&gt;&lt;p&gt;我们现在提到自动装配的时候，一般会和 Spring Boot 联系在一起。但是，实际上 Spring Framework 早就实现了这个功能。Spring Boot 只是在其基础上，通过 SPI 的方式，做了进一步优化。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;SpringBoot 定义了一套接口规范，这套规范规定：SpringBoot 在启动时会扫描外部引用 jar 包中的&lt;code&gt;META-INF/spring.factories&lt;/code&gt;文件，将文件中配置的类型信息加载到 Spring 容器（此处涉及到 JVM 类加载机制与 Spring 的容器知识），并执行类中定义的各种操作。对于外部 jar 来说，只需要按照 SpringBoot 定义的标准，就能将自己的功能装置进 SpringBoot。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;没有 Spring Boot 的情况下，如果我们需要引入第三方依赖，需要手动配置，非常麻烦。但是，Spring Boot 中，我们直接引入一个 starter 即可。比如你想要在项目中使用 redis 的话，直接在项目中引入对应的 starter 即可。&lt;/p&gt;
&lt;figure class=&quot;highlight xml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter-data-redis&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;引入 starter 之后，我们通过少量注解和一些简单的配置就能使用第三方组件提供的功能了。&lt;/p&gt;
&lt;p&gt;在我看来，自动装配可以简单理解为：&lt;strong&gt;通过注解或者一些简单的配置就能在 Spring Boot 的帮助下实现某块功能。&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="面试" scheme="http://plutowu.top/categories/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="Java" scheme="http://plutowu.top/categories/%E9%9D%A2%E8%AF%95/Java/"/>
    
    <category term="笔记" scheme="http://plutowu.top/categories/%E9%9D%A2%E8%AF%95/Java/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="笔记" scheme="http://plutowu.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Java" scheme="http://plutowu.top/tags/Java/"/>
    
    <category term="面试" scheme="http://plutowu.top/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="框架" scheme="http://plutowu.top/tags/%E6%A1%86%E6%9E%B6/"/>
    
    <category term="SpringBoot" scheme="http://plutowu.top/tags/SpringBoot/"/>
    
    <category term="Spring" scheme="http://plutowu.top/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Java后端面试笔记-I/O</title>
    <link href="http://plutowu.top/2021/03/10/Java%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AE%B0-I-O/"/>
    <id>http://plutowu.top/2021/03/10/Java%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AE%B0-I-O/</id>
    <published>2021-03-10T14:24:34.000Z</published>
    <updated>2021-03-11T02:50:00.658Z</updated>
    
    <content type="html"><![CDATA[<h1 id="I-O相关"><a href="#I-O相关" class="headerlink" title="I/O相关"></a>I/O相关</h1><h2 id="1-常见的I-O模型有哪些？Java中BIO、NIO、AIO的区别？"><a href="#1-常见的I-O模型有哪些？Java中BIO、NIO、AIO的区别？" class="headerlink" title="1.常见的I/O模型有哪些？Java中BIO、NIO、AIO的区别？"></a>1.常见的I/O模型有哪些？Java中BIO、NIO、AIO的区别？</h2><h3 id="BIO-Blocking-I-O"><a href="#BIO-Blocking-I-O" class="headerlink" title="BIO (Blocking I/O)"></a>BIO (Blocking I/O)</h3><p><strong>BIO 属于同步阻塞 IO 模型</strong> 。</p><p>同步阻塞 IO 模型中，应用程序发起 read 调用后，会一直阻塞，直到在内核把数据拷贝到用户空间。</p><p><img src="https://plutowu-blogimgs.oss-cn-guangzhou.aliyuncs.com/img/20210310124137.png"></p><p>在客户端连接数量不高的情况下，是没问题的。但是，当面对十万甚至百万级连接的时候，传统的 BIO 模型是无能为力的。因此，我们需要一种更高效的 I/O 处理模型来应对更高的并发量。</p><a id="more"></a><h3 id="NIO-Non-blocking-New-I-O"><a href="#NIO-Non-blocking-New-I-O" class="headerlink" title="NIO (Non-blocking/New I/O)"></a>NIO (Non-blocking/New I/O)</h3><p>Java 中的 NIO 于 Java 1.4 中引入，对应 <code>java.nio</code> 包，提供了 <code>Channel</code> , <code>Selector</code>，<code>Buffer</code> 等抽象。NIO 中的 N 可以理解为 Non-blocking，不单纯是 New。它支持面向缓冲的，基于通道的 I/O 操作方法。 对于高负载、高并发的（网络）应用，应使用 NIO 。</p><p>Java 中的 NIO 可以看作是 <strong>I/O 多路复用模型</strong>。也有很多人认为，Java 中的 NIO 属于同步非阻塞 IO 模型。</p><p>跟着我的思路往下看看，相信你会得到答案！</p><p>我们先来看看 <strong>同步非阻塞 IO 模型</strong>。</p><p><img src="https://plutowu-blogimgs.oss-cn-guangzhou.aliyuncs.com/img/20210310124333.png"></p><p>同步非阻塞 IO 模型中，应用程序会一直发起 read 调用，等待数据从内核空间拷贝到用户空间的这段时间里，线程依然是阻塞的，直到在内核把数据拷贝到用户空间。</p><p>相比于同步阻塞 IO 模型，同步非阻塞 IO 模型确实有了很大改进。通过轮询操作，避免了一直阻塞。</p><p>但是，这种 IO 模型同样存在问题：<strong>应用程序不断进行 I/O 系统调用轮询数据是否已经准备好的过程是十分消耗 CPU 资源的。</strong></p><p>这个时候，<strong>I/O 多路复用模型</strong> 就上场了。</p><p><img src="https://plutowu-blogimgs.oss-cn-guangzhou.aliyuncs.com/img/20210310124406.png"></p><p>IO 多路复用模型中，线程首先发起 select 调用，询问内核数据是否准备就绪，等内核把数据准备好了，用户线程再发起 read 调用。read 调用的过程（数据从内核空间-&gt;用户空间）还是阻塞的。</p><blockquote><p>目前支持 IO 多路复用的系统调用，有 select，epoll 等等。select 系统调用，是目前几乎在所有的操作系统上都有支持</p><ul><li><strong>select 调用</strong> ：内核提供的系统调用，它支持一次查询多个系统调用的可用状态。几乎所有的操作系统都支持。</li><li><strong>epoll 调用</strong> ：linux 2.6 内核，属于 select 调用的增强版本，优化了 IO 的执行效率。</li></ul></blockquote><p><strong>IO 多路复用模型，通过减少无效的系统调用，减少了对 CPU 资源的消耗。</strong></p><p>Java 中的 NIO ，有一个非常重要的<strong>选择器 ( Selector )</strong> 的概念，也可以被称为 <strong>多路复用器</strong>。通过它，只需要一个线程便可以管理多个客户端连接。当客户端数据到了之后，才会为其服务。</p><p><img src="https://plutowu-blogimgs.oss-cn-guangzhou.aliyuncs.com/img/20210310124438.png"></p><h3 id="AIO-Asynchronous-I-O"><a href="#AIO-Asynchronous-I-O" class="headerlink" title="AIO (Asynchronous I/O)"></a>AIO (Asynchronous I/O)</h3><p>AIO 也就是 NIO 2。Java 7 中引入了 NIO 的改进版 NIO 2,它是异步 IO 模型。</p><p>异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。</p><p><img src="https://plutowu-blogimgs.oss-cn-guangzhou.aliyuncs.com/img/20210310124459.png"></p><p>目前来说 AIO 的应用还不是很广泛。Netty 之前也尝试使用过 AIO，不过又放弃了。这是因为，Netty 使用了 AIO 之后，在 Linux 系统上的性能并没有多少提升。</p><p>最后，来一张图，简单总结一下 Java 中的 BIO、NIO、AIO。</p><p><img src="https://plutowu-blogimgs.oss-cn-guangzhou.aliyuncs.com/img/20210310124518.png"></p><h2 id="2-Java-中的I-O流"><a href="#2-Java-中的I-O流" class="headerlink" title="2. Java 中的I/O流"></a>2. Java 中的I/O流</h2><ul><li>按照流的流向分，可以分为输入流和输出流；</li><li>按照操作单元划分，可以划分为字节流和字符流；</li><li>按照流的角色划分为节点流和处理流。</li></ul><p>Java I/O 流共涉及 40 多个类，这些类看上去很杂乱，但实际上很有规则，而且彼此之间存在非常紧密的联系， Java I/0 流的 40 多个类都是从如下 4 个抽象类基类中派生出来的。</p><ul><li>InputStream/Reader: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。</li><li>OutputStream/Writer: 所有输出流的基类，前者是字节输出流，后者是字符输出流。</li></ul><p>按操作方式分类结构图：</p><p><img src="https://plutowu-blogimgs.oss-cn-guangzhou.aliyuncs.com/img/20210311103940.png"></p><p>按操作对象分类结构图：</p><p><img src="https://plutowu-blogimgs.oss-cn-guangzhou.aliyuncs.com/img/20210311103946.png"></p><h3 id="既然有了字节流-为什么还要有字符流"><a href="#既然有了字节流-为什么还要有字符流" class="headerlink" title="既然有了字节流,为什么还要有字符流?"></a>既然有了字节流,为什么还要有字符流?</h3><p>问题本质想问：<strong>不管是文件读写还是网络发送接收，信息的最小存储单元都是字节，那为什么 I/O 流操作要分为字节流操作和字符流操作呢？</strong></p><p>回答：字符流是由 Java 虚拟机将字节转换得到的，问题就出在这个过程还算是非常耗时，并且，如果我们不知道编码类型就很容易出现乱码问题。所以， I/O 流就干脆提供了一个直接操作字符的接口，方便我们平时对字符进行流操作。如果音频文件、图片等媒体文件用字节流比较好，如果涉及到字符的话使用字符流比较好。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;I-O相关&quot;&gt;&lt;a href=&quot;#I-O相关&quot; class=&quot;headerlink&quot; title=&quot;I/O相关&quot;&gt;&lt;/a&gt;I/O相关&lt;/h1&gt;&lt;h2 id=&quot;1-常见的I-O模型有哪些？Java中BIO、NIO、AIO的区别？&quot;&gt;&lt;a href=&quot;#1-常见的I-O模型有哪些？Java中BIO、NIO、AIO的区别？&quot; class=&quot;headerlink&quot; title=&quot;1.常见的I/O模型有哪些？Java中BIO、NIO、AIO的区别？&quot;&gt;&lt;/a&gt;1.常见的I/O模型有哪些？Java中BIO、NIO、AIO的区别？&lt;/h2&gt;&lt;h3 id=&quot;BIO-Blocking-I-O&quot;&gt;&lt;a href=&quot;#BIO-Blocking-I-O&quot; class=&quot;headerlink&quot; title=&quot;BIO (Blocking I/O)&quot;&gt;&lt;/a&gt;BIO (Blocking I/O)&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;BIO 属于同步阻塞 IO 模型&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;同步阻塞 IO 模型中，应用程序发起 read 调用后，会一直阻塞，直到在内核把数据拷贝到用户空间。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://plutowu-blogimgs.oss-cn-guangzhou.aliyuncs.com/img/20210310124137.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;在客户端连接数量不高的情况下，是没问题的。但是，当面对十万甚至百万级连接的时候，传统的 BIO 模型是无能为力的。因此，我们需要一种更高效的 I/O 处理模型来应对更高的并发量。&lt;/p&gt;</summary>
    
    
    
    <category term="面试" scheme="http://plutowu.top/categories/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="Java" scheme="http://plutowu.top/categories/%E9%9D%A2%E8%AF%95/Java/"/>
    
    <category term="笔记" scheme="http://plutowu.top/categories/%E9%9D%A2%E8%AF%95/Java/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="笔记" scheme="http://plutowu.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Java" scheme="http://plutowu.top/tags/Java/"/>
    
    <category term="面试" scheme="http://plutowu.top/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="I/O" scheme="http://plutowu.top/tags/I-O/"/>
    
  </entry>
  
  <entry>
    <title>Java后端面试笔记-JVM</title>
    <link href="http://plutowu.top/2021/03/09/Java%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AE%B0-JVM/"/>
    <id>http://plutowu.top/2021/03/09/Java%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AE%B0-JVM/</id>
    <published>2021-03-09T13:40:16.000Z</published>
    <updated>2021-03-11T01:21:54.841Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JVM相关"><a href="#JVM相关" class="headerlink" title="JVM相关"></a>JVM相关</h1><h2 id="1-修改Java字节码"><a href="#1-修改Java字节码" class="headerlink" title="1.修改Java字节码"></a>1.修改Java字节码</h2><p>在OpenJDK里有一个<code>AsmTools</code>项目，用来生成正确的或者不正确的java <code>.class</code>文件，主要用来测试和验证。</p><p><code>AsmTools</code>引入了两种表示<code>.class</code>文件的语法：</p><ul><li><p>JASM</p><p>用类似java本身的语法来定义类和函数，字节码指令则很像传统的汇编。</p></li><li><p>JCOD</p><p>整个<code>.class</code>用容器的方式来表示，可以很清楚表示类文件的结构。</p></li></ul><p>重要的是两种语法的文件都是可以和<code>.class</code>互相转换的。</p><p>在这里主要使用<code>JASM</code>语法。</p><a id="more"></a><h3 id="生成asmtools-jar"><a href="#生成asmtools-jar" class="headerlink" title="生成asmtools.jar"></a>生成asmtools.jar</h3><p>如果你的机器没有安装 <code>Mercurial</code>，请先安装(Mericurial 类似 Git 和 SVN，是一个分布式版本控制系统，使用 Python 编写，OpenJDK 就托管在 Mercurial 平台上)</p><p>然后执行以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// Clone代码</span><br><span class="line">hg clone ://hg.openjdk.java.net/code-tools/asmtools</span><br><span class="line"></span><br><span class="line">// 编译</span><br><span class="line">cd asmtools/build</span><br><span class="line">ant</span><br></pre></td></tr></table></figure><p>即可得到asmtools.jar文件。</p><h3 id="准备一个Example"><a href="#准备一个Example" class="headerlink" title="准备一个Example"></a>准备一个Example</h3><p>Foo.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">  <span class="keyword">if</span> (flag) System.out.println(<span class="string">&quot;Hello, Java!&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (flag == <span class="keyword">true</span>) System.out.println(<span class="string">&quot;Hello, JVM!&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>javac Foo.java</code>命令生成Foo.class文件，使用JD-GUI打开内容如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.PrintStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] paramArrayOfString)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (i != <span class="number">0</span>) &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Hello, Java!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">1</span>) &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Hello, JVM!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>java Foo</code>命令运行Foo.class文件输出结果：</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Hello,</span> Java!</span><br><span class="line"><span class="built_in">Hello,</span> JVM!</span><br></pre></td></tr></table></figure><h3 id="由class文件生成jasm文件"><a href="#由class文件生成jasm文件" class="headerlink" title="由class文件生成jasm文件"></a>由class文件生成jasm文件</h3><p>如下命令将class文件中的内容转换成对应的jasm语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar asmtools.jar jdis Foo.class</span><br></pre></td></tr></table></figure><p>上面输出的内容会直接打印在终端，当然你也可以把它输入到文件中：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar asmtools.jar jdis <span class="module-access"><span class="module"><span class="identifier">Foo</span>.</span></span><span class="keyword">class</span> &gt; <span class="module-access"><span class="module"><span class="identifier">Foo</span>.</span></span>jasm</span><br></pre></td></tr></table></figure><p>Foo.jasm 文件内容如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">super</span> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span></span><br><span class="line">    version 52:0</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Method <span class="string">&quot;&lt;init&gt;&quot;</span>:<span class="string">&quot;()V&quot;</span></span><br><span class="line">    stack <span class="number">1</span> locals <span class="number">1</span></span><br><span class="line">&#123;</span><br><span class="line">        aload_0;</span><br><span class="line">        invokespecial   Method java/lang/Object.<span class="string">&quot;&lt;init&gt;&quot;</span>:<span class="string">&quot;()V&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Method main:<span class="string">&quot;([Ljava/lang/String;)V&quot;</span></span><br><span class="line">    stack <span class="number">2</span> locals <span class="number">2</span></span><br><span class="line">&#123;</span><br><span class="line">        iconst_1;</span><br><span class="line">        istore_1;</span><br><span class="line">        iload_1;</span><br><span class="line">        ifeq    L14;</span><br><span class="line">        getstatic   Field java/lang/System.out:<span class="string">&quot;Ljava/io/PrintStream;&quot;</span>;</span><br><span class="line">        ldc String <span class="string">&quot;Hello, Java!&quot;</span>;</span><br><span class="line">        invokevirtual   Method java/io/PrintStream.println:<span class="string">&quot;(Ljava/lang/String;)V&quot;</span>;</span><br><span class="line">    L14:    stack_frame_type append;</span><br><span class="line">        locals_map <span class="keyword">int</span>;</span><br><span class="line">        iload_1;</span><br><span class="line">        iconst_1;</span><br><span class="line">        if_icmpne   L27;</span><br><span class="line">        getstatic   Field java/lang/System.out:<span class="string">&quot;Ljava/io/PrintStream;&quot;</span>;</span><br><span class="line">        ldc String <span class="string">&quot;Hello, JVM!&quot;</span>;</span><br><span class="line">        invokevirtual   Method java/io/PrintStream.println:<span class="string">&quot;(Ljava/lang/String;)V&quot;</span>;</span><br><span class="line">    L27:    stack_frame_type same;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// end Class Foo</span></span><br></pre></td></tr></table></figure><p>为了将 Foo.class 中的 <code>int i = 1;</code> 修改成 <code>int i = 2;</code>，我们需要替换 Foo.jasm 文件中的 <code>iconst_1</code> 为 <code>iconst_2</code>。</p><h3 id="由jasm文件生成class文件"><a href="#由jasm文件生成class文件" class="headerlink" title="由jasm文件生成class文件"></a>由jasm文件生成class文件</h3><p>执行如下命令：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">java </span>-<span class="keyword">jar </span>asmtools.<span class="keyword">jar </span><span class="keyword">jasm </span>Foo.<span class="keyword">jasm</span></span><br></pre></td></tr></table></figure><p>这时再用 JD-GUI 打开 Foo.class 文件，内容如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.PrintStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] paramArrayOfString)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (i != <span class="number">0</span>) &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Hello, Java!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">1</span>) &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Hello, JVM!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到 i 的确由 1 变成 2 了。</p><p><code>java Foo</code> 输出内容如下：</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Hello,</span> Java!</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>其实就两个命令：</p><ul><li>由 class 文件生成 jasm 文件：<code>java -jar asmtools.jar jdis Foo.class &gt; Foo.jasm</code></li><li>由 jasm 文件生成 class 文件：<code>java -jar asmtools.jar jasm Foo.jasm</code></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;JVM相关&quot;&gt;&lt;a href=&quot;#JVM相关&quot; class=&quot;headerlink&quot; title=&quot;JVM相关&quot;&gt;&lt;/a&gt;JVM相关&lt;/h1&gt;&lt;h2 id=&quot;1-修改Java字节码&quot;&gt;&lt;a href=&quot;#1-修改Java字节码&quot; class=&quot;headerlink&quot; title=&quot;1.修改Java字节码&quot;&gt;&lt;/a&gt;1.修改Java字节码&lt;/h2&gt;&lt;p&gt;在OpenJDK里有一个&lt;code&gt;AsmTools&lt;/code&gt;项目，用来生成正确的或者不正确的java &lt;code&gt;.class&lt;/code&gt;文件，主要用来测试和验证。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;AsmTools&lt;/code&gt;引入了两种表示&lt;code&gt;.class&lt;/code&gt;文件的语法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;JASM&lt;/p&gt;
&lt;p&gt;用类似java本身的语法来定义类和函数，字节码指令则很像传统的汇编。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;JCOD&lt;/p&gt;
&lt;p&gt;整个&lt;code&gt;.class&lt;/code&gt;用容器的方式来表示，可以很清楚表示类文件的结构。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;重要的是两种语法的文件都是可以和&lt;code&gt;.class&lt;/code&gt;互相转换的。&lt;/p&gt;
&lt;p&gt;在这里主要使用&lt;code&gt;JASM&lt;/code&gt;语法。&lt;/p&gt;</summary>
    
    
    
    <category term="面试" scheme="http://plutowu.top/categories/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="Java" scheme="http://plutowu.top/categories/%E9%9D%A2%E8%AF%95/Java/"/>
    
    <category term="笔记" scheme="http://plutowu.top/categories/%E9%9D%A2%E8%AF%95/Java/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="笔记" scheme="http://plutowu.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Java" scheme="http://plutowu.top/tags/Java/"/>
    
    <category term="面试" scheme="http://plutowu.top/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="JVM" scheme="http://plutowu.top/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>睡前故事-白雪为嫁</title>
    <link href="http://plutowu.top/2020/11/23/%E7%9D%A1%E5%89%8D%E6%95%85%E4%BA%8B-%E7%99%BD%E9%9B%AA%E4%B8%BA%E5%AB%81/"/>
    <id>http://plutowu.top/2020/11/23/%E7%9D%A1%E5%89%8D%E6%95%85%E4%BA%8B-%E7%99%BD%E9%9B%AA%E4%B8%BA%E5%AB%81/</id>
    <published>2020-11-23T15:23:59.000Z</published>
    <updated>2021-03-11T02:55:00.001Z</updated>
    
    <content type="html"><![CDATA[<p>风暴戾地撞着窗，这个冬天格外冰冷。</p><p>“你听话呀。”母亲的声音疲惫而心疼，“他家条件差得很，还有两个兄弟没成家。你跟过去吃没得吃、穿没得穿，只有受苦啊！”</p><p>她和母亲并排躺在床上，抿着嘴唇并不出声，唯有泪珠成串滚落，很快浸湿枕巾。</p><p>母亲侧着身，用右手柔柔帮她擦着泪，也有些哽咽：“妈妈都是为你好，你醒点事，好么？他平日里就会打架闹事，不是个有出息的人。”</p><p>她吸了一下鼻子，眼睛执拗地闭着，无声哭泣。</p><p>“明天去把孩子拿掉就好了。”母亲的声音在耳边继续着，她有她的苦心与疼爱，“时间久了你就不难过了，妈妈给你找个好婆家，保证比他强，过日子总归是要吃饱穿暖。”</p><p>她抬了抬右手，没能抬动。</p><p>母亲警觉地握紧了她的手。</p><p>她的右手和母亲的左手紧紧绑在一起，布条还打了死结。</p><p>“你们三兄妹里，妈妈最疼你，哪里能看着你吃苦。”母亲见止不住她的泪，自己的眼泪也落了下来，“你这个苕伢子……”</p><p>母亲哭了一阵，帮她掖好被子，终于结束了劝慰，“很晚了，好好睡一觉，天亮妈妈就带你去医院。”</p><a id="more"></a><hr><p>时间，怎么这么难熬呢？</p><p>眼泪，好像流干了。</p><p>眼睛涩涩的，她一动不动，静静听着旁边的呼吸声。</p><p>呼吸很平稳，应是已睡熟了。但她仍不敢动，她知道机会只有一次。</p><p>她很累，东躲西藏，最终还是被家人抓回来，已经身心俱疲。但她一点睡意也没有，她在心里默默地算着时间。</p><p>这会儿应该是凌晨了，外面的房间很久没有动静，父亲应该也睡了。</p><p>她试探着侧转身体，面对母亲。母亲闭着眼睛，毫无反应。</p><p>母亲也很累了，这阵子她一定也很难过吧？她那么疼爱儿女。</p><p>可是，对不起妈妈，这次我不能听话。她在黑夜里看着母亲隐约的脸，心里默默说道。</p><p>沉默不是顺从，是在等这唯一的机会。</p><p>她小心翼翼地去解绑着手的布条，死结很难解，她只能一点一点的艰难挪动。</p><p>她心里很着急，但她强迫自己的动作更轻柔一些。</p><p>结慢慢、慢慢松开，母亲突然嘟囔了一句什么！</p><p>她全身都僵硬了！一动不敢动，假装自己熟睡着。但心脏跳动得如此剧烈，几乎提到了嗓子眼。</p><p>但母亲接下来并没有其他动作，那句话也听不清楚，只是一句梦呓。</p><p>她平复着心跳，缓慢地将布条解开。</p><p>一只手压着被子，不让寒意透进来，身体小心翼翼往床下挪。</p><p>终于，双脚落地。</p><p>地面冰凉刺骨，但她已经顾不得那么多。</p><p>时间紧迫！机会过了明天就不再有！</p><p>她甚至来不及去穿一双鞋子，去拿一件外套。</p><p>她踮着赤脚，做贼一般地挪出房间。</p><p>从父亲的床边蹑手蹑脚走过，掩耳盗铃般地不敢看他一眼。</p><p>来到堂屋，她轻轻抬起门栓，将大门缓缓拉开。</p><p>嘶~！</p><p>外面的寒风猛地灌了进来，将她整个人都浇凉。</p><p>但她却精神一振，把门拉开到仅容一人进出的空间，就赶紧侧身钻了出去。</p><p>她缓缓合上大门，仅着睡衣，赤足投入了漫天风雪中。</p><hr><p>这夜可真冷呵！</p><p>她冻得牙齿打颤，全身上下没一处不冷。</p><p>尤其踩在雪上的赤足，已经麻木得似乎没有了感觉。</p><p>但她只管捂着她的小腹，一脚深一脚浅地往前迈。</p><p>这是孩子。</p><p>这是我的孩子。</p><p>这是我和他的孩子！</p><p>她开始跑，用劲跑，使出全身力气的跑。</p><p>跑在这条那么熟悉的路上！跑在去他家的路上！</p><p>不到两公里的距离，她乌黑的头发上已经披满白雪。</p><p>她全身都快冻僵了，但总有一股子力气不知从哪里涌出来。</p><p>她终于站到了他家门前。</p><p>她敲门，用力敲门，大声喊他的名字。</p><p>房间里响起重物坠地的声音，继而是急促的脚步声，男人猛地撞出来，拉开房门！</p><p>他看到了怎样的一幅情景？</p><p>门外立着的，是面色苍白、瑟瑟发抖却灼灼与他对视的女子。</p><p>她的皮肤如雪，十里八乡没有哪个女子有这般白净。</p><p>她紧抿着已冻得乌青的唇，就那么俏生生立在雪中！</p><p>眼泪一下子就涌了出来，这是他以为将永远失去的她！</p><p>他一把将她从雪地里抱起，牢牢抱进怀里。</p><p>白茫茫的雪夜啊，风刀割不开的恋人。</p><p>这一夜。</p><p>有多少人见证了漫天风雪，就有多少人看到了白色婚纱。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;风暴戾地撞着窗，这个冬天格外冰冷。&lt;/p&gt;
&lt;p&gt;“你听话呀。”母亲的声音疲惫而心疼，“他家条件差得很，还有两个兄弟没成家。你跟过去吃没得吃、穿没得穿，只有受苦啊！”&lt;/p&gt;
&lt;p&gt;她和母亲并排躺在床上，抿着嘴唇并不出声，唯有泪珠成串滚落，很快浸湿枕巾。&lt;/p&gt;
&lt;p&gt;母亲侧着身，用右手柔柔帮她擦着泪，也有些哽咽：“妈妈都是为你好，你醒点事，好么？他平日里就会打架闹事，不是个有出息的人。”&lt;/p&gt;
&lt;p&gt;她吸了一下鼻子，眼睛执拗地闭着，无声哭泣。&lt;/p&gt;
&lt;p&gt;“明天去把孩子拿掉就好了。”母亲的声音在耳边继续着，她有她的苦心与疼爱，“时间久了你就不难过了，妈妈给你找个好婆家，保证比他强，过日子总归是要吃饱穿暖。”&lt;/p&gt;
&lt;p&gt;她抬了抬右手，没能抬动。&lt;/p&gt;
&lt;p&gt;母亲警觉地握紧了她的手。&lt;/p&gt;
&lt;p&gt;她的右手和母亲的左手紧紧绑在一起，布条还打了死结。&lt;/p&gt;
&lt;p&gt;“你们三兄妹里，妈妈最疼你，哪里能看着你吃苦。”母亲见止不住她的泪，自己的眼泪也落了下来，“你这个苕伢子……”&lt;/p&gt;
&lt;p&gt;母亲哭了一阵，帮她掖好被子，终于结束了劝慰，“很晚了，好好睡一觉，天亮妈妈就带你去医院。”&lt;/p&gt;</summary>
    
    
    
    <category term="睡前故事" scheme="http://plutowu.top/categories/%E7%9D%A1%E5%89%8D%E6%95%85%E4%BA%8B/"/>
    
    
    <category term="里世界" scheme="http://plutowu.top/tags/%E9%87%8C%E4%B8%96%E7%95%8C/"/>
    
    <category term="睡前故事" scheme="http://plutowu.top/tags/%E7%9D%A1%E5%89%8D%E6%95%85%E4%BA%8B/"/>
    
  </entry>
  
  <entry>
    <title>睡前故事-女巫</title>
    <link href="http://plutowu.top/2020/11/22/%E7%9D%A1%E5%89%8D%E6%95%85%E4%BA%8B-%E5%A5%B3%E5%B7%AB/"/>
    <id>http://plutowu.top/2020/11/22/%E7%9D%A1%E5%89%8D%E6%95%85%E4%BA%8B-%E5%A5%B3%E5%B7%AB/</id>
    <published>2020-11-22T15:42:28.000Z</published>
    <updated>2021-03-11T02:55:45.637Z</updated>
    
    <content type="html"><![CDATA[<p>“你知道吗，从遇见你的那天起，我心里，就种下了一个愿望……”</p><p>女巫瘫坐在地上，她仰起脸，怔怔地望着身前伤痕累累的男人，两行晶莹的泪水从脸颊滑落。</p><a id="more"></a><hr><p>十五年前。</p><p>女巫骑着扫帚在天上散心，远远地望见一道黑烟。</p><p>她飞到黑烟的源头察看，这里本来是一处村落，现在变成了一片废墟，四处都是断壁残垣，空气中弥漫着烧焦的木头与鲜血的混合气味。</p><p>她在废墟中翻找了很久，最终在一个大水缸下面发现一个幸存的小男孩。</p><p>女巫兴奋地把他抱了起来。</p><p>年仅五岁的小男孩在空中流着眼泪，瑟瑟发抖地问：“女……女巫阿姨，你会吃掉我吗？”</p><p>女巫皱了皱好看的柳叶眉，捏着他白皙的脸颊，说：“叫姐姐！”</p><p>这时，一群拿着锄头和镰刀的村民赶了过来。</p><p>他们远远地望见女巫抱着的小男孩。</p><p>人群顿时沸沸扬扬地呼喊了起来。</p><p>“快，抓住她！一定是那个女巫毁了这个村子！”</p><p>“我的上帝啊，谁能救救那个可怜的孩子！”</p><p>见村民们赶来，女巫连忙抱起小男孩，骑上扫帚飞走了。</p><hr><p>不久之后，女巫被冠以屠村的罪名，全国通缉。</p><p>对此，她毫不在乎，优哉游哉地在自己的魔法小屋里玩养成游戏，他每天教小男孩调配药剂，感应魔法。</p><p>只要他一偷懒，她的魔杖便会毫不留情地敲打他的脑袋。</p><p>只不过，每当女巫想要教训他的时候，他就用胖乎乎的小手捂着头顶，瞪着水汪汪的大眼睛可怜巴巴地望着她。</p><p>于是，女巫的处罚常常会半途而废。</p><p>这样的日子过得很快，转眼男孩就长大了。</p><p>他二十岁的时候，已经长得比女巫要高大得多，女巫踮起脚尖只能勉强碰到他的额头。</p><p>她再也不能随心所欲地敲打他的头顶了，每当她要处罚他的时候，他只要伸直胳膊按住女巫的头，她不管怎么挥舞魔杖也碰不到他。</p><p>女巫只好自己躲到书房，一边生闷气一边翻阅《男人的一百种烹饪方法》。</p><p>每当这时候，他都会做她最爱吃的蛋包饭，宠溺地看着她一边傲娇地说不好吃一边不停嘴地吃光一整盘蛋包饭。</p><hr><p>这天是采购日，他自己骑着扫帚出门采购食材，她待在家里百无聊赖地翻着书。</p><p>突然，一支燃烧的箭矢射了进来。</p><p>女巫黑色袍子上的防御法阵瞬间触发。</p><p>她挡住了箭，拿着法杖飘到了屋外。</p><p>那是一大群赏金猎人，其中不乏职业的女巫杀手。</p><p>“终于还是来了吗？”</p><p>他带着一堆食材返回的时候，家已经变成了一堆废墟，女巫拄着魔杖站在地上，她身上的法袍已经残破不堪，白皙的肌肤上，殷红的鲜血直流。</p><p>女巫抬头望见了他，他的眼中燃烧着怒火。</p><p>“滚开！小屁孩不要在这里碍事！”</p><p>女巫朝他吼道。</p><p>他缓缓走向了她，摸了摸她的头，说：“十五年了，我还不了解你嘛。”</p><p>他拿着魔杖，背对着她说：“你知道吗，从遇见你的那天起，我心里，就种下了一个愿望……”</p><p>话还没说完，无数的箭矢就朝着他射了过来，他的魔杖闪烁着光芒，站在他身前抵挡着一切攻击。</p><p>女巫瘫坐在地上，她仰起脸，怔怔地望着身前伤痕累累的男人，两行晶莹的泪水从脸颊滑落。</p><p>这场战斗不知道持续了多久，他的魔杖终于折断了，而对面还站着的赏金猎人也寥寥无几。</p><p>“再加把劲，只要把这个女巫的尸体带回去，咱们就有一辈子都花不完的赏金啦！”</p><p>话音刚落，一支箭矢就朝着女巫射了过去。</p><p>他飞身扑到了她的身前，紧紧地抱住了她，用背部挡住了那支箭。</p><p>这时，一个骑士骑着马飞奔了过来，他朝着赏金猎人们大喊着：“国王有令，屠村的罪魁祸首已经落网，是一群山贼，女巫无罪！女巫无罪！”</p><p>女巫流着泪摸着他渐渐失去血色的脸颊。</p><p>“为什么……为什么？”</p><p>他笑了笑，宠溺地摸了摸她的额头，说：“我种下的愿望是……保护你，一辈子。”</p><p>他撑着地面站起身来，背对着不知所措的人群，横着抱起女巫，缓缓地离开了。</p><p>女巫被他用公主抱的姿势抱在怀里，她说：“你的伤，没关系吗？”</p><p>他笑了笑，说：“没关系，一会把箭取出来，你给我用魔法治疗一下就好啦。”</p><p>“我……我们要去哪儿。”</p><p>“我们一起，去找一个新家。”</p><p>晚安</p><p>早安</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;“你知道吗，从遇见你的那天起，我心里，就种下了一个愿望……”&lt;/p&gt;
&lt;p&gt;女巫瘫坐在地上，她仰起脸，怔怔地望着身前伤痕累累的男人，两行晶莹的泪水从脸颊滑落。&lt;/p&gt;</summary>
    
    
    
    <category term="睡前故事" scheme="http://plutowu.top/categories/%E7%9D%A1%E5%89%8D%E6%95%85%E4%BA%8B/"/>
    
    
    <category term="里世界" scheme="http://plutowu.top/tags/%E9%87%8C%E4%B8%96%E7%95%8C/"/>
    
    <category term="睡前故事" scheme="http://plutowu.top/tags/%E7%9D%A1%E5%89%8D%E6%95%85%E4%BA%8B/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot-bug解决</title>
    <link href="http://plutowu.top/2020/11/21/SpringBoot-bug%E8%A7%A3%E5%86%B3/"/>
    <id>http://plutowu.top/2020/11/21/SpringBoot-bug%E8%A7%A3%E5%86%B3/</id>
    <published>2020-11-21T07:51:14.000Z</published>
    <updated>2021-03-09T15:27:33.021Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SpringBoot-BUG解决"><a href="#SpringBoot-BUG解决" class="headerlink" title="SpringBoot-BUG解决"></a>SpringBoot-BUG解决</h1><h2 id="1-跨域配置失效（SpringBoot版本问题）"><a href="#1-跨域配置失效（SpringBoot版本问题）" class="headerlink" title="1.跨域配置失效（SpringBoot版本问题）"></a>1.跨域配置失效（SpringBoot版本问题）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CrosConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addCorsMappings</span><span class="params">(CorsRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addMapping(<span class="string">&quot;/**&quot;</span>)</span><br><span class="line">                .allowedOrigins(<span class="string">&quot;*&quot;</span>)</span><br><span class="line">                .allowedMethods(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;HEAD&quot;</span>, <span class="string">&quot;POST&quot;</span>, <span class="string">&quot;PUT&quot;</span>, <span class="string">&quot;DELETE&quot;</span>, <span class="string">&quot;OPTIONS&quot;</span>)</span><br><span class="line">                .allowCredentials(<span class="keyword">true</span>)</span><br><span class="line">                .maxAge(<span class="number">3600</span>)</span><br><span class="line">                .allowedHeaders(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>采用SpringBoot 2.4.0版本下，配置跨域，报错</p><a id="more"></a><p><em>java.lang.IllegalArgumentException: When allowCredentials is true, allowedOrigins cannot contain the special value “＊”since that cannot be set on the “Access-Control-Allow-Origin” response header. To allow credentials to a set of origins, list them explicitly or consider using “allowedOriginPatterns” instead</em></p><p>错误为：当设置了<code>allowCredentials=true</code>的时候，服务器端响应的<code>Access-Control-Allow-Origin</code>头，它的值不能是<code>*</code>，必须要明确的指定出客户端的<code>origin</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.allowedOrigins(<span class="string">&quot;http://localhost&quot;</span>)</span><br></pre></td></tr></table></figure><p>指明具体客户端<code>origin</code>后，虽无报错，但浏览器访问仍然显示跨域失败。</p><p>==最终方法：将SpringBoot版本切换为2.2.x，成功解决==</p><p>…..尚未完结，持续更新</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;SpringBoot-BUG解决&quot;&gt;&lt;a href=&quot;#SpringBoot-BUG解决&quot; class=&quot;headerlink&quot; title=&quot;SpringBoot-BUG解决&quot;&gt;&lt;/a&gt;SpringBoot-BUG解决&lt;/h1&gt;&lt;h2 id=&quot;1-跨域配置失效（SpringBoot版本问题）&quot;&gt;&lt;a href=&quot;#1-跨域配置失效（SpringBoot版本问题）&quot; class=&quot;headerlink&quot; title=&quot;1.跨域配置失效（SpringBoot版本问题）&quot;&gt;&lt;/a&gt;1.跨域配置失效（SpringBoot版本问题）&lt;/h2&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@Configuration&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;CrosConfig&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;WebMvcConfigurer&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;addCorsMappings&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(CorsRegistry registry)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        registry.addMapping(&lt;span class=&quot;string&quot;&gt;&amp;quot;/**&amp;quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                .allowedOrigins(&lt;span class=&quot;string&quot;&gt;&amp;quot;*&amp;quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                .allowedMethods(&lt;span class=&quot;string&quot;&gt;&amp;quot;GET&amp;quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&amp;quot;HEAD&amp;quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&amp;quot;POST&amp;quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&amp;quot;PUT&amp;quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&amp;quot;DELETE&amp;quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&amp;quot;OPTIONS&amp;quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                .allowCredentials(&lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                .maxAge(&lt;span class=&quot;number&quot;&gt;3600&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                .allowedHeaders(&lt;span class=&quot;string&quot;&gt;&amp;quot;*&amp;quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;采用SpringBoot 2.4.0版本下，配置跨域，报错&lt;/p&gt;</summary>
    
    
    
    <category term="编程" scheme="http://plutowu.top/categories/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="Java Web" scheme="http://plutowu.top/categories/%E7%BC%96%E7%A8%8B/Java-Web/"/>
    
    
    <category term="笔记" scheme="http://plutowu.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Java Web" scheme="http://plutowu.top/tags/Java-Web/"/>
    
    <category term="Swagger" scheme="http://plutowu.top/tags/Swagger/"/>
    
  </entry>
  
  <entry>
    <title>vue-搭建vue+element ui项目</title>
    <link href="http://plutowu.top/2020/11/21/vue-%E6%90%AD%E5%BB%BAvue+element-ui%E9%A1%B9%E7%9B%AE/"/>
    <id>http://plutowu.top/2020/11/21/vue-%E6%90%AD%E5%BB%BAvue+element-ui%E9%A1%B9%E7%9B%AE/</id>
    <published>2020-11-21T01:38:15.000Z</published>
    <updated>2021-03-09T15:21:58.196Z</updated>
    
    <content type="html"><![CDATA[<h1 id="搭建Vue-Element-UI项目（通过Vue-UI）"><a href="#搭建Vue-Element-UI项目（通过Vue-UI）" class="headerlink" title="搭建Vue+Element-UI项目（通过Vue-UI）"></a>搭建Vue+Element-UI项目（通过Vue-UI）</h1><h2 id="1-启动命令行，进入Vue-UI"><a href="#1-启动命令行，进入Vue-UI" class="headerlink" title="1.启动命令行，进入Vue-UI"></a>1.启动命令行，进入Vue-UI</h2><p><img src="https://plutowu-blogimgs.oss-cn-guangzhou.aliyuncs.com/img/image-20201121094336554.png" alt="image-20201121094336554"></p><p>输入<a href="http://localhost:8000，即可进入UI界面">http://localhost:8000，即可进入UI界面</a></p><p><img src="https://plutowu-blogimgs.oss-cn-guangzhou.aliyuncs.com/img/image-20201121094647023.png" alt="image-20201121094647023"></p><a id="more"></a><h2 id="2-进入Vue项目管理器，新建项目"><a href="#2-进入Vue项目管理器，新建项目" class="headerlink" title="2.进入Vue项目管理器，新建项目"></a>2.进入Vue项目管理器，新建项目</h2><p>进入Vue项目管理器，进行新建或删除项目等操作</p><p><img src="https://plutowu-blogimgs.oss-cn-guangzhou.aliyuncs.com/img/image-20201121094734271.png" alt="image-20201121094734271"></p><p><img src="https://plutowu-blogimgs.oss-cn-guangzhou.aliyuncs.com/img/image-20201121094904195.png" alt="image-20201121094904195"></p><p>存在三种选项，管理现有项目、新建项目和导入项目，我们选择创建项目</p><p><img src="https://plutowu-blogimgs.oss-cn-guangzhou.aliyuncs.com/img/image-20201121095201637.png" alt="image-20201121095201637"></p><ul><li>创建新项目Step1-详情</li></ul><p><img src="https://plutowu-blogimgs.oss-cn-guangzhou.aliyuncs.com/img/image-20201121095418245.png" alt="image-20201121095418245"></p><ul><li>创建新项目Step2-预设</li></ul><p><img src="https://plutowu-blogimgs.oss-cn-guangzhou.aliyuncs.com/img/image-20201121095637943.png" alt="image-20201121095637943"></p><ul><li>创建新项目Step3-功能选择</li></ul><p><img src="https://plutowu-blogimgs.oss-cn-guangzhou.aliyuncs.com/img/image-20201121100002708.png" alt="image-20201121100002708"></p><ul><li>创建新项目Step4-配置</li></ul><p><img src="https://plutowu-blogimgs.oss-cn-guangzhou.aliyuncs.com/img/image-20201121100134876.png" alt="image-20201121100134876"></p><p>此时会询问是否创建为预设，可选择否或保留此预设，保留预设可免去重复配置</p><p><img src="https://plutowu-blogimgs.oss-cn-guangzhou.aliyuncs.com/img/image-20201121100207810.png" alt="image-20201121100207810"></p><h2 id="3-配置新项目"><a href="#3-配置新项目" class="headerlink" title="3.配置新项目"></a>3.配置新项目</h2><p><img src="https://plutowu-blogimgs.oss-cn-guangzhou.aliyuncs.com/img/image-20201121100350314.png" alt="image-20201121100350314"></p><p>进入项目管理器下，插件选项，安装所需插件</p><p>这里我们选择Element-ui与axios</p><p><img src="https://plutowu-blogimgs.oss-cn-guangzhou.aliyuncs.com/img/image-20201121100526996.png" alt="image-20201121100526996"></p><p><img src="https://plutowu-blogimgs.oss-cn-guangzhou.aliyuncs.com/img/image-20201121100551055.png" alt="image-20201121100551055"></p><p>均点击安装即可</p><p>安装完成，即完成项目搭建</p><h2 id="4-进入VS-Code查看成果"><a href="#4-进入VS-Code查看成果" class="headerlink" title="4.进入VS Code查看成果"></a>4.进入VS Code查看成果</h2><p><img src="https://plutowu-blogimgs.oss-cn-guangzhou.aliyuncs.com/img/image-20201121101030358.png" alt="image-20201121101030358"></p><p>开启NPM脚本-serve，开启热部署</p><p><img src="https://plutowu-blogimgs.oss-cn-guangzhou.aliyuncs.com/img/image-20201121101123455.png" alt="image-20201121101123455"></p><p>可进入相应端口，实时查看项目，编辑完项目后CTRL+S保存即可完成更新，NPM脚本会重新编译</p><p><img src="https://plutowu-blogimgs.oss-cn-guangzhou.aliyuncs.com/img/image-20201121101327645.png" alt="image-20201121101327645"></p><hr><p><strong>至此，Vue+Element项目搭建完成，接下来就可以开始你的渐进式开发了！</strong></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;搭建Vue-Element-UI项目（通过Vue-UI）&quot;&gt;&lt;a href=&quot;#搭建Vue-Element-UI项目（通过Vue-UI）&quot; class=&quot;headerlink&quot; title=&quot;搭建Vue+Element-UI项目（通过Vue-UI）&quot;&gt;&lt;/a&gt;搭建Vue+Element-UI项目（通过Vue-UI）&lt;/h1&gt;&lt;h2 id=&quot;1-启动命令行，进入Vue-UI&quot;&gt;&lt;a href=&quot;#1-启动命令行，进入Vue-UI&quot; class=&quot;headerlink&quot; title=&quot;1.启动命令行，进入Vue-UI&quot;&gt;&lt;/a&gt;1.启动命令行，进入Vue-UI&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://plutowu-blogimgs.oss-cn-guangzhou.aliyuncs.com/img/image-20201121094336554.png&quot; alt=&quot;image-20201121094336554&quot;&gt;&lt;/p&gt;
&lt;p&gt;输入&lt;a href=&quot;http://localhost:8000，即可进入UI界面&quot;&gt;http://localhost:8000，即可进入UI界面&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://plutowu-blogimgs.oss-cn-guangzhou.aliyuncs.com/img/image-20201121094647023.png&quot; alt=&quot;image-20201121094647023&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="编程" scheme="http://plutowu.top/categories/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="Vue" scheme="http://plutowu.top/categories/%E7%BC%96%E7%A8%8B/Vue/"/>
    
    <category term="Element UI" scheme="http://plutowu.top/categories/%E7%BC%96%E7%A8%8B/Vue/Element-UI/"/>
    
    
    <category term="Vue" scheme="http://plutowu.top/tags/Vue/"/>
    
    <category term="Element UI" scheme="http://plutowu.top/tags/Element-UI/"/>
    
  </entry>
  
  <entry>
    <title>睡前故事-放开那条恶龙</title>
    <link href="http://plutowu.top/2020/11/20/%E7%9D%A1%E5%89%8D%E6%95%85%E4%BA%8B-%E6%94%BE%E5%BC%80%E9%82%A3%E6%9D%A1%E6%81%B6%E9%BE%99/"/>
    <id>http://plutowu.top/2020/11/20/%E7%9D%A1%E5%89%8D%E6%95%85%E4%BA%8B-%E6%94%BE%E5%BC%80%E9%82%A3%E6%9D%A1%E6%81%B6%E9%BE%99/</id>
    <published>2020-11-20T15:28:19.000Z</published>
    <updated>2021-03-11T02:55:08.846Z</updated>
    
    <content type="html"><![CDATA[<p>龙宝宝有个梦想——抓一只……呸，抓一位公主。</p><p>为什么要抓公主呢？</p><p>因为龙族有一项特殊的成人礼——抓公主。</p><p>只有在王宫骑士重重包围之下抓走公主的龙，才能成为一条伟大的巨龙。</p><a id="more"></a><hr><p>为了实现自己的梦想，龙宝宝变身成一个俊美的少年，每天都背着一个小麻袋，拎着一根小木棍，在王城里瞎逛。</p><p>他的计划是：</p><p>遇见公主</p><p>打晕公主</p><p>装进麻袋</p><p>溜之大吉</p><p>一个月过去了，他始终没能见到公主。</p><p>渐渐的，他失去了瞎逛的动力。每天只是把袋子和棍子扔在一边，坐在墙角看着来往的路人，看看哪一个有可能是公主。</p><p>有时候一天下来，袋子里还能多几个铜币。</p><p>这天，他像往常一样坐在墙角。</p><p>迎面走过来一个牵着白马的少女。</p><p>“喂，小乞丐。”</p><p>“我不是小乞丐！”</p><p>他一下子站起来，瞪着少女说。</p><p>龙宝宝心想，要不是你长得还挺漂亮，我一口吃掉你，你信不信。</p><p>但就算你好看，也不能侮辱龙族的尊严！</p><p>“那你是什么？”</p><p>“我是龙……龙……”</p><p>他正支支吾吾不知道怎么隐瞒自己的身份，一支王国骑士巡逻队远远地朝这里走来。</p><p>“来不及了，小乞丐，把棍子给我！”</p><p>“哦，好。”</p><p>龙宝宝呆呆地把棍子递了过去。</p><p>“可能会很疼，你忍着点儿哈。”</p><p>“啊？为什……”</p><p>他的话还没说完，只觉得眼前一黑，失去了意识。</p><p>他再次睁开眼睛的时候，眼前一片漆黑。</p><p>他使劲扭动着身体，发现自己被绳子绑住了。</p><p>少女那清脆的嗓音从外面传来。</p><p>“小乞丐，你别乱动，我放你出来。”</p><p>说完，少女把他从麻袋里倒了出来。</p><p>他一边大口呼吸着新鲜空气，又一边观察着下四周，这是在城外的森林里，只有火堆，白马和少女。</p><p>少女坐在火堆旁，拍了拍他的肩膀，说：“实话跟你说吧，我是王国的公主，最近离家出走，缺个仆人，我观察你很久了，觉得你是个很好的人选。”</p><p>龙宝宝目瞪口呆地听着，少女自顾自地说着。</p><p>“我的计划就是接近你，打晕你，装进麻袋，然后溜之大吉。”</p><p>“你看，多么完美的计划，你还自带麻袋和木棍，简直太贴心了！”</p><p>龙宝宝心想，这计划似曾相识啊，等等，她说她是谁来着，公……公主？</p><p>我……我成功啦？</p><p>“话说，你为什么要离家出走呢？”</p><p>“我想成为一位伟大的战士，每一位伟大的战士都要经历一场特殊的成人礼。”</p><hr><p>“什么？”</p><p>“屠龙！”</p><p>“……”</p><p>于是，龙宝宝和公主踏上了“屠龙”的旅程。</p><p>公主似乎很虚弱，他们足足走了半个月，才走出了森林。</p><p>但是，在森林的边缘，他们终于还是遇到了王国骑士团。</p><p>骑士们不敢对公主动手，所有火力都迎向了公主身边的少年。</p><p>一番激战过后，少年被揍得伤痕累累，奄奄一息地倒在地上。</p><p>“住手！”</p><p>“你们别打了，我跟你们回去。”</p><p>公主伏在少年的耳边轻轻地说：“回家吧，龙宝宝，别再想着抓公主啦。”</p><p>少年的眼睛圆瞪着，难以置信地望向她。</p><p>公主回头，留给他一个含泪的微笑。</p><p>有人说成长是一个过程，但龙宝宝的成长，只是一个瞬间。</p><p>他站起身来，身上逐渐布满了黑色的鳞片，一对翅膀从背后钻了出来，瞬间就遮蔽了整片天空。</p><p>巨大的翅膀扇动起来，飓风席卷了整片森林。</p><p>只是一次呼吸的时间，黑影就笼罩了整个骑士团。</p><p>“把公主还给我！”</p><p>巨龙把公主带回了自己的洞穴，又变成了奄奄一息的少年。</p><p>“现在，你只要杀了我，就可以变成伟大的战士了。”</p><p>公主把剑抽了出来，刺向了少年。</p><p>少年缓缓闭上眼睛。</p><p>他听到剑摔落的声音，感到一丝丝热气喷在自己的耳朵上。</p><p>他睁开眼睛，公主倒在自己的身上。</p><p>“你是怎么发现我是龙的？”</p><p>“每一位屠龙战士，血脉里都隐藏着分辨龙的能力，只不过，当他们爱上一条龙的时候，便虚弱的再也挥不动剑了。”</p><p>他盯着她，说：“你知道吗，当我第一次看到你的时候，就已经想好孩子叫什么了。”</p><p>晚安</p><p>早安</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;龙宝宝有个梦想——抓一只……呸，抓一位公主。&lt;/p&gt;
&lt;p&gt;为什么要抓公主呢？&lt;/p&gt;
&lt;p&gt;因为龙族有一项特殊的成人礼——抓公主。&lt;/p&gt;
&lt;p&gt;只有在王宫骑士重重包围之下抓走公主的龙，才能成为一条伟大的巨龙。&lt;/p&gt;</summary>
    
    
    
    <category term="睡前故事" scheme="http://plutowu.top/categories/%E7%9D%A1%E5%89%8D%E6%95%85%E4%BA%8B/"/>
    
    
    <category term="里世界" scheme="http://plutowu.top/tags/%E9%87%8C%E4%B8%96%E7%95%8C/"/>
    
    <category term="睡前故事" scheme="http://plutowu.top/tags/%E7%9D%A1%E5%89%8D%E6%95%85%E4%BA%8B/"/>
    
  </entry>
  
  <entry>
    <title>睡前故事-喝酒</title>
    <link href="http://plutowu.top/2020/11/19/%E7%9D%A1%E5%89%8D%E6%95%85%E4%BA%8B-%E5%96%9D%E9%85%92/"/>
    <id>http://plutowu.top/2020/11/19/%E7%9D%A1%E5%89%8D%E6%95%85%E4%BA%8B-%E5%96%9D%E9%85%92/</id>
    <published>2020-11-19T13:07:58.000Z</published>
    <updated>2021-03-11T02:55:17.516Z</updated>
    
    <content type="html"><![CDATA[<p>山上有一只小狐狸。</p><p>她在山上修炼了一百年，终于化出了人形。</p><p>一出关，她就迫不及待地跑下了山。</p><p>“一百年啦，也不知道人间变成什么样了。”</p><a id="more"></a><hr><p>没走多远，她就嗅到一股香气，她仔细闻了闻，是酒香！</p><p>她擦了擦口水，摇身一变化成一个妙龄少女，又把尾巴往裙子里塞了塞。</p><p>她寻着酒香来到了山下的小镇上，小镇里车水马龙，远处的集市人声鼎沸。</p><p>她瞪着好奇宝宝一般的大眼睛，望着青石板的小路，络绎不绝的马车，以及，不远处的酒肆。</p><p>她一路小跑着来到了酒肆，叫道：“小二，来一碗酒！”</p><p>酒肆的小伙计瞅了瞅她，心里嘀咕道“大白天的一个人姑娘家出来喝酒，还真是少见。”想归想，他还是盛了一碗酒，送到小狐狸面前。</p><p>“客官，请慢用。”</p><p>小狐狸端起碗一饮而尽，这酒可真香啊！</p><p>她喝了一碗又一碗，直到喝得酩酊大醉，才满意地摸了摸小肚子，出了门。</p><p>自此，小狐狸天天下山喝酒，她的积蓄也越来越少。</p><p>她仔细琢磨了一下，再这样喝下去，钱肯定不够花，不如把小石子变成铜钱付账。可是，小石子的法术只能维持一会儿，用不了多久就会变回去，这样不就把酒肆给坑了？人家做个小本生意也不容易，左思右想，小狐狸决定在小镇上用法术行医赚钱，赚到的钱再用来买酒喝，嗯，就这么办！</p><hr><p>第二天，小狐狸就变成少女的模样，扛着一个“再世华佗”的小旗子，下了山。</p><p>她在小镇的集市上摆了个小摊子，生意就算是开张了。</p><p>一开始，小镇上的百姓还不相她，觉得这么年轻的姑娘，哪里会什么医术。没过多久，李家爷爷多年的老寒腿被她轻轻松松治好了，她的小摊子前立马排起了长队。</p><p>来找她看病的都是在医馆买不起药的穷人，小狐狸心软，不忍心收他们的钱。</p><p>天色晚了，小狐狸打起自己的小包袱收摊回家，她的小包袱里装得满满的，有宋家奶奶塞的馍馍，还有刘家爷爷送的萝卜，只是一个铜板都没有。</p><p>她挑着包袱路过酒肆，闻着酒香擦了擦口水，可她摸了摸自己的包袱，叹了口气，心想：“算了，起码今晚能吃顿饱饭。”</p><p>这样想着，她慢慢走开了。</p><p>这时，酒肆的小伙计追了出来。</p><p>望着她的背影喊道：“唉，姑娘留步，我请你喝酒！”</p><p>她的两个小耳朵立马树了起来，几乎飞一般地跑到小伙计面前，盯着他说：“你说什么？再说一遍！”</p><p>小伙计擦了擦汗，说：“我……我请你喝酒。”</p><p>“哈哈哈哈，原来这家酒馆就是你开的呀，看不出来啊，小掌柜！”</p><p>小狐狸一边抱着酒坛子，一边拍着小伙计的肩膀说。</p><p>小伙计腼腆地笑了笑，说：“你治好了那么多乡亲，都不要钱，请你喝点酒算什么！以后，你若是想喝酒，尽管来便是了。”</p><p>她的脸上布满了红晕，打着酒嗝说：“嘿嘿嘿，你可真……真是个好人！”</p><p>小伙计的脸红了红，讪讪地笑着，挠了挠头。</p><hr><p>夜深了，小狐狸喝得酩酊大醉，露出了原形，倒头便睡。</p><p>小伙计叹了口气，把她背在了身上，往山上走去。</p><p>风一吹，小狐狸毛绒绒的耳朵动了动，蹭的小伙计的脖子发痒，他说：“你醒啦。”</p><p>小狐狸的声音有些发颤，说：“你……你是什么时候发现的？”</p><p>他笑着说：“你每次来店里喝酒，喝醉了连尾巴都藏不住，你说呢？”</p><p>小狐狸哼唧着用小爪子在他背上锤了几下，说：“你……你……”</p><p>“好啦好啦，其实，小狐狸就挺可爱的。”</p><p>小狐狸的脸红了，她用蚊子一般的声音说：“那你觉得，我变成人，和变回小狐狸，哪个好看？”</p><p>小伙计笑了笑，毫不犹豫地回答：“都好看！”</p><p>小狐狸的脸红得发烫，她把脸埋进了小伙计的背上，用小爪子捂着，没过多久，又睡着了。</p><p>晚安</p><p>早安</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;山上有一只小狐狸。&lt;/p&gt;
&lt;p&gt;她在山上修炼了一百年，终于化出了人形。&lt;/p&gt;
&lt;p&gt;一出关，她就迫不及待地跑下了山。&lt;/p&gt;
&lt;p&gt;“一百年啦，也不知道人间变成什么样了。”&lt;/p&gt;</summary>
    
    
    
    <category term="睡前故事" scheme="http://plutowu.top/categories/%E7%9D%A1%E5%89%8D%E6%95%85%E4%BA%8B/"/>
    
    
    <category term="里世界" scheme="http://plutowu.top/tags/%E9%87%8C%E4%B8%96%E7%95%8C/"/>
    
    <category term="睡前故事" scheme="http://plutowu.top/tags/%E7%9D%A1%E5%89%8D%E6%95%85%E4%BA%8B/"/>
    
  </entry>
  
  <entry>
    <title>Swagger笔记</title>
    <link href="http://plutowu.top/2020/11/19/Swagger%E7%AC%94%E8%AE%B0/"/>
    <id>http://plutowu.top/2020/11/19/Swagger%E7%AC%94%E8%AE%B0/</id>
    <published>2020-11-19T10:46:43.000Z</published>
    <updated>2021-03-09T15:23:38.901Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Swagger"><a href="#Swagger" class="headerlink" title="Swagger"></a>Swagger</h1><ul><li>了解Swagger的概念及作用</li><li>了解前后端分离</li><li>在springboot中集成swagger</li></ul><h2 id="Swagger简介"><a href="#Swagger简介" class="headerlink" title="Swagger简介"></a>Swagger简介</h2><ul><li><h3 id="前言："><a href="#前言：" class="headerlink" title="前言："></a><strong>前言</strong>：</h3></li></ul><p>　　接口文档对于前后端开发人员都十分重要。尤其近几年流行前后端分离后接口文档又变成重中之重。接口文档固然重要，但是由于项 目周期等原因后端人员经常出现无法及时更新，导致前端人员抱怨接 口文档和实际情况不一致。</p><p>　　很多人员会抱怨别人写的接口文档不规范，不及时更新。当时当 自己写的时候确实最烦去写接口文档。这种痛苦只有亲身经历才会牢 记于心。</p><p>　　如果接口文档可以实时动态生成就不会出现上面问题。</p><p>　　<strong>Swagger</strong> 可以完美的解决上面的问题。</p><a id="more"></a><ul><li><h3 id="Open-API："><a href="#Open-API：" class="headerlink" title="Open API："></a><strong>Open API</strong>：</h3></li></ul><p>　　Open API 规范(OpenAPI Specification)以前叫做 Swagger 规范，是REST API 的 API 描述格式。</p><p>　　Open API 文件允许描述整个 API，包括：</p><p>　　　　· 每个访问地址的类型。POST 或 GET。</p><p>　　　　·每个操作的参数。包括输入输出参数。</p><p>　　　　·认证方法。</p><p>　　　　·连接信息，声明，使用团队和其他信息。</p><p>　　Open API 规范可以使用 YAML 或 JSON 格式进行编写。这样更利于我们和机器进行阅读。</p><p>　　OpenAPI 规范（OAS）为 RESTful API 定义了一个与语言无关的标 准接口，允许人和计算机发现和理解服务的功能，而无需访问源代码， 文档或通过网络流量检查。正确定义后，消费者可以使用最少量的实 现逻辑来理解远程服务并与之交互。然后，文档生成工具可以使用 OpenAPI 定义来显示 API，使用各 种编程语言生成服务器和客户端的代码生成工具，测试工具以及许多 其他用例。</p><ul><li><h3 id="Swagger-简介："><a href="#Swagger-简介：" class="headerlink" title="Swagger 简介："></a><strong>Swagger 简介</strong>：</h3></li></ul><p>　　Swagger 是一套围绕 Open API 规范构建的开源工具，可以帮助设 计，构建，记录和使用 REST API。</p><p>　　Swagger 工具包括的组件：</p><p>　　　　Swagger Editor  ：基于浏览器编辑器，可以在里面编写 Open API规范。类似 Markdown 具有实时预览描述文件的功能。</p><p>　　　　Swagger UI：将 Open API 规范呈现为交互式 API 文档。用可视化UI 展示描述文件。</p><p>　　　　Swagger Codegen：将 OpenAPI 规范生成为服务器存根和客户端 库。通过 Swagger Codegen 可以将描述文件生成 html 格式和 cwiki 形 式的接口文档，同时也可以生成多种言语的客户端和服务端代码。</p><p>　　　　Swagger Inspector：和 Swagger UI 有点类似，但是可以返回更多 信息，也会保存请求的实际参数数据。</p><p>　　　　Swagger Hub：集成了上面所有项目的各个功能，你可以以项目 和版本为单位，将你的描述文件上传到 Swagger Hub 中。在 Swagger Hub 中可以完成上面项目的所有工作，需要注册账号，分免费版和收费版。</p><p>　　　　使用 Swagger，就是把相关的信息存储在它定义的描述文件里面（yml 或 json 格式），再通过维护这个描述文件可以去更新接口文档， 以及生成各端代码。</p><ul><li><h3 id="官网：https-swagger-io"><a href="#官网：https-swagger-io" class="headerlink" title="官网：https://swagger.io/"></a>官网：<a href="https://swagger.io/">https://swagger.io/</a></h3></li></ul><h2 id="SpringBoot集成Swagger"><a href="#SpringBoot集成Swagger" class="headerlink" title="SpringBoot集成Swagger"></a>SpringBoot集成Swagger</h2><p><strong>SpringBoot集成Swagger</strong> =&gt; <strong>springfox</strong>，两个jar包</p><ul><li><strong><a href="https://mvnrepository.com/artifact/io.springfox/springfox-swagger2">Springfox-swagger2</a></strong></li><li><a href="https://mvnrepository.com/artifact/io.springfox/springfox-swagger-ui">springfox-swagger-ui</a></li></ul><p><strong>使用Swagger</strong></p><p>要求：jdk 1.8 + 否则swagger2无法运行</p><p>步骤：</p><ol><li><p>新建一个SpringBoot-web项目</p></li><li><p>添加Maven依赖（注意：2.9.2版本之前，之后的不行）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/io.springfox/springfox-swagger-ui --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- https://mvnrepository.com/artifact/io.springfox/springfox-swagger2 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>编写HelloController，测试Swagger</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ol><ol start="4"><li><p>在配置类编写SwaggerConfig，并配置注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableSwagger2</span>         <span class="comment">//开启Swagger2</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SwaggerConfig</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>访问<a href="http://localhost:8080/swagger-ui.html#%EF%BC%8C%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%88%B0Swagger-ui%E7%95%8C%E9%9D%A2">http://localhost:8080/swagger-ui.html#，可以看到Swagger-ui界面</a></p><p><img src="https://plutowu-blogimgs.oss-cn-guangzhou.aliyuncs.com/img/image-20201119192400412.png" alt="image-20201119192400412"></p></li></ol><h2 id="配置Swagger"><a href="#配置Swagger" class="headerlink" title="配置Swagger"></a>配置Swagger</h2><ol><li>Swagger通过Docekt的bean实例实现</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 配置了Swagger的Docket的bean实例</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Docket <span class="title">docket</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2)</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><p>配置Swagger信息可以通过——&gt;apiInfo    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//配置Swagger信息-&gt;apiInfo</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ApiInfo <span class="title">apiInfo</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        Contact contact = <span class="keyword">new</span> Contact(<span class="string">&quot;PlutoWu&quot;</span>, <span class="string">&quot;https://www.plutowu.top/&quot;</span>, <span class="string">&quot;p1utowu@qq.com&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ApiInfo(</span><br><span class="line">                <span class="string">&quot;Pluto的SwaggerAPI文档&quot;</span>,</span><br><span class="line">                <span class="string">&quot;PlutoWu Swagger&quot;</span>,</span><br><span class="line">                <span class="string">&quot;v1.0&quot;</span>,</span><br><span class="line">                <span class="string">&quot;https://www.plutowu.top/&quot;</span>,</span><br><span class="line">                contact,</span><br><span class="line">                <span class="string">&quot;Apache 2.0&quot;</span>,</span><br><span class="line">                <span class="string">&quot;http://www.apache.org/licenses/LICENSE-2.0&quot;</span>,</span><br><span class="line">                <span class="keyword">new</span> ArrayList());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>Docekt关联apiInfo以实现Swagger-UI页面的自主化</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Docket <span class="title">docket</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2)</span><br><span class="line">                .apiInfo(apiInfo());</span><br><span class="line">                &#125;</span><br></pre></td></tr></table></figure><ol start="4"><li><p>重新访问<a href="http://localhost:8080/swagger-ui.html#%EF%BC%8C%E5%A6%82%E4%B8%8B%E5%9B%BE%E6%89%80%E7%A4%BA">http://localhost:8080/swagger-ui.html#，如下图所示</a></p><p><img src="https://plutowu-blogimgs.oss-cn-guangzhou.aliyuncs.com/img/image-20201119185622792.png" alt="image-20201119185622792"></p></li></ol><h2 id="配置Swagger扫描接口"><a href="#配置Swagger扫描接口" class="headerlink" title="配置Swagger扫描接口"></a>配置Swagger扫描接口</h2><ol><li><p>通过设置Docket下的select()实现对扫描接口的配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Docket <span class="title">docket</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2)</span><br><span class="line">            .apiInfo(apiInfo())</span><br><span class="line">            .select()</span><br><span class="line">            <span class="comment">// RequestHandlerSelectors，配置要扫描接口的方式</span></span><br><span class="line">            <span class="comment">// basePackage指定要扫描的包</span></span><br><span class="line">            <span class="comment">// any()：扫描全部</span></span><br><span class="line">            <span class="comment">// none()：不扫描</span></span><br><span class="line">            <span class="comment">// withClassAnnotation：扫描类上的注解，参数是一个注解的反射对象</span></span><br><span class="line">            <span class="comment">// withMethodAnnotation：扫描方法上的注解</span></span><br><span class="line">            .apis(RequestHandlerSelectors.basePackage(<span class="string">&quot;com.pluto.swagger.controller&quot;</span>))</span><br><span class="line">            <span class="comment">// path()：过滤什么路径</span></span><br><span class="line">            <span class="comment">// .paths(PathSelectors.ant(&quot;/pluto/**&quot;))</span></span><br><span class="line">            .build();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li><p>现在只能扫描到controller包下的接口</p><p><img src="https://plutowu-blogimgs.oss-cn-guangzhou.aliyuncs.com/img/image-20201119193024261.png" alt="image-20201119193024261"></p></li><li><p>以下为可选的方式包括指定接口、包以及路径</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RequestHandlerSelectors，配置要扫描接口的方式</span></span><br><span class="line"><span class="comment">// basePackage指定要扫描的包</span></span><br><span class="line"><span class="comment">// any()：扫描全部</span></span><br><span class="line"><span class="comment">// none()：不扫描</span></span><br><span class="line"><span class="comment">// regex(final String pathRegex)：通过正则表达式控制</span></span><br><span class="line"><span class="comment">// ant(final String antPattern)：通过ant()控制</span></span><br><span class="line"><span class="comment">// withClassAnnotation：扫描类上的注解，参数是一个注解的反射对象</span></span><br><span class="line"><span class="comment">// withMethodAnnotation：扫描方法上的注解</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// path()：过滤什么路径</span></span><br><span class="line">.paths(PathSelectors.ant(<span class="string">&quot;/pluto/**&quot;</span>))</span><br></pre></td></tr></table></figure><h2 id="配置Swagger开关"><a href="#配置Swagger开关" class="headerlink" title="配置Swagger开关"></a>配置Swagger开关</h2><ol><li><p>在Docket下添加如下配置即可实现开关Swagger</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Docket <span class="title">docket</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2)</span><br><span class="line">            .apiInfo(apiInfo())</span><br><span class="line">            .enable(<span class="keyword">false</span>) <span class="comment">// 开关Swagger</span></span><br><span class="line">            .build();</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><p>置于false即可看到以下页面</p><p><img src="https://plutowu-blogimgs.oss-cn-guangzhou.aliyuncs.com/img/image-20201119193738092.png" alt="image-20201119193738092"></p></li><li><p>如何动态配置当项目处于test、dev环境时显示swagger，处于prod时不显示？</p><ul><li>判断是否为生产环境  flag = false</li></ul><ul><li>注入enable  (flag)</li></ul></li></ol><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 应用名称</span></span><br><span class="line"><span class="meta">spring.application.name</span>=<span class="string">swagger-demo</span></span><br><span class="line"><span class="comment"># 应用服务 WEB 访问端口</span></span><br><span class="line"><span class="meta">server.port</span>=<span class="string">8080</span></span><br><span class="line"><span class="meta">spring.profiles.active</span>=<span class="string">dev</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Docket <span class="title">docket</span><span class="params">(Environment environment)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置要显示的Swagger环境</span></span><br><span class="line">        Profiles profiles = Profiles.of(<span class="string">&quot;dev&quot;</span>,<span class="string">&quot;test&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过environment.acceptsProfiles判断自己是否处于自己设定的环境中</span></span><br><span class="line">        <span class="keyword">boolean</span> flag = environment.acceptsProfiles(profiles);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2)</span><br><span class="line">               .apiInfo(apiInfo())</span><br><span class="line">               .enable(<span class="keyword">true</span>)</span><br><span class="line">               .select()</span><br><span class="line">               .apis(RequestHandlerSelectors.basePackage(<span class="string">&quot;com.pluto.swagger.controller&quot;</span>))</span><br><span class="line">               .paths(PathSelectors.ant(<span class="string">&quot;/pluto/**&quot;</span>))</span><br><span class="line">               .build();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="https://plutowu-blogimgs.oss-cn-guangzhou.aliyuncs.com/img/image-20201119195647700.png" alt="image-20201119195647700"></p><p><strong>同理，配置文件更改环境为prod即可切换为发布版本，端口也要相应更改为8082。</strong></p><h2 id="配置API分组"><a href="#配置API分组" class="headerlink" title="配置API分组"></a>配置API分组</h2><ol><li>默认分组为default，可以通过groupName()方法进行配置分组</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2)</span><br><span class="line">                .apiInfo(apiInfo())</span><br><span class="line">                .groupName(<span class="string">&quot;Pluto&quot;</span>) <span class="comment">// 配置分组</span></span><br><span class="line">                .enable(<span class="keyword">true</span>)</span><br><span class="line">                .select()</span><br><span class="line">                ......</span><br></pre></td></tr></table></figure><ol start="2"><li>重启服务页面显示分组</li></ol><p><img src="https://plutowu-blogimgs.oss-cn-guangzhou.aliyuncs.com/img/image-20201119200703587.png" alt="image-20201119200703587"></p><ol start="3"><li>配置多个分组——配置多个Docket（别忘了@Bean注解，否则无法注册为实例）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Docket <span class="title">docket1</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2).groupName(<span class="string">&quot;YaYa&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Docket <span class="title">docket2</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2).groupName(<span class="string">&quot;XiaoGuo&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Docket <span class="title">docket3</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2).groupName(<span class="string">&quot;Lily&quot;</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>重启服务，页面可见多个分组</li></ol><p><img src="https://plutowu-blogimgs.oss-cn-guangzhou.aliyuncs.com/img/image-20201119201309428.png" alt="image-20201119201309428"></p><h2 id="实体配置"><a href="#实体配置" class="headerlink" title="实体配置"></a>实体配置</h2><ol><li>新建实体类</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ApiModel(&quot;用户实体类&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;用户名&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String username;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;密码&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String password;</span><br><span class="line">    </span><br><span class="line">    ......</span><br></pre></td></tr></table></figure><ol start="2"><li>配置Controller类，添加请求接口</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只要我们的接口中，返回值存在实体类，它就会被扫描到Swagger中</span></span><br><span class="line">    <span class="meta">@PostMapping(value = &quot;/user&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">user</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> User();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>重启服务，查看实体类被扫描</li></ol><p><img src="https://plutowu-blogimgs.oss-cn-guangzhou.aliyuncs.com/img/image-20201119202436940.png" alt="image-20201119202436940"></p><p><strong><em>注意：并非@ApiModel让实体类被扫描，而是只要出现在接口方法的返回值上的实体类都会被扫描到，@ApiModelProperty和@ApiModel只是为实体类添加注释所用。</em></strong></p><ul><li>@ApiModel为类添加注释</li><li>@ApiModelProperty为类具体属性添加注释</li></ul><h2 id="常用Swagger注解"><a href="#常用Swagger注解" class="headerlink" title="常用Swagger注解"></a>常用Swagger注解</h2><p>Swagger的所有注解定义在io.swagger.annotations包下</p><p>下面列一些经常用到的，未列举出来的可以另行查阅说明：</p><table><thead><tr><th align="center"><strong>Swagger注解</strong></th><th align="center"><strong>简单说明</strong></th></tr></thead><tbody><tr><td align="center">@Api(tags = “xxx模块说明”)</td><td align="center">作用在模块类上</td></tr><tr><td align="center">@ApiOperation(“xxx接口说明”)</td><td align="center">作用在接口方法上</td></tr><tr><td align="center">@ApiModel(“xxxPOJO说明”)</td><td align="center">作用在模型类上：如VO、BO</td></tr><tr><td align="center">@ApiModelProperty(value = “xxx属性说明”,hidden = true)</td><td align="center">作用在类方法和属性上，hidden设置为true可以隐藏该属性</td></tr><tr><td align="center">@ApiParam(“xxx参数说明”)</td><td align="center">作用在参数、方法和字段上，类似@ApiModelProperty</td></tr></tbody></table><h2 id="Swagger-GET-POST-测试功能"><a href="#Swagger-GET-POST-测试功能" class="headerlink" title="Swagger(GET/POST)测试功能"></a>Swagger(GET/POST)测试功能</h2><ol><li>Controller方法前添加==@ApiOeration==注释</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ApiOperation(&quot;Post测试类&quot;)</span></span><br><span class="line">    <span class="meta">@PostMapping(value = &quot;/post&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">post</span><span class="params">(<span class="meta">@ApiParam(&quot;用户名&quot;)</span> User user)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>重启服务进入Swagger-ui界面进行测试</li></ol><p><img src="https://plutowu-blogimgs.oss-cn-guangzhou.aliyuncs.com/img/image-20201119205520715.png" alt="image-20201119205520715"></p><p><img src="https://plutowu-blogimgs.oss-cn-guangzhou.aliyuncs.com/img/image-20201119205838266.png" alt="image-20201119205838266"></p><p><img src="https://plutowu-blogimgs.oss-cn-guangzhou.aliyuncs.com/img/image-20201119205659138.png" alt="image-20201119205659138"></p><p><strong>总结：</strong></p><ul><li>添加注释到一些较难理解的接口或属性，以便增加可读性</li><li>可在线测试</li><li>API实时更新</li></ul><p>==注意：在正式版本发布时，需关闭Swagger！！！==</p><ul><li>处于安全考虑</li><li>节省内存</li></ul><h2 id="拓展（Swagger皮肤切换）"><a href="#拓展（Swagger皮肤切换）" class="headerlink" title="拓展（Swagger皮肤切换）"></a>拓展（Swagger皮肤切换）</h2><ul><li>bootstrap-ui <strong>访问 <a href="http://localhost:8080/doc.html">http://localhost:8080/doc.html</a></strong>进入UI</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 引入swagger-bootstrap-ui包 /doc.html--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.xiaoymin<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>swagger-bootstrap-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://plutowu-blogimgs.oss-cn-guangzhou.aliyuncs.com/img/image-20201119210101794.png" alt="image-20201119210101794"></p><ul><li>mg-ui <strong>访问 <a href="http://localhost:8080/document.html">http://localhost:8080/document.html</a></strong>进入UI</li></ul><p><img src="https://plutowu-blogimgs.oss-cn-guangzhou.aliyuncs.com/img/image-20201119210351394.png" alt="image-20201119210351394"></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Swagger&quot;&gt;&lt;a href=&quot;#Swagger&quot; class=&quot;headerlink&quot; title=&quot;Swagger&quot;&gt;&lt;/a&gt;Swagger&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;了解Swagger的概念及作用&lt;/li&gt;
&lt;li&gt;了解前后端分离&lt;/li&gt;
&lt;li&gt;在springboot中集成swagger&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;Swagger简介&quot;&gt;&lt;a href=&quot;#Swagger简介&quot; class=&quot;headerlink&quot; title=&quot;Swagger简介&quot;&gt;&lt;/a&gt;Swagger简介&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;h3 id=&quot;前言：&quot;&gt;&lt;a href=&quot;#前言：&quot; class=&quot;headerlink&quot; title=&quot;前言：&quot;&gt;&lt;/a&gt;&lt;strong&gt;前言&lt;/strong&gt;：&lt;/h3&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;　　接口文档对于前后端开发人员都十分重要。尤其近几年流行前后端分离后接口文档又变成重中之重。接口文档固然重要，但是由于项 目周期等原因后端人员经常出现无法及时更新，导致前端人员抱怨接 口文档和实际情况不一致。&lt;/p&gt;
&lt;p&gt;　　很多人员会抱怨别人写的接口文档不规范，不及时更新。当时当 自己写的时候确实最烦去写接口文档。这种痛苦只有亲身经历才会牢 记于心。&lt;/p&gt;
&lt;p&gt;　　如果接口文档可以实时动态生成就不会出现上面问题。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;Swagger&lt;/strong&gt; 可以完美的解决上面的问题。&lt;/p&gt;</summary>
    
    
    
    <category term="编程" scheme="http://plutowu.top/categories/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="Java Web" scheme="http://plutowu.top/categories/%E7%BC%96%E7%A8%8B/Java-Web/"/>
    
    <category term="笔记" scheme="http://plutowu.top/categories/%E7%BC%96%E7%A8%8B/Java-Web/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="笔记" scheme="http://plutowu.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Java Web" scheme="http://plutowu.top/tags/Java-Web/"/>
    
    <category term="Swagger" scheme="http://plutowu.top/tags/Swagger/"/>
    
  </entry>
  
  <entry>
    <title>睡前故事-活了100万次的猫</title>
    <link href="http://plutowu.top/2020/11/18/%E7%9D%A1%E5%89%8D%E6%95%85%E4%BA%8B-%E6%B4%BB%E4%BA%86100%E4%B8%87%E6%AC%A1%E7%9A%84%E7%8C%AB/"/>
    <id>http://plutowu.top/2020/11/18/%E7%9D%A1%E5%89%8D%E6%95%85%E4%BA%8B-%E6%B4%BB%E4%BA%86100%E4%B8%87%E6%AC%A1%E7%9A%84%E7%8C%AB/</id>
    <published>2020-11-18T15:29:56.000Z</published>
    <updated>2021-03-11T02:55:26.856Z</updated>
    
    <content type="html"><![CDATA[<p>有一只100万年也不死的猫。</p><p>其实猫死了100万次，又活了100万次。</p><p>是一只漂亮的虎斑猫。 有100万个人宠爱过这只猫，有100万个人在这只猫死的时候哭过。</p><p>可是猫连一次也没有哭过。</p><a id="more"></a><hr><p>有一回，猫是国王的猫。</p><p>猫讨厌什么国王。</p><p>国王爱打仗，总是发动战争。而且，他还把猫用一个漂亮的篮子装起来，带到战场上。有一天，猫被一支飞来的箭射死了。</p><p>正打着仗，国王却抱着猫哭了起来。</p><p>国王仗也不打了，回到了王宫，然后，把猫埋到了王宫的院子里。</p><hr><p>有一回，猫是水手的猫。</p><p>猫讨厌什么水手。</p><p>水手带着猫走遍了全世界的大海和全世界的码头。</p><p>有一天，猫从船上掉了下来。</p><p>因为猫不会游泳，水手连忙用网子捞了上来，可猫还是淹死了。</p><p>水手抱着湿得像一块抹布似的猫，大声地哭起来。然后，把猫埋到了遥远的港口小镇的公园的树下。</p><hr><p>有一回，猫是马戏团魔术师的猫。</p><p>猫讨厌什么马戏团。</p><p>魔术师每天把猫装到一个箱子里，用锯子锯成两半儿，接着再把完好无损的猫从箱子里取出来，换来一片拍手声。</p><p>有一天，魔术师失手了，真的把猫锯成了两半儿。</p><p>魔术师两手拎着两半儿的猫，大声地哭起来。</p><p>这次，谁也没有拍手。</p><p>魔术师把猫埋到了马戏场的后面。</p><hr><p>有一回，猫是小偷的猫。</p><p>猫讨厌什么小偷。</p><p>小偷和猫一起，在漆黑的小镇上，像猫一样轻轻地转来转去。</p><p>小偷只偷养狗的人家。趁着狗冲猫叫的时候，小偷撬开保险箱。</p><p>一天，猫被狗给咬死了。</p><p>小偷抱着偷来的钻石和猫，在夜晚的小镇上一边大声地哭，一边走。然后，回到家里，把猫埋到了小小的院子里。</p><hr><p>有一回，猫是一个孤零零的老太太的猫。</p><p>猫讨厌什么老太太。</p><p>老太太每天抱着猫，从小窗户看着外面。</p><p>猫整天在老太太的腿上睡大觉。</p><p>不久，猫老死了。摇摇晃晃的老太太抱着摇摇晃晃的死了的猫，哭了一整天。</p><p>老太太把猫埋到了院子的树底下。</p><hr><p>有一回，猫是一个小女孩的猫。</p><p>猫讨厌什么小女孩。</p><p>小女孩有时把猫背在背上玩，有时紧紧抱着猫睡觉。她哭的时候，还会用猫的后背来擦眼泪。</p><p>有一天，猫被小女孩后背的带子给勒死了。</p><p>小女孩抱着耷拉着脑袋的猫，哭了一整天。然后，她把猫埋到了院子的树底下。</p><hr><p>猫已经不在乎死亡了。</p><p>有一回，猫不再是别人的猫了。</p><p>成了一只野猫。</p><p>猫头一次变成了自己的猫。</p><p>猫太喜欢自己了。</p><p>怎么说呢，漂亮的虎斑猫终于变成了漂亮的野猫。</p><p>不管是哪一只母猫，都想成为猫的新娘。</p><p>有的送条大鱼当礼物，有的献上新鲜的老鼠，有的送来了少见的木天蓼，还有的去舔猫那漂亮的虎斑纹。</p><p>可猫却说：</p><p>“我可死过100万次呢！我才不吃这一套！”</p><p>因为猫比谁都喜欢自己。</p><hr><p>只有一只猫连看也不看他一眼，是一只美丽的白猫。</p><p>猫走过去说：“我可死过100万次呢！”</p><p>“噢。”</p><p>白猫只说了这么一声。</p><p>猫有点生气了，怎么说呢，因为他太喜欢自己了。</p><p>第二天、第三天，猫都走到白猫的身边，说：“你还一次也没活完吧？”</p><p>“噢。”</p><p>白猫只说了这么一声。</p><p>有一天，猫在白猫面前一连翻了三个跟头，说：</p><p>“我呀，曾经是马戏团的猫呢。”</p><p>“噢。”</p><p>白猫只说了这么一声。</p><p>“我呀，我死过100万次……”</p><p>说到一半的时候，猫问白猫：“我可以待在你身边吗？”</p><p>“行呀。”</p><p>白猫说。</p><p>就这样，他一直待在了白猫的身边。</p><p>白猫生了好多可爱的小猫。</p><p>猫再也不说“我呀，我死过100万次……”了。</p><p>猫比喜欢自己还要喜欢白猫和小猫们。</p><p>小猫们很快就长大了，一个个走掉了。</p><p>“他们都成了漂亮的野猫啦。”</p><p>“是啊。”</p><p>白猫说，然后她的嗓子眼儿里发出了温柔的“咕噜咕噜”声。</p><p>白猫已经成了一个老奶奶了。</p><p>猫对白猫更温柔了，嗓子眼儿里也发出了“咕噜咕噜”声。</p><p>猫多想和白猫永远地一起活下去呀！</p><hr><p>有一天，白猫静静地躺倒在猫的怀里一动也不动了。</p><p>猫抱着白猫，流下了大滴大滴的眼泪，猫头一次哭了。从晚上哭到早上，又从早上哭到晚上。哭啊哭啊，猫哭了有100万次。</p><p>早上、晚上……一天中午，猫的哭声停止了。</p><p>猫也静静地、一动不动地躺在了白猫的身边。</p><p>猫再也没有起死回生过。</p><hr><p>“在天愿作比翼鸟，在地愿为连理枝。”在绘本的最后，画着一株并蒂双生的花。这便是最美丽的爱。一百万次生命的经历，使他深深懂得，爱，来之不易、幸福、得之不易。<br>猫在他第一百万零一次生命中，诠释了幸福的真谛，那便是真正的幸福！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;有一只100万年也不死的猫。&lt;/p&gt;
&lt;p&gt;其实猫死了100万次，又活了100万次。&lt;/p&gt;
&lt;p&gt;是一只漂亮的虎斑猫。 有100万个人宠爱过这只猫，有100万个人在这只猫死的时候哭过。&lt;/p&gt;
&lt;p&gt;可是猫连一次也没有哭过。&lt;/p&gt;</summary>
    
    
    
    <category term="睡前故事" scheme="http://plutowu.top/categories/%E7%9D%A1%E5%89%8D%E6%95%85%E4%BA%8B/"/>
    
    
    <category term="里世界" scheme="http://plutowu.top/tags/%E9%87%8C%E4%B8%96%E7%95%8C/"/>
    
    <category term="睡前故事" scheme="http://plutowu.top/tags/%E7%9D%A1%E5%89%8D%E6%95%85%E4%BA%8B/"/>
    
  </entry>
  
  <entry>
    <title>git clone加速问题解决方案</title>
    <link href="http://plutowu.top/2020/11/17/git-clone%E5%8A%A0%E9%80%9F%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>http://plutowu.top/2020/11/17/git-clone%E5%8A%A0%E9%80%9F%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</id>
    <published>2020-11-17T14:23:46.000Z</published>
    <updated>2021-03-11T04:09:05.164Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Git-Clone速度过慢解决方案"><a href="#Git-Clone速度过慢解决方案" class="headerlink" title="Git Clone速度过慢解决方案"></a>Git Clone速度过慢解决方案</h1><h1 id="1-方案一-使用gitclone-com加速"><a href="#1-方案一-使用gitclone-com加速" class="headerlink" title="1.方案一 使用gitclone.com加速"></a>1.方案一 使用gitclone.com加速</h1><p><strong><em>访问gitclone加速的官网<a href="https://gitclone.com,可以通过搜索栏搜索克隆项目/">https://gitclone.com，可以通过搜索栏搜索克隆项目</a></em></strong></p><p><img src="https://plutowu-blogimgs.oss-cn-guangzhou.aliyuncs.com/img/image-20201117222630897.png"></p><a id="more"></a><p><strong>其也提供了三种自定义加速方法（省去在GitClone搜索相应文件）</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">方法一（替换URL）</span><br><span class="line"></span><br><span class="line">git clone https://gitclone.com/github.com/tendermint/tendermint.git</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">方法二（设置git参数）</span><br><span class="line"></span><br><span class="line">git config --global url.&quot;https://gitclone.com/&quot;.insteadOf https://</span><br><span class="line">git clone https://github.com/tendermint/tendermint.git</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">方法三（使用cgit客户端）</span><br><span class="line"></span><br><span class="line">cgit clone https://github.com/tendermint/tendermint.git</span><br></pre></td></tr></table></figure><p><strong>搜索图例：</strong></p><p><img src="https://plutowu-blogimgs.oss-cn-guangzhou.aliyuncs.com/img/image-20201117223120221.png"></p><h1 id="2-方案二-使用Gitee转载仓库"><a href="#2-方案二-使用Gitee转载仓库" class="headerlink" title="2.方案二 使用Gitee转载仓库"></a>2.方案二 使用Gitee转载仓库</h1><h2 id="1-登录gitee-com"><a href="#1-登录gitee-com" class="headerlink" title="1.登录gitee.com"></a>1.登录gitee.com</h2><p><img src="https://plutowu-blogimgs.oss-cn-guangzhou.aliyuncs.com/img/Snipaste_2020-11-17_23-27-48.png"></p><h2 id="2-获取GitHub仓库URL"><a href="#2-获取GitHub仓库URL" class="headerlink" title="2.获取GitHub仓库URL"></a>2.获取GitHub仓库URL</h2><p><img src="https://plutowu-blogimgs.oss-cn-guangzhou.aliyuncs.com/img/Snipaste_2020-11-17_23-32-22.png"></p><h2 id="3-填写URL"><a href="#3-填写URL" class="headerlink" title="3.填写URL"></a>3.填写URL</h2><p><img src="https://plutowu-blogimgs.oss-cn-guangzhou.aliyuncs.com/img/Snipaste_2020-11-17_23-34-39.png"></p><h2 id="4-拉取仓库到Gitee完成"><a href="#4-拉取仓库到Gitee完成" class="headerlink" title="4.拉取仓库到Gitee完成"></a>4.拉取仓库到Gitee完成</h2><p><img src="https://plutowu-blogimgs.oss-cn-guangzhou.aliyuncs.com/img/Snipaste_2020-11-17_23-36-37.png"></p><h2 id="5-git-clone仓库"><a href="#5-git-clone仓库" class="headerlink" title="5.git clone仓库"></a>5.git clone仓库</h2><p><img src="https://plutowu-blogimgs.oss-cn-guangzhou.aliyuncs.com/img/Snipaste_2020-11-17_23-38-41.png"></p><hr><p><strong>总的来说，两种方法中gitclone.com会出现时常不稳定的现象，不过大部分时间都能够以高速克隆仓库。不到必要时刻，不推荐使用gitee二次搬运仓库，因为流程较为繁琐</strong></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Git-Clone速度过慢解决方案&quot;&gt;&lt;a href=&quot;#Git-Clone速度过慢解决方案&quot; class=&quot;headerlink&quot; title=&quot;Git Clone速度过慢解决方案&quot;&gt;&lt;/a&gt;Git Clone速度过慢解决方案&lt;/h1&gt;&lt;h1 id=&quot;1-方案一-使用gitclone-com加速&quot;&gt;&lt;a href=&quot;#1-方案一-使用gitclone-com加速&quot; class=&quot;headerlink&quot; title=&quot;1.方案一 使用gitclone.com加速&quot;&gt;&lt;/a&gt;1.方案一 使用gitclone.com加速&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;&lt;em&gt;访问gitclone加速的官网&lt;a href=&quot;https://gitclone.com,可以通过搜索栏搜索克隆项目/&quot;&gt;https://gitclone.com，可以通过搜索栏搜索克隆项目&lt;/a&gt;&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://plutowu-blogimgs.oss-cn-guangzhou.aliyuncs.com/img/image-20201117222630897.png&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="教程" scheme="http://plutowu.top/categories/%E6%95%99%E7%A8%8B/"/>
    
    <category term="Git" scheme="http://plutowu.top/categories/%E6%95%99%E7%A8%8B/Git/"/>
    
    
    <category term="Git" scheme="http://plutowu.top/tags/Git/"/>
    
    <category term="教程" scheme="http://plutowu.top/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Servlet实例总结</title>
    <link href="http://plutowu.top/2020/11/17/Servlet%E5%AE%9E%E4%BE%8B%E6%80%BB%E7%BB%93/"/>
    <id>http://plutowu.top/2020/11/17/Servlet%E5%AE%9E%E4%BE%8B%E6%80%BB%E7%BB%93/</id>
    <published>2020-11-17T04:02:55.000Z</published>
    <updated>2021-03-09T15:24:04.364Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Servlet实例总结-基于Java、SQLserver、Tomcat"><a href="#Servlet实例总结-基于Java、SQLserver、Tomcat" class="headerlink" title="Servlet实例总结-基于Java、SQLserver、Tomcat"></a>Servlet实例总结-基于Java、SQLserver、Tomcat</h1><h2 id="题目及要求"><a href="#题目及要求" class="headerlink" title="题目及要求:"></a>题目及要求:</h2><h3 id="使用Java-Bean-Servlet-Jsp实现下列目标"><a href="#使用Java-Bean-Servlet-Jsp实现下列目标" class="headerlink" title="使用Java Bean+Servlet+Jsp实现下列目标"></a><strong>使用Java Bean+Servlet+Jsp实现下列目标</strong></h3><ol><li>任务一：在数据库中建立表格T_BOOK(BID, BNAME, BAUTHER, BPRICE, BAMOUNT, BPUBDATE)，并向表中添加一些记录，T_BOOK数据表结构如下：</li></ol><p>表1-2 T_BOOK数据表</p><table><thead><tr><th>序号</th><th>列名</th><th>含义</th><th>类型</th><th>备注</th></tr></thead><tbody><tr><td>1</td><td>BID</td><td>书号</td><td>VARCHAR(20)</td><td>“B0001”</td></tr><tr><td>2</td><td>BNAME</td><td>书名</td><td>VARCHAR(50)</td><td></td></tr><tr><td>3</td><td>BAUTHER</td><td>作者</td><td>VARCHAR(50)</td><td></td></tr><tr><td>4</td><td>BTYPE</td><td>类型</td><td>VARCHAR(50)</td><td>计算机、文学</td></tr><tr><td>5</td><td>BPRICE</td><td>价格</td><td>INT</td><td></td></tr><tr><td>6</td><td>BAMOUNT</td><td>数量</td><td>INT</td><td></td></tr><tr><td>7</td><td>BPUBDATE</td><td>出版日期</td><td>DATE</td><td>2000-1-1</td></tr></tbody></table><ol start="2"><li><p>任务二：编写程序，在JSP页面中提供表单，用户可填写图书数据，向T_BOOK表中添加一条记录。</p></li><li><p>任务三：编写程序，在JSP页面提供按书名模糊查询功能，用户输入书名部分或全部内容，查询的结果显示在JSP页面上。</p></li><li><p>任务四：编写程序，在JSP页面中提供按价格区间查询功能，用户可填写两个价格，查询出两个价格之间的图书结果显示在JSP页面上。</p></li><li><p>任务五：编写程序，在JSP页面中提供按书号更新书籍数量功能，用户输入书号、数量，可更新数据表中的记录。</p></li></ol><a id="more"></a><hr><h3 id="实现"><a href="#实现" class="headerlink" title="实现:"></a>实现:</h3><h5 id="任务1：使用图形化建立数据库及建表，如下图："><a href="#任务1：使用图形化建立数据库及建表，如下图：" class="headerlink" title="任务1：使用图形化建立数据库及建表，如下图："></a>任务1：使用图形化建立数据库及建表，如下图：</h5><p><img src="https://img-blog.csdnimg.cn/20201117121051611.jpg#pic_center" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/20201117121051621.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzgyNDEzOQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20201117121051649.jpg#pic_center" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/20201117142430287.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzgyNDEzOQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><!-- more --><hr><h5 id="任务2：增加记录，使用post传值，设置简易窗口即可，注意SQL语句的正确。"><a href="#任务2：增加记录，使用post传值，设置简易窗口即可，注意SQL语句的正确。" class="headerlink" title="任务2：增加记录，使用post传值，设置简易窗口即可，注意SQL语句的正确。"></a>任务2：增加记录，使用post传值，设置简易窗口即可，注意SQL语句的正确。</h5><p><strong>代码如下：</strong></p><p>DbBean.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.etspace.abc.jdbc;</span><br><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DbBean</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> Statement stmt=<span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">private</span> Connection conn=<span class="keyword">null</span>;</span><br><span class="line">ResultSet rs=<span class="keyword">null</span>;</span><br><span class="line"><span class="comment">//构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DbBean</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"><span class="comment">//打开连接</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">openConnection</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">Class.forName(<span class="string">&quot;com.microsoft.sqlserver.jdbc.SQLServerDriver&quot;</span>).newInstance();</span><br><span class="line">String url=<span class="string">&quot;jdbc:sqlserver://localhost:1433;databaseName=book&quot;</span>;</span><br><span class="line">String user=<span class="string">&quot;sa&quot;</span>;</span><br><span class="line">String password=<span class="string">&quot;wsy0910&quot;</span>;</span><br><span class="line">conn=DriverManager.getConnection(url, user, password);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(ClassNotFoundException e)</span><br><span class="line">&#123;</span><br><span class="line">System.err.println(<span class="string">&quot;openConn:&quot;</span>+e.getMessage());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(SQLException e)</span><br><span class="line">&#123;</span><br><span class="line">System.err.println(<span class="string">&quot;openConn:&quot;</span>+e.getMessage());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//执行查询类的SQL语句</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ResultSet <span class="title">executeQuery</span><span class="params">(String sql)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">rs=<span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">stmt=conn.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE);</span><br><span class="line">rs=stmt.executeQuery(sql);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(SQLException e)</span><br><span class="line">&#123;</span><br><span class="line">System.err.println(<span class="string">&quot;executeQuery:&quot;</span>+e.getMessage());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> rs;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//执行更新类的SQL语句</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">executeUpdate</span><span class="params">(String sql)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">stmt=conn.createStatement();</span><br><span class="line">n=stmt.executeUpdate(sql);</span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)</span><br><span class="line">&#123;</span><br><span class="line">System.out.print(e.toString());</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//关闭连接</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">closeConnection</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (rs!=<span class="keyword">null</span>)</span><br><span class="line">rs.close();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(SQLException e)</span><br><span class="line">&#123;</span><br><span class="line">System.err.println(<span class="string">&quot;closeRs:&quot;</span>+e.getMessage());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (stmt!=<span class="keyword">null</span>)</span><br><span class="line">stmt.close();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(SQLException e)</span><br><span class="line">&#123;</span><br><span class="line">System.err.println(<span class="string">&quot;closeStmt:&quot;</span>+e.getMessage());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (conn!=<span class="keyword">null</span>)</span><br><span class="line">conn.close();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(SQLException e)</span><br><span class="line">&#123;</span><br><span class="line">System.err.println(<span class="string">&quot;closeConn:&quot;</span>+e.getMessage());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>tszjServlet.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.etspace.abc.servlet;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.etspace.abc.jdbc.DbBean;</span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;serial&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">tszjServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">doPost(request,response);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">request.setCharacterEncoding(<span class="string">&quot;gb2312&quot;</span>);</span><br><span class="line">response.setCharacterEncoding(<span class="string">&quot;gb2312&quot;</span>);</span><br><span class="line">response.setContentType(<span class="string">&quot;text/html;charset=gb2312&quot;</span>);</span><br><span class="line">PrintWriter out = response.getWriter();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">String BID =  request.getParameter(<span class="string">&quot;BID&quot;</span>);</span><br><span class="line">String BNAME =  request.getParameter(<span class="string">&quot;BNAME&quot;</span>);</span><br><span class="line">String BAUTHER =  request.getParameter(<span class="string">&quot;BAUTHER&quot;</span>);</span><br><span class="line">String BTYPE =  request.getParameter(<span class="string">&quot;BTYPE&quot;</span>);</span><br><span class="line">String BPRICE =  request.getParameter(<span class="string">&quot;BPRICE&quot;</span>);</span><br><span class="line">String BAMOUNT =  request.getParameter(<span class="string">&quot;BAMOUNT&quot;</span>);</span><br><span class="line">String BPUBDATE =  request.getParameter(<span class="string">&quot;BPUBDATE&quot;</span>);</span><br><span class="line">String sql = <span class="string">&quot;insert into T_BOOK(BID,BNAME,BAUTHER,BTYPE,BPRICE,BAMOUNT,BPUBDATE)&quot;</span>;</span><br><span class="line">sql=sql+<span class="string">&quot; values(&#x27;&quot;</span>+BID+<span class="string">&quot;&#x27;,&#x27;&quot;</span>+BNAME+<span class="string">&quot;&#x27;,&#x27;&quot;</span>+BAUTHER+<span class="string">&quot;&#x27;,&#x27;&quot;</span>+BTYPE+<span class="string">&quot;&#x27;,&#x27;&quot;</span>+BPRICE+<span class="string">&quot;&#x27;,&quot;</span>+BAMOUNT+<span class="string">&quot;,&#x27;&quot;</span>+BPUBDATE+<span class="string">&quot;&#x27;)&quot;</span>;</span><br><span class="line"><span class="comment">//out.print(sql);</span></span><br><span class="line">DbBean myDbBean=<span class="keyword">new</span> DbBean();</span><br><span class="line">myDbBean.openConnection();</span><br><span class="line">        <span class="keyword">int</span> n = myDbBean.executeUpdate(sql);</span><br><span class="line">        <span class="keyword">if</span> (n&gt;<span class="number">0</span>)&#123;</span><br><span class="line">       out.print(<span class="string">&quot;图书记录增加成功！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="keyword">else</span> &#123;</span><br><span class="line">       out.print(<span class="string">&quot;图书记录增加失败！&quot;</span>);</span><br><span class="line">       &#125; </span><br><span class="line">myDbBean.closeConnection();</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">out.print(e.toString());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>tszj.jsp</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=gb2312&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.sql.*&quot;</span>%&gt;</span><br><span class="line">&lt;jsp:useBean id=&quot;myDbBean&quot; scope=&quot;page&quot; class=&quot;org.etspace.abc.jdbc.DbBean&quot;&gt;&lt;/jsp:useBean&gt;</span><br><span class="line">&lt;%request.setCharacterEncoding(<span class="string">&quot;gb2312&quot;</span>); %&gt;</span><br><span class="line">&lt;script language=<span class="string">&quot;JavaScript&quot;</span>&gt;</span><br><span class="line"><span class="function">function <span class="title">check</span><span class="params">(theForm)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (theForm.BID.value.length != <span class="number">5</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    alert(<span class="string">&quot;书号必须为5位！&quot;</span>);</span><br><span class="line">    theForm.BID.focus();</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">false</span>);</span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="keyword">if</span> (theForm.BNAME.value == <span class="string">&quot;&quot;</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    alert(<span class="string">&quot;请输入书名！&quot;</span>);</span><br><span class="line">    theForm.BNAME.focus();</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (theForm.BPUBDATE.value == <span class="string">&quot;&quot;</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    alert(<span class="string">&quot;请输入出版日期！&quot;</span>);</span><br><span class="line">    theForm.BPUBDATE.focus();</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (theForm.BAMOUNT.value == <span class="string">&quot;&quot;</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    alert(<span class="string">&quot;请输入数量！&quot;</span>);</span><br><span class="line">    theForm.BAMOUNT.focus();</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (theForm.BPRICE.value == <span class="string">&quot;&quot;</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    alert(<span class="string">&quot;请输入价格！&quot;</span>);</span><br><span class="line">    theForm.BPRICE.focus();</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (theForm.BAUTHER.value == <span class="string">&quot;&quot;</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    alert(<span class="string">&quot;请输入作者！&quot;</span>);</span><br><span class="line">    theForm.BAUTHER.focus();</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (theForm.BTYPE.value == <span class="string">&quot;&quot;</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    alert(<span class="string">&quot;请输入类型！&quot;</span>);</span><br><span class="line">    theForm.BTYPE.focus();</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">false</span>);</span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;&lt;title&gt;图书增加&lt;/title&gt;&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div align=<span class="string">&quot;center&quot;</span>&gt;</span><br><span class="line">  &lt;P&gt;图书增加&lt;/P&gt;</span><br><span class="line">&lt;form id=<span class="string">&quot;form1&quot;</span> name=<span class="string">&quot;form1&quot;</span> method=<span class="string">&quot;post&quot;</span> action=<span class="string">&quot;tszjServlet&quot;</span> onSubmit=<span class="string">&quot;return check(this)&quot;</span>&gt;</span><br><span class="line">&lt;table border=<span class="string">&quot;1&quot;</span>&gt;</span><br><span class="line">&lt;tr&gt;&lt;td&gt;书号&lt;/td&gt;&lt;td&gt;&lt;input name=&quot;BID&quot; type=&quot;text&quot; id=&quot;BID&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;</span><br><span class="line">&lt;tr&gt;&lt;td&gt;书名&lt;/td&gt;&lt;td&gt;&lt;input name=&quot;BNAME&quot; type=&quot;text&quot; id=&quot;BNAME&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;</span><br><span class="line">&lt;tr&gt;&lt;td&gt;作者&lt;/td&gt;&lt;td&gt;&lt;input name=&quot;BAUTHER&quot; type=&quot;text&quot; id=&quot;BAUTHER&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;</span><br><span class="line">&lt;tr&gt;&lt;td&gt;类型&lt;/td&gt;&lt;td&gt;</span><br><span class="line">&lt;input type=<span class="string">&quot;radio&quot;</span> name=<span class="string">&quot;BTYPE&quot;</span> value=<span class="string">&quot;计算机&quot;</span> checked=<span class="string">&quot;checked&quot;</span> /&gt;计算机 </span><br><span class="line">&lt;input type=<span class="string">&quot;radio&quot;</span> name=<span class="string">&quot;BTYPE&quot;</span> value=<span class="string">&quot;文学&quot;</span> /&gt;文学 </span><br><span class="line">&lt;/td&gt;&lt;/tr&gt;</span><br><span class="line">&lt;%</span><br><span class="line">String sql = <span class="string">&quot;select * from BID order by T_BOOK&quot;</span>;</span><br><span class="line">myDbBean.openConnection();</span><br><span class="line">ResultSet rs=myDbBean.executeQuery(sql);</span><br><span class="line">%&gt;</span><br><span class="line">&lt;/td&gt;&lt;/tr&gt;</span><br><span class="line">&lt;tr&gt;&lt;td&gt;价格&lt;/td&gt;&lt;td&gt;&lt;input name=&quot;BPRICE&quot; type=&quot;text&quot; id=&quot;BPRICE&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;</span><br><span class="line">&lt;tr&gt;&lt;td&gt;数量&lt;/td&gt;&lt;td&gt;&lt;input name=&quot;BAMOUNT&quot; type=&quot;text&quot; id=&quot;BAMOUNT&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;</span><br><span class="line">&lt;tr&gt;&lt;td&gt;出版日期&lt;/td&gt;&lt;td&gt;&lt;input name=&quot;BPUBDATE&quot; type=&quot;text&quot; id=&quot;BPUBDATE&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;</span><br><span class="line">&lt;/table&gt;</span><br><span class="line">&lt;br&gt;</span><br><span class="line">  &lt;input name=<span class="string">&quot;submit&quot;</span> type=<span class="string">&quot;submit&quot;</span>  value=<span class="string">&quot;确定&quot;</span> /&gt;</span><br><span class="line">  &lt;input name=<span class="string">&quot;reset&quot;</span> type=<span class="string">&quot;reset&quot;</span> value=<span class="string">&quot;重置&quot;</span> /&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p><strong>截图如下：</strong></p><p><img src="https://img-blog.csdnimg.cn/20201117121051785.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzgyNDEzOQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20201117121051789.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzgyNDEzOQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><hr><h5 id="任务3：模糊查询，设置一个实体类Book，注意SQL语句的准确即可，此题我用直接输出，可用List列表进行输出。"><a href="#任务3：模糊查询，设置一个实体类Book，注意SQL语句的准确即可，此题我用直接输出，可用List列表进行输出。" class="headerlink" title="任务3：模糊查询，设置一个实体类Book，注意SQL语句的准确即可，此题我用直接输出，可用List列表进行输出。"></a>任务3：模糊查询，设置一个实体类Book，注意SQL语句的准确即可，此题我用直接输出，可用List列表进行输出。</h5><p><strong>代码如下：</strong></p><p>Book.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.etspace.abc.bean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Book</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String BID;</span><br><span class="line"><span class="keyword">public</span> String BNAME;</span><br><span class="line"><span class="keyword">public</span> String BAUTHER;</span><br><span class="line"><span class="keyword">public</span> String BTYPE;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> BPRICE;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> BAMOUNT;</span><br><span class="line"><span class="keyword">public</span> String BPUBDATE;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getBID</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> BID;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBID</span><span class="params">(String BID)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.BID = BID;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getBNAME</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> BNAME;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBNAME</span><span class="params">(String BNAME)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.BNAME = BNAME;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getBAUTHER</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> BAUTHER;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBAUTHER</span><span class="params">(String BAUTHER)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.BAUTHER = BAUTHER;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getBTYPE</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> BTYPE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBTYPE</span><span class="params">(String BTYPE)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.BTYPE = BTYPE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getBPRICE</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> BPRICE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBPRICE</span><span class="params">(<span class="keyword">int</span> BPRICE)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.BPRICE = BPRICE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getBAMOUNT</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> BAMOUNT;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBAMOUNT</span><span class="params">(<span class="keyword">int</span> BAMOUNT)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.BAMOUNT = BAMOUNT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getBPUBDATE</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> BPUBDATE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBPUBDATE</span><span class="params">(String BPUBDATE)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.BPUBDATE = BPUBDATE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mhcxServlet.java</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">package org.etspace.abc.servlet;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.PrintWriter;</span><br><span class="line">import java.sql.ResultSet;</span><br><span class="line"></span><br><span class="line">import javax.servlet.ServletException;</span><br><span class="line">import javax.servlet.annotation.WebServlet;</span><br><span class="line">import javax.servlet.http.HttpServlet;</span><br><span class="line">import javax.servlet.http.HttpServletRequest;</span><br><span class="line">import javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line">import org.etspace.abc.jdbc.DbBean;</span><br><span class="line">@<span class="constructor">WebServlet(<span class="string">&quot;/mhcxServlet&quot;</span>)</span></span><br><span class="line">@<span class="constructor">SuppressWarnings(<span class="string">&quot;serial&quot;</span>)</span></span><br><span class="line">public <span class="keyword">class</span> mhcxServlet extends HttpServlet &#123;</span><br><span class="line">public void <span class="keyword">do</span><span class="constructor">Get(HttpServletRequest <span class="params">request</span>, HttpServletResponse <span class="params">response</span>)</span></span><br><span class="line">throws ServletException, IOException &#123;</span><br><span class="line"><span class="keyword">do</span><span class="constructor">Post(<span class="params">request</span>,<span class="params">response</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line">public void <span class="keyword">do</span><span class="constructor">Post(HttpServletRequest <span class="params">request</span>, HttpServletResponse <span class="params">response</span>)</span></span><br><span class="line">throws ServletException, IOException &#123;</span><br><span class="line">request.set<span class="constructor">CharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>)</span>;</span><br><span class="line">response.set<span class="constructor">CharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>)</span>;</span><br><span class="line">response.set<span class="constructor">ContentType(<span class="string">&quot;text/html;charset=UTF-8&quot;</span>)</span>;</span><br><span class="line">PrintWriter out = response.get<span class="constructor">Writer()</span>;</span><br><span class="line"></span><br><span class="line">String input = request.get<span class="constructor">Parameter(<span class="string">&quot;input&quot;</span>)</span>;</span><br><span class="line">String sql = <span class="string">&quot;select * from T_BOOK where BNAME like &#x27;%&quot;</span>+input+<span class="string">&quot;%&#x27;&quot;</span>;</span><br><span class="line"><span class="comment">//like实现模糊查询</span></span><br><span class="line">DbBean myDbBean=<span class="keyword">new</span> <span class="constructor">DbBean()</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">myDbBean.<span class="keyword">open</span><span class="constructor">Connection()</span>;</span><br><span class="line">&#125; catch (Exception e1) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e1.print<span class="constructor">StackTrace()</span>;</span><br><span class="line">&#125;</span><br><span class="line">        ResultSet rs = myDbBean.execute<span class="constructor">Query(<span class="params">sql</span>)</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;    </span><br><span class="line">        <span class="keyword">while</span>(rs.next<span class="literal">()</span>)&#123;</span><br><span class="line">        out.println(</span><br><span class="line">        <span class="string">&quot;&lt;font color=\&#x27;blue\&#x27; size=\&#x27;2\&#x27; face=\&#x27;Arial\&#x27; &gt;&quot;</span></span><br><span class="line">        + <span class="string">&quot;书号：&quot;</span>+rs.get<span class="constructor">String(<span class="string">&quot;BID&quot;</span>)</span>+</span><br><span class="line">        <span class="string">&quot;  书名：&quot;</span>+rs.get<span class="constructor">String(<span class="string">&quot;BNAME&quot;</span>)</span>+</span><br><span class="line">        <span class="string">&quot;  作者：&quot;</span>+rs.get<span class="constructor">String(<span class="string">&quot;BAUTHER&quot;</span>)</span>+</span><br><span class="line">        <span class="string">&quot;  类型：&quot;</span>+rs.get<span class="constructor">String(<span class="string">&quot;BTYPE&quot;</span>)</span>+</span><br><span class="line">        <span class="string">&quot;  价格：&quot;</span>+rs.get<span class="constructor">String(<span class="string">&quot;BPRICE&quot;</span>)</span>+</span><br><span class="line">        <span class="string">&quot;  数量：&quot;</span>+rs.get<span class="constructor">String(<span class="string">&quot;BAMOUNT&quot;</span>)</span>+</span><br><span class="line">        <span class="string">&quot;  出版日期：&quot;</span>+rs.get<span class="constructor">String(<span class="string">&quot;BPUBDATE&quot;</span>)</span></span><br><span class="line">        );<span class="comment">//直接打印，并修改字体大小颜色，使适应界面</span></span><br><span class="line">        out.println(<span class="string">&quot;&lt;br&gt;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        rs.close<span class="literal">()</span>;</span><br><span class="line">myDbBean.close<span class="constructor">Connection()</span>;</span><br><span class="line">&#125; </span><br><span class="line">catch (Exception e) &#123;</span><br><span class="line">out.print(e.<span class="keyword">to</span><span class="constructor">String()</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mhcx.jsp</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page language=<span class="string">&quot;java&quot;</span> contentType=<span class="string">&quot;text/html; charset=UTF-8&quot;</span></span><br><span class="line">    pageEncoding=<span class="string">&quot;UTF-8&quot;</span>%&gt;</span><br><span class="line">&lt;!DOCTYPE html PUBLIC <span class="string">&quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;</span> <span class="string">&quot;http://www.w3.org/TR/html4/loose.dtd&quot;</span>&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta http-equiv=<span class="string">&quot;Content-Type&quot;</span> content=<span class="string">&quot;text/html; charset=UTF-8&quot;</span>&gt;</span><br><span class="line">&lt;title&gt;模糊查询&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div align=<span class="string">&quot;center&quot;</span>&gt;</span><br><span class="line">&lt;p&gt;模糊查询&lt;/p&gt;</span><br><span class="line">&lt;form action=<span class="string">&quot;mhcxServlet&quot;</span> method=<span class="string">&quot;post&quot;</span>&gt;</span><br><span class="line">&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;input&quot;</span>/&gt;&lt;br&gt;</span><br><span class="line">&lt;input type=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;确定&quot;</span>/&gt;</span><br><span class="line">&lt;input type=<span class="string">&quot;reset&quot;</span> value=<span class="string">&quot;重置&quot;</span>/&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p><strong>截图如下：</strong></p><p><img src="https://img-blog.csdnimg.cn/20201117121051749.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzgyNDEzOQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><hr><h5 id="任务4：区间查找，设置了一个success的jsp进行跳转输出列表，请注意SQL代码的正确与初始化列表的先后顺序。"><a href="#任务4：区间查找，设置了一个success的jsp进行跳转输出列表，请注意SQL代码的正确与初始化列表的先后顺序。" class="headerlink" title="任务4：区间查找，设置了一个success的jsp进行跳转输出列表，请注意SQL代码的正确与初始化列表的先后顺序。"></a>任务4：区间查找，设置了一个success的jsp进行跳转输出列表，请注意SQL代码的正确与初始化列表的先后顺序。</h5><p><strong>代码如下：</strong></p><p>jgcxServlet,java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.etspace.abc.servlet;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="keyword">import</span> java.sql.ResultSet;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.etspace.abc.bean.Book;</span><br><span class="line"><span class="keyword">import</span> org.etspace.abc.jdbc.DbBean;</span><br><span class="line"><span class="meta">@WebServlet(&quot;/jgcxServlet&quot;)</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;serial&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">jgcxServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">doPost(request,response);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">request.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">response.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">response.setContentType(<span class="string">&quot;text/html;charset=UTF-8&quot;</span>);</span><br><span class="line">PrintWriter out = response.getWriter();</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Low = Integer.parseInt(request.getParameter(<span class="string">&quot;LowPrice&quot;</span>));</span><br><span class="line"><span class="keyword">int</span> High = Integer.parseInt(request.getParameter(<span class="string">&quot;HighPrice&quot;</span>));</span><br><span class="line"></span><br><span class="line">String sql = <span class="string">&quot;select * from T_BOOK where BPRICE between &quot;</span>+Low+<span class="string">&quot; and &quot;</span>+High;</span><br><span class="line"><span class="comment">//between实现区间查询</span></span><br><span class="line">DbBean myDbBean=<span class="keyword">new</span> DbBean();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">myDbBean.openConnection();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e1) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e1.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">        ResultSet rs = myDbBean.executeQuery(sql);</span><br><span class="line">        List&lt;Book&gt; BookList = <span class="keyword">new</span> ArrayList&lt;Book&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span> &#123;    </span><br><span class="line">        <span class="keyword">while</span>(rs.next())&#123;</span><br><span class="line">        Book book = <span class="keyword">new</span> Book();</span><br><span class="line">        book.setBID(rs.getString(<span class="string">&quot;BID&quot;</span>));</span><br><span class="line">        book.setBNAME(rs.getString(<span class="string">&quot;BNAME&quot;</span>));</span><br><span class="line">        book.setBAUTHER(rs.getString(<span class="string">&quot;BAUTHER&quot;</span>));</span><br><span class="line">        book.setBTYPE(rs.getString(<span class="string">&quot;BTYPE&quot;</span>));</span><br><span class="line">        book.setBPRICE(rs.getInt(<span class="string">&quot;BPRICE&quot;</span>));</span><br><span class="line">        book.setBAMOUNT(rs.getInt(<span class="string">&quot;BAMOUNT&quot;</span>));</span><br><span class="line">        book.setBPUBDATE(rs.getString(<span class="string">&quot;BPUBDATE&quot;</span>));</span><br><span class="line">        BookList.add(book);</span><br><span class="line">        &#125;</span><br><span class="line">        request.setAttribute(<span class="string">&quot;BookList&quot;</span>, BookList);</span><br><span class="line">        rs.close();</span><br><span class="line">myDbBean.closeConnection();</span><br><span class="line">request.getRequestDispatcher(<span class="string">&quot;/jgcxSuccess.jsp&quot;</span>).forward(request, response);</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">out.print(e.toString());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>jgcx.jsp</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page language=<span class="string">&quot;java&quot;</span> contentType=<span class="string">&quot;text/html; charset=UTF-8&quot;</span></span><br><span class="line">    pageEncoding=<span class="string">&quot;UTF-8&quot;</span>%&gt;</span><br><span class="line">&lt;!DOCTYPE html PUBLIC <span class="string">&quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;</span> <span class="string">&quot;http://www.w3.org/TR/html4/loose.dtd&quot;</span>&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta http-equiv=<span class="string">&quot;Content-Type&quot;</span> content=<span class="string">&quot;text/html; charset=UTF-8&quot;</span>&gt;</span><br><span class="line">&lt;title&gt;价格区间查询&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div align=<span class="string">&quot;center&quot;</span>&gt;</span><br><span class="line">&lt;p&gt;价格区间查询&lt;/p&gt;</span><br><span class="line">&lt;form action=<span class="string">&quot;jgcxServlet&quot;</span> method=<span class="string">&quot;post&quot;</span>&gt;</span><br><span class="line">请输入您要查询图书的价格:</span><br><span class="line">&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;LowPrice&quot;</span>/&gt;-</span><br><span class="line">&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;HighPrice&quot;</span>/&gt;&lt;br&gt;</span><br><span class="line">&lt;input type=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;确定&quot;</span>/&gt;</span><br><span class="line">&lt;input type=<span class="string">&quot;reset&quot;</span> value=<span class="string">&quot;重置&quot;</span>/&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>jgcxSuccess.jsp</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page language=<span class="string">&quot;java&quot;</span> <span class="keyword">import</span>=<span class="string">&quot;java.util.*&quot;</span> pageEncoding=<span class="string">&quot;utf-8&quot;</span>%&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span> = <span class="string">&quot;java.io.IOException&quot;</span>%&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span> = <span class="string">&quot;java.io.PrintWriter&quot;</span>%&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span> = <span class="string">&quot;java.util.ArrayList&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span> = <span class="string">&quot;org.etspace.abc.bean.Book&quot;</span> %&gt;</span><br><span class="line">&lt;%<span class="meta">@page</span> <span class="keyword">import</span>=<span class="string">&quot;java.sql.*&quot;</span> %&gt;</span><br><span class="line">&lt;!DOCTYPE html PUBLIC <span class="string">&quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;</span> <span class="string">&quot;http://www.w3.org/TR/html4/loose.dtd&quot;</span>&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta http-equiv=<span class="string">&quot;Content-Type&quot;</span> content=<span class="string">&quot;text/html; charset=ISO-8859-1&quot;</span>&gt;</span><br><span class="line">&lt;title&gt;查询结果&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;% ArrayList BookList = (ArrayList)request.getAttribute(<span class="string">&quot;BookList&quot;</span>);</span><br><span class="line"> </span><br><span class="line"> %&gt;</span><br><span class="line"></span><br><span class="line">&lt;div align=<span class="string">&quot;center&quot;</span>&gt;</span><br><span class="line">&lt;h2&gt;查询结果&lt;/h2&gt;</span><br><span class="line">&lt;table align=<span class="string">&quot;center&quot;</span> border = <span class="string">&#x27;1&#x27;</span>&gt;</span><br><span class="line">        &lt;tr&gt;</span><br><span class="line">            &lt;th&gt;书号&lt;/th&gt;</span><br><span class="line">            &lt;th&gt;书名&lt;/th&gt;</span><br><span class="line">            &lt;th&gt;作者&lt;/th&gt;</span><br><span class="line">            &lt;th&gt;类型&lt;/th&gt;</span><br><span class="line">            &lt;th&gt;价格&lt;/th&gt;</span><br><span class="line">            &lt;th&gt;数量&lt;/th&gt;</span><br><span class="line">            &lt;th&gt;出版日期&lt;/th&gt;</span><br><span class="line">        &lt;/tr&gt;</span><br><span class="line">        &lt;%</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; BookList.size(); i++)&#123;</span><br><span class="line">     Book book = (Book)BookList.get(i);%&gt;</span><br><span class="line">     &lt;tr&gt;</span><br><span class="line">     &lt;td&gt;&lt;%=book.getBID()%&gt;&lt;/td&gt;</span><br><span class="line">     &lt;td&gt;&lt;%=book.getBNAME()%&gt;&lt;/td&gt;</span><br><span class="line">     &lt;td&gt;&lt;%=book.getBAUTHER()%&gt;&lt;/td&gt;</span><br><span class="line">     &lt;td&gt;&lt;%=book.getBTYPE()%&gt;&lt;/td&gt;</span><br><span class="line">     &lt;td&gt;&lt;%=book.getBPRICE()%&gt;&lt;/td&gt;</span><br><span class="line">     &lt;td&gt;&lt;%=book.getBAMOUNT()%&gt;&lt;/td&gt;</span><br><span class="line">     &lt;td&gt;&lt;%=book.getBPUBDATE()%&gt;&lt;/td&gt;</span><br><span class="line">     &lt;/tr&gt;</span><br><span class="line">     &lt;%</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     %&gt;</span><br><span class="line">   </span><br><span class="line">&lt;/table&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p><strong>截图如下：</strong></p><p><img src="https://img-blog.csdnimg.cn/20201117121051781.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzgyNDEzOQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><hr><h5 id="任务5：修改数据，即确认书号修改数量，保证SQL语句正确，和任务1无异。"><a href="#任务5：修改数据，即确认书号修改数量，保证SQL语句正确，和任务1无异。" class="headerlink" title="任务5：修改数据，即确认书号修改数量，保证SQL语句正确，和任务1无异。"></a>任务5：修改数据，即确认书号修改数量，保证SQL语句正确，和任务1无异。</h5><p><strong>代码如下：</strong></p><p>tsxgServlet.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.etspace.abc.servlet;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.etspace.abc.jdbc.DbBean;</span><br><span class="line"><span class="meta">@WebServlet(&quot;/tsxgServlet&quot;)</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;serial&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">tsxgServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">doPost(request,response);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">request.setCharacterEncoding(<span class="string">&quot;gb2312&quot;</span>);</span><br><span class="line">response.setCharacterEncoding(<span class="string">&quot;gb2312&quot;</span>);</span><br><span class="line">response.setContentType(<span class="string">&quot;text/html;charset=gb2312&quot;</span>);</span><br><span class="line">PrintWriter out = response.getWriter();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">String BID =  request.getParameter(<span class="string">&quot;BID&quot;</span>);</span><br><span class="line">String BAMOUNT =  request.getParameter(<span class="string">&quot;BAMOUNT&quot;</span>);</span><br><span class="line">String sql = <span class="string">&quot;update T_BOOK set BAMOUNT = &quot;</span>+BAMOUNT+<span class="string">&quot; where BID = &#x27;&quot;</span>+BID+<span class="string">&quot;&#x27;&quot;</span>;</span><br><span class="line"><span class="comment">//out.print(sql);</span></span><br><span class="line">DbBean myDbBean=<span class="keyword">new</span> DbBean();</span><br><span class="line">myDbBean.openConnection();</span><br><span class="line">        <span class="keyword">int</span> n = myDbBean.executeUpdate(sql);</span><br><span class="line">        <span class="keyword">if</span> (n&gt;<span class="number">0</span>)&#123;</span><br><span class="line">       out.print(<span class="string">&quot;图书记录修改成功！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="keyword">else</span> &#123;</span><br><span class="line">       out.print(<span class="string">&quot;图书记录修改失败！&quot;</span>);</span><br><span class="line">       &#125; </span><br><span class="line">myDbBean.closeConnection();</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">out.print(e.toString());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>tsxg.jsp</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=gb2312&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.sql.*&quot;</span>%&gt;</span><br><span class="line">&lt;jsp:useBean id=&quot;myDbBean&quot; scope=&quot;page&quot; class=&quot;org.etspace.abc.jdbc.DbBean&quot;&gt;&lt;/jsp:useBean&gt;</span><br><span class="line">&lt;%request.setCharacterEncoding(<span class="string">&quot;gb2312&quot;</span>); %&gt;</span><br><span class="line">&lt;script language=<span class="string">&quot;JavaScript&quot;</span>&gt;</span><br><span class="line"><span class="function">function <span class="title">check</span><span class="params">(theForm)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (theForm.BID.value.length != <span class="number">5</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    alert(<span class="string">&quot;书号必须为5位！&quot;</span>);</span><br><span class="line">    theForm.BID.focus();</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">false</span>);</span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="keyword">if</span> (theForm.BNAME.value == <span class="string">&quot;&quot;</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    alert(<span class="string">&quot;请输入书名！&quot;</span>);</span><br><span class="line">    theForm.BNAME.focus();</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (theForm.BPUBDATE.value == <span class="string">&quot;&quot;</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    alert(<span class="string">&quot;请输入出版日期！&quot;</span>);</span><br><span class="line">    theForm.BPUBDATE.focus();</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (theForm.BAMOUNT.value == <span class="string">&quot;&quot;</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    alert(<span class="string">&quot;请输入数量！&quot;</span>);</span><br><span class="line">    theForm.BAMOUNT.focus();</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (theForm.BPRICE.value == <span class="string">&quot;&quot;</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    alert(<span class="string">&quot;请输入价格！&quot;</span>);</span><br><span class="line">    theForm.BPRICE.focus();</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (theForm.BAUTHER.value == <span class="string">&quot;&quot;</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    alert(<span class="string">&quot;请输入作者！&quot;</span>);</span><br><span class="line">    theForm.BAUTHER.focus();</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (theForm.BTYPE.value == <span class="string">&quot;&quot;</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    alert(<span class="string">&quot;请输入类型！&quot;</span>);</span><br><span class="line">    theForm.BTYPE.focus();</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">false</span>);</span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;&lt;title&gt;图书数量修改&lt;/title&gt;&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div align=<span class="string">&quot;center&quot;</span>&gt;</span><br><span class="line">  &lt;P&gt;图书数量修改&lt;/P&gt;</span><br><span class="line">&lt;form id=<span class="string">&quot;form1&quot;</span> name=<span class="string">&quot;form1&quot;</span> method=<span class="string">&quot;post&quot;</span> action=<span class="string">&quot;tsxgServlet&quot;</span> onSubmit=<span class="string">&quot;return check(this)&quot;</span>&gt;</span><br><span class="line">&lt;table border=<span class="string">&quot;1&quot;</span>&gt;</span><br><span class="line">&lt;tr&gt;&lt;td&gt;书号&lt;/td&gt;&lt;td&gt;&lt;input name=&quot;BID&quot; type=&quot;text&quot; id=&quot;BID&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;</span><br><span class="line">&lt;%</span><br><span class="line">String sql = <span class="string">&quot;select * from BID order by T_BOOK&quot;</span>;</span><br><span class="line">myDbBean.openConnection();</span><br><span class="line">ResultSet rs=myDbBean.executeQuery(sql);</span><br><span class="line">%&gt;</span><br><span class="line">&lt;/td&gt;&lt;/tr&gt;</span><br><span class="line">&lt;tr&gt;&lt;td&gt;数量&lt;/td&gt;&lt;td&gt;&lt;input name=&quot;BAMOUNT&quot; type=&quot;text&quot; id=&quot;BAMOUNT&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;</span><br><span class="line">&lt;/table&gt;</span><br><span class="line">&lt;br&gt;</span><br><span class="line">  &lt;input name=<span class="string">&quot;submit&quot;</span> type=<span class="string">&quot;submit&quot;</span>  value=<span class="string">&quot;确定&quot;</span> /&gt;</span><br><span class="line">  &lt;input name=<span class="string">&quot;reset&quot;</span> type=<span class="string">&quot;reset&quot;</span> value=<span class="string">&quot;重置&quot;</span> /&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p><strong>截图如下：</strong></p><p><img src="https://img-blog.csdnimg.cn/20201117121051738.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzgyNDEzOQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><hr><p><strong>希望能帮到你学习Servlet技术，以及MVC模型的相关知识，感谢观看！</strong></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Servlet实例总结-基于Java、SQLserver、Tomcat&quot;&gt;&lt;a href=&quot;#Servlet实例总结-基于Java、SQLserver、Tomcat&quot; class=&quot;headerlink&quot; title=&quot;Servlet实例总结-基于Java、SQLserver、Tomcat&quot;&gt;&lt;/a&gt;Servlet实例总结-基于Java、SQLserver、Tomcat&lt;/h1&gt;&lt;h2 id=&quot;题目及要求&quot;&gt;&lt;a href=&quot;#题目及要求&quot; class=&quot;headerlink&quot; title=&quot;题目及要求:&quot;&gt;&lt;/a&gt;题目及要求:&lt;/h2&gt;&lt;h3 id=&quot;使用Java-Bean-Servlet-Jsp实现下列目标&quot;&gt;&lt;a href=&quot;#使用Java-Bean-Servlet-Jsp实现下列目标&quot; class=&quot;headerlink&quot; title=&quot;使用Java Bean+Servlet+Jsp实现下列目标&quot;&gt;&lt;/a&gt;&lt;strong&gt;使用Java Bean+Servlet+Jsp实现下列目标&lt;/strong&gt;&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;任务一：在数据库中建立表格T_BOOK(BID, BNAME, BAUTHER, BPRICE, BAMOUNT, BPUBDATE)，并向表中添加一些记录，T_BOOK数据表结构如下：&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;表1-2 T_BOOK数据表&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;序号&lt;/th&gt;
&lt;th&gt;列名&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;th&gt;备注&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;BID&lt;/td&gt;
&lt;td&gt;书号&lt;/td&gt;
&lt;td&gt;VARCHAR(20)&lt;/td&gt;
&lt;td&gt;“B0001”&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;BNAME&lt;/td&gt;
&lt;td&gt;书名&lt;/td&gt;
&lt;td&gt;VARCHAR(50)&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;BAUTHER&lt;/td&gt;
&lt;td&gt;作者&lt;/td&gt;
&lt;td&gt;VARCHAR(50)&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;BTYPE&lt;/td&gt;
&lt;td&gt;类型&lt;/td&gt;
&lt;td&gt;VARCHAR(50)&lt;/td&gt;
&lt;td&gt;计算机、文学&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;BPRICE&lt;/td&gt;
&lt;td&gt;价格&lt;/td&gt;
&lt;td&gt;INT&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;BAMOUNT&lt;/td&gt;
&lt;td&gt;数量&lt;/td&gt;
&lt;td&gt;INT&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;BPUBDATE&lt;/td&gt;
&lt;td&gt;出版日期&lt;/td&gt;
&lt;td&gt;DATE&lt;/td&gt;
&lt;td&gt;2000-1-1&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;&lt;p&gt;任务二：编写程序，在JSP页面中提供表单，用户可填写图书数据，向T_BOOK表中添加一条记录。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;任务三：编写程序，在JSP页面提供按书名模糊查询功能，用户输入书名部分或全部内容，查询的结果显示在JSP页面上。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;任务四：编写程序，在JSP页面中提供按价格区间查询功能，用户可填写两个价格，查询出两个价格之间的图书结果显示在JSP页面上。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;任务五：编写程序，在JSP页面中提供按书号更新书籍数量功能，用户输入书号、数量，可更新数据表中的记录。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="编程" scheme="http://plutowu.top/categories/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="Java Web" scheme="http://plutowu.top/categories/%E7%BC%96%E7%A8%8B/Java-Web/"/>
    
    
    <category term="Java" scheme="http://plutowu.top/tags/Java/"/>
    
    <category term="Servlet" scheme="http://plutowu.top/tags/Servlet/"/>
    
    <category term="Java Web" scheme="http://plutowu.top/tags/Java-Web/"/>
    
  </entry>
  
  <entry>
    <title>三角判断</title>
    <link href="http://plutowu.top/2020/11/17/%E4%B8%89%E8%A7%92%E5%88%A4%E6%96%AD/"/>
    <id>http://plutowu.top/2020/11/17/%E4%B8%89%E8%A7%92%E5%88%A4%E6%96%AD/</id>
    <published>2020-11-17T04:01:54.000Z</published>
    <updated>2021-03-09T15:21:15.415Z</updated>
    
    <content type="html"><![CDATA[<h1 id="三角判断-基于C语言"><a href="#三角判断-基于C语言" class="headerlink" title="三角判断-基于C语言"></a>三角判断-基于C语言</h1><p><em>目的：此程序是为了判断输入的三角形三边，并判断三角形类型，包括等腰三角形、等边三角形、直角三角形、一般三角形及错值判定。</em></p><a id="more"></a><p>代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> a, b, c;</span><br><span class="line">   </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入三角形的三边:（用空格隔开，以回车结束）\n&quot;</span>);</span><br><span class="line">    scanf_s(<span class="string">&quot;%f%f%f&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">    <span class="comment">//判断是否满足三角形条件：两边之和是否大于第三边；</span></span><br><span class="line">    <span class="keyword">if</span> (a == <span class="number">0</span> || b == <span class="number">0</span> || c == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;输入边有空值0，错误！\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (a &lt; <span class="number">0</span> || b &lt; <span class="number">0</span> || c &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;输入边有负值，错误！\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (a + b &gt; c &amp;&amp; b + c &gt; a &amp;&amp; a + c &gt; a)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//判断三条边是否相等，三边相等即为等边三角形</span></span><br><span class="line">        <span class="keyword">if</span> (a == b &amp;&amp; a == c)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;等边三角形\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断三角形是否有两天边相等,两边相等即为等腰三角形</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (a == b || a == c || b == c)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;等腰三角形\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断是否有两边的平方和大于第三边的平方，即为直角三角形</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((a * a + b * b == c * c) || (a * a + c * c == b * b) || (b * b + c * c == a * a))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;直角三角形\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//其他情况为一般三角形</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;一般三角形\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//两边之和小于第三边，不能构成三角形</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;三边不能构成三角形\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><strong>总结：最基本的C语言入门程序，对新手可以很好的了解各个运算符的作用以及if函数的运用。</strong></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;三角判断-基于C语言&quot;&gt;&lt;a href=&quot;#三角判断-基于C语言&quot; class=&quot;headerlink&quot; title=&quot;三角判断-基于C语言&quot;&gt;&lt;/a&gt;三角判断-基于C语言&lt;/h1&gt;&lt;p&gt;&lt;em&gt;目的：此程序是为了判断输入的三角形三边，并判断三角形类型，包括等腰三角形、等边三角形、直角三角形、一般三角形及错值判定。&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="编程" scheme="http://plutowu.top/categories/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="C" scheme="http://plutowu.top/categories/%E7%BC%96%E7%A8%8B/C/"/>
    
    
    <category term="C语言" scheme="http://plutowu.top/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
</feed>
