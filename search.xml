<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Java后端面试笔记-框架</title>
    <url>/2021/03/10/Java%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AE%B0-%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<h1 id="框架相关"><a href="#框架相关" class="headerlink" title="框架相关"></a>框架相关</h1><h2 id="1-SpringBoot-自动装配原理"><a href="#1-SpringBoot-自动装配原理" class="headerlink" title="1.SpringBoot 自动装配原理"></a>1.SpringBoot 自动装配原理</h2><h3 id="什么是-SpringBoot-自动装配？"><a href="#什么是-SpringBoot-自动装配？" class="headerlink" title="什么是 SpringBoot 自动装配？"></a>什么是 SpringBoot 自动装配？</h3><p>我们现在提到自动装配的时候，一般会和 Spring Boot 联系在一起。但是，实际上 Spring Framework 早就实现了这个功能。Spring Boot 只是在其基础上，通过 SPI 的方式，做了进一步优化。</p>
<blockquote>
<p>SpringBoot 定义了一套接口规范，这套规范规定：SpringBoot 在启动时会扫描外部引用 jar 包中的<code>META-INF/spring.factories</code>文件，将文件中配置的类型信息加载到 Spring 容器（此处涉及到 JVM 类加载机制与 Spring 的容器知识），并执行类中定义的各种操作。对于外部 jar 来说，只需要按照 SpringBoot 定义的标准，就能将自己的功能装置进 SpringBoot。</p>
</blockquote>
<p>没有 Spring Boot 的情况下，如果我们需要引入第三方依赖，需要手动配置，非常麻烦。但是，Spring Boot 中，我们直接引入一个 starter 即可。比如你想要在项目中使用 redis 的话，直接在项目中引入对应的 starter 即可。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>引入 starter 之后，我们通过少量注解和一些简单的配置就能使用第三方组件提供的功能了。</p>
<p>在我看来，自动装配可以简单理解为：<strong>通过注解或者一些简单的配置就能在 Spring Boot 的帮助下实现某块功能。</strong></p>
<a id="more"></a>

<h3 id="SpringBoot-是如何实现自动装配的？如何实现按需加载？"><a href="#SpringBoot-是如何实现自动装配的？如何实现按需加载？" class="headerlink" title="SpringBoot 是如何实现自动装配的？如何实现按需加载？"></a>SpringBoot 是如何实现自动装配的？如何实现按需加载？</h3><p>我们先看一下 SpringBoot 的核心注解 <code>SpringBootApplication</code> 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line">&lt;<span class="number">1.</span>&gt;<span class="meta">@SpringBootConfiguration</span></span><br><span class="line">&lt;<span class="number">2.</span>&gt;<span class="meta">@ComponentScan</span></span><br><span class="line">&lt;<span class="number">3.</span>&gt;<span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootApplication &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Configuration</span> <span class="comment">//实际上它也是一个配置类</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootConfiguration &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大概可以把 <code>@SpringBootApplication</code>看作是 <code>@Configuration</code>、<code>@EnableAutoConfiguration</code>、<code>@ComponentScan</code> 注解的集合。根据 SpringBoot 官网，这三个注解的作用分别是：</p>
<ul>
<li><code>@EnableAutoConfiguration</code>：启用 SpringBoot 的自动配置机制</li>
<li><code>@Configuration</code>：允许在上下文中注册额外的 bean 或导入其他配置类</li>
<li><code>@ComponentScan</code>： 扫描被<code>@Component</code> (<code>@Service</code>,<code>@Controller</code>)注解的 bean，注解默认会扫描启动类所在的包下所有的类 ，可以自定义不扫描某些 bean。如下图所示，容器中将排除<code>TypeExcludeFilter</code>和<code>AutoConfigurationExcludeFilter</code>。</li>
</ul>
<p><img src="https://plutowu-blogimgs.oss-cn-guangzhou.aliyuncs.com/img/20210310151024.png"></p>
<p><code>EnableAutoConfiguration</code> 是实现自动装配的重要注解，我们以这个注解入手。</p>
<h3 id="EnableAutoConfiguration-实现自动装配的核心注解"><a href="#EnableAutoConfiguration-实现自动装配的核心注解" class="headerlink" title="@EnableAutoConfiguration:实现自动装配的核心注解"></a>@EnableAutoConfiguration:实现自动装配的核心注解</h3><p><code>EnableAutoConfiguration</code> 只是一个简单地注解，自动装配核心功能的实现实际是通过 <code>AutoConfigurationImportSelector</code>类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@AutoConfigurationPackage</span> <span class="comment">//作用：将main包下的所欲组件注册到容器中</span></span><br><span class="line"><span class="meta">@Import(&#123;AutoConfigurationImportSelector.class&#125;)</span> <span class="comment">//加载自动装配类 xxxAutoconfiguration</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAutoConfiguration &#123;</span><br><span class="line">    String ENABLED_OVERRIDE_PROPERTY = <span class="string">&quot;spring.boot.enableautoconfiguration&quot;</span>;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt;[] exclude() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    String[] excludeName() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们现在重点分析下<code>AutoConfigurationImportSelector</code> 类到底做了什么？</p>
<h3 id="AutoConfigurationImportSelector-加载自动装配类"><a href="#AutoConfigurationImportSelector-加载自动装配类" class="headerlink" title="AutoConfigurationImportSelector:加载自动装配类"></a>AutoConfigurationImportSelector:加载自动装配类</h3><p><code>AutoConfigurationImportSelector</code>类的继承体系如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AutoConfigurationImportSelector</span> <span class="keyword">implements</span> <span class="title">DeferredImportSelector</span>, <span class="title">BeanClassLoaderAware</span>, <span class="title">ResourceLoaderAware</span>, <span class="title">BeanFactoryAware</span>, <span class="title">EnvironmentAware</span>, <span class="title">Ordered</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DeferredImportSelector</span> <span class="keyword">extends</span> <span class="title">ImportSelector</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ImportSelector</span> </span>&#123;</span><br><span class="line">    String[] selectImports(AnnotationMetadata var1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出，<code>AutoConfigurationImportSelector</code> 类实现了 <code>ImportSelector</code>接口，也就实现了这个接口中的 <code>selectImports</code>方法，该方法主要用于<strong>获取所有符合条件的类的全限定类名，这些类需要被加载到 IoC 容器中</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] NO_IMPORTS = <span class="keyword">new</span> String[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String[] selectImports(AnnotationMetadata annotationMetadata) &#123;</span><br><span class="line">        <span class="comment">// &lt;1&gt;.判断自动装配开关是否打开</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.isEnabled(annotationMetadata)) &#123;</span><br><span class="line">            <span class="keyword">return</span> NO_IMPORTS;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">//&lt;2&gt;.获取所有需要装配的bean</span></span><br><span class="line">            AutoConfigurationMetadata autoConfigurationMetadata = AutoConfigurationMetadataLoader.loadMetadata(<span class="keyword">this</span>.beanClassLoader);</span><br><span class="line">            AutoConfigurationImportSelector.AutoConfigurationEntry autoConfigurationEntry = <span class="keyword">this</span>.getAutoConfigurationEntry(autoConfigurationMetadata, annotationMetadata);</span><br><span class="line">            <span class="keyword">return</span> StringUtils.toStringArray(autoConfigurationEntry.getConfigurations());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这里我们需要重点关注一下<code>getAutoConfigurationEntry()</code>方法，这个方法主要负责加载自动配置类的。</p>
<p>该方法调用链如下：</p>
<p><img src="https://plutowu-blogimgs.oss-cn-guangzhou.aliyuncs.com/img/20210310151300.png"></p>
<p>现在我们结合<code>getAutoConfigurationEntry()</code>的源码来详细分析一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AutoConfigurationEntry EMPTY_ENTRY = <span class="keyword">new</span> AutoConfigurationEntry();</span><br><span class="line"></span><br><span class="line"><span class="function">AutoConfigurationEntry <span class="title">getAutoConfigurationEntry</span><span class="params">(AutoConfigurationMetadata autoConfigurationMetadata, AnnotationMetadata annotationMetadata)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//&lt;1&gt;.</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.isEnabled(annotationMetadata)) &#123;</span><br><span class="line">            <span class="keyword">return</span> EMPTY_ENTRY;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//&lt;2&gt;.</span></span><br><span class="line">            AnnotationAttributes attributes = <span class="keyword">this</span>.getAttributes(annotationMetadata);</span><br><span class="line">            <span class="comment">//&lt;3&gt;.</span></span><br><span class="line">            List&lt;String&gt; configurations = <span class="keyword">this</span>.getCandidateConfigurations(annotationMetadata, attributes);</span><br><span class="line">            <span class="comment">//&lt;4&gt;.</span></span><br><span class="line">            configurations = <span class="keyword">this</span>.removeDuplicates(configurations);</span><br><span class="line">            Set&lt;String&gt; exclusions = <span class="keyword">this</span>.getExclusions(annotationMetadata, attributes);</span><br><span class="line">            <span class="keyword">this</span>.checkExcludedClasses(configurations, exclusions);</span><br><span class="line">            configurations.removeAll(exclusions);</span><br><span class="line">            configurations = <span class="keyword">this</span>.filter(configurations, autoConfigurationMetadata);</span><br><span class="line">            <span class="keyword">this</span>.fireAutoConfigurationImportEvents(configurations, exclusions);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> AutoConfigurationImportSelector.AutoConfigurationEntry(configurations, exclusions);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>第 1 步</strong>:</p>
<p>判断自动装配开关是否打开。默认<code>spring.boot.enableautoconfiguration=true</code>，可在 <code>application.properties</code> 或 <code>application.yml</code> 中设置</p>
<p><img src="https://plutowu-blogimgs.oss-cn-guangzhou.aliyuncs.com/img/20210310151411.png"></p>
<p><strong>第 2 步</strong> ：</p>
<p>用于获取<code>EnableAutoConfiguration</code>注解中的 <code>exclude</code> 和 <code>excludeName</code></p>
<p><img src="https://plutowu-blogimgs.oss-cn-guangzhou.aliyuncs.com/img/20210310151439.png"></p>
<p><strong>第 3 步</strong></p>
<p>获取需要自动装配的所有配置类，读取<code>META-INF/spring.factories</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">spring-boot/spring-boot-project/spring-boot-autoconfigure/src/main/resources/META-INF/spring.factories</span><br></pre></td></tr></table></figure>

<p><img src="https://plutowu-blogimgs.oss-cn-guangzhou.aliyuncs.com/img/20210310151533.png"></p>
<p>从下图可以看到这个文件的配置内容都被我们读取到了。<code>XXXAutoConfiguration</code>的作用就是按需加载组件。</p>
<p><img src="https://plutowu-blogimgs.oss-cn-guangzhou.aliyuncs.com/img/20210310151540.png"></p>
<p>不光是这个依赖下的<code>META-INF/spring.factories</code>被读取到，所有 Spring Boot Starter 下的<code>META-INF/spring.factories</code>都会被读取到。</p>
<p>所以，你可以清楚滴看到， druid 数据库连接池的 Spring Boot Starter 就创建了<code>META-INF/spring.factories</code>文件。</p>
<p>如果，我们自己要创建一个 Spring Boot Starter，这一步是必不可少的。</p>
<p><img src="https://plutowu-blogimgs.oss-cn-guangzhou.aliyuncs.com/img/20210310151708.png"></p>
<p><strong>第 4 步</strong> ：</p>
<p>到这里可能面试官会问你:“<code>spring.factories</code>中这么多配置，每次启动都要全部加载么？”。</p>
<p>很明显，这是不现实的。我们 debug 到后面你会发现，<code>configurations</code> 的值变小了。</p>
<p><img src="https://plutowu-blogimgs.oss-cn-guangzhou.aliyuncs.com/img/20210310151550.png"></p>
<p>因为，这一步有经历了一遍筛选，<code>@ConditionalOnXXX</code> 中的所有条件都满足，该类才会生效。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="comment">// 检查相关的类：RabbitTemplate 和 Channel是否存在</span></span><br><span class="line"><span class="comment">// 存在才会加载</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(&#123; RabbitTemplate.class, Channel.class &#125;)</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(RabbitProperties.class)</span></span><br><span class="line"><span class="meta">@Import(RabbitAnnotationDrivenConfiguration.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitAutoConfiguration</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> Spring Boot 提供的条件注解</p>
<ul>
<li><code>@ConditionalOnBean</code>：当容器里有指定 Bean 的条件下</li>
<li><code>@ConditionalOnMissingBean</code>：当容器里没有指定 Bean 的情况下</li>
<li><code>@ConditionalOnSingleCandidate</code>：当指定 Bean 在容器中只有一个，或者虽然有多个但是指定首选 Bean</li>
<li><code>@ConditionalOnClass</code>：当类路径下有指定类的条件下</li>
<li><code>@ConditionalOnMissingClass</code>：当类路径下没有指定类的条件下</li>
<li><code>@ConditionalOnProperty</code>：指定的属性是否有指定的值</li>
<li><code>@ConditionalOnResource</code>：类路径是否有指定的值</li>
<li><code>@ConditionalOnExpression</code>：基于 SpEL 表达式作为判断条件</li>
<li><code>@ConditionalOnJava</code>：基于 Java 版本作为判断条件</li>
<li><code>@ConditionalOnJndi</code>：在 JNDI 存在的条件下差在指定的位置</li>
<li><code>@ConditionalOnNotWebApplication</code>：当前项目不是 Web 项目的条件下</li>
<li><code>@ConditionalOnWebApplication</code>：当前项目是 Web 项目的条件下</li>
</ul>
<h3 id="如何实现一个-Starter？"><a href="#如何实现一个-Starter？" class="headerlink" title="如何实现一个 Starter？"></a>如何实现一个 Starter？</h3><p>撸一个 starter，实现自定义线程池</p>
<p>第一步，创建<code>threadpool-spring-boot-starter</code>工程</p>
<p><img src="https://plutowu-blogimgs.oss-cn-guangzhou.aliyuncs.com/img/20210310151933.png"></p>
<p>第二步，引入 Spring Boot 相关依赖</p>
<p><img src="https://plutowu-blogimgs.oss-cn-guangzhou.aliyuncs.com/img/20210310151955.png"></p>
<p>第三步，创建<code>ThreadPoolAutoConfiguration</code></p>
<p><img src="https://plutowu-blogimgs.oss-cn-guangzhou.aliyuncs.com/img/20210310152017.png"></p>
<p>第四步，在<code>threadpool-spring-boot-starter</code>工程的 resources 包下创建<code>META-INF/spring.factories</code>文件</p>
<p><img src="https://plutowu-blogimgs.oss-cn-guangzhou.aliyuncs.com/img/20210310152042.png"></p>
<p>最后新建工程引入<code>threadpool-spring-boot-starter</code></p>
<p><img src="https://plutowu-blogimgs.oss-cn-guangzhou.aliyuncs.com/img/20210310152103.png"></p>
<p>测试通过</p>
<p><img src="https://plutowu-blogimgs.oss-cn-guangzhou.aliyuncs.com/img/20210310152130.png"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Spring Boot 通过<code>@EnableAutoConfiguration</code>开启自动装配，通过 SpringFactoriesLoader 最终加载<code>META-INF/spring.factories</code>中的自动配置类实现自动装配，自动配置类其实就是通过<code>@Conditional</code>按需加载的配置类，想要其生效必须引入<code>spring-boot-starter-xxx</code>包实现起步依赖</p>
<h2 id="2-SpringBoot-的启动流程"><a href="#2-SpringBoot-的启动流程" class="headerlink" title="2.SpringBoot 的启动流程"></a>2.SpringBoot 的启动流程</h2><h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h3><p><img src="https://plutowu-blogimgs.oss-cn-guangzhou.aliyuncs.com/img/20210310190123.png"></p>
<h3 id="源码及过程解析"><a href="#源码及过程解析" class="headerlink" title="源码及过程解析"></a>源码及过程解析</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ConfigurableApplicationContext <span class="title">run</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 1.初始化stopWatcch(计数器),调用其start方法开始计时</span></span><br><span class="line">	StopWatch stopWatch = <span class="keyword">new</span> StopWatch();</span><br><span class="line">	stopWatch.start();</span><br><span class="line">	ConfigurableApplicationContext context = <span class="keyword">null</span>;</span><br><span class="line">	FailureAnalyzers analyzers = <span class="keyword">null</span>;</span><br><span class="line">	<span class="comment">// 2.设置系统属性java.awt.headless,这里设置为true,表示运行在服务器端，在没有显示器和鼠标键盘的模式下工作，模拟输入输出设备功能</span></span><br><span class="line">	configureHeadlessProperty();</span><br><span class="line">	<span class="comment">// 3.调用springApplicationRunListeners#starting</span></span><br><span class="line">	SpringApplicationRunListeners listeners = getRunListeners(args);</span><br><span class="line">	listeners.starting();</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">// 4.创建一个defaultApplicationArguments对象，他持有args参数（main函数中传入），调用prepareEnvironment方法</span></span><br><span class="line">		ApplicationArguments applicationArguments = <span class="keyword">new</span> DefaultApplicationArguments(args);</span><br><span class="line">		ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments);</span><br><span class="line">		<span class="comment">// 5.打印banner</span></span><br><span class="line">		Banner printedBanner = printBanner(environment);</span><br><span class="line">		<span class="comment">// 6.创建springboot上下文</span></span><br><span class="line">		context = createApplicationContext();</span><br><span class="line">		<span class="comment">// 7.初始化FailureAnalyzers</span></span><br><span class="line">		analyzers = <span class="keyword">new</span> FailureAnalyzers(context);</span><br><span class="line">		<span class="comment">// 8.调用prepareContext</span></span><br><span class="line">		prepareContext(context, environment, listeners, applicationArguments, printedBanner);</span><br><span class="line">		<span class="comment">// 9.调用AbstractApplicationContext#refresh</span></span><br><span class="line">		refreshContext(context);</span><br><span class="line">		<span class="comment">// 10.在容器完成刷新后，依次调用注册的Runners</span></span><br><span class="line">		afterRefresh(context, applicationArguments);</span><br><span class="line">		<span class="comment">// 11.调用SpringApplicationRunListeners#finished</span></span><br><span class="line">		listeners.finished(context, <span class="keyword">null</span>);</span><br><span class="line">		<span class="comment">// 12.停止计时</span></span><br><span class="line">		stopWatch.stop();</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.logStartupInfo) &#123;</span><br><span class="line">			<span class="keyword">new</span> StartupInfoLogger(<span class="keyword">this</span>.mainApplicationClass).logStarted(getApplicationLog(), stopWatch);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> context;</span><br><span class="line">	&#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">		<span class="comment">// 13.初始化过程中出现异常时调用handelRunFailure进行处理，抛出IllegalStateException</span></span><br><span class="line">		handleRunFailure(context, listeners, analyzers, ex);</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(ex);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上代码就是SpringBoot的启动流程了，其中注释也非常详细，主要步骤也已经标注，现将主要步骤总结如下：</p>
<ol>
<li>从<code>spring.factories</code>配置文件中<strong>加载<code>EventPublishingRunListener</code>对象</strong>，该对象拥有<code>SimpleApplicationEventMulticaster</code>属性，即在SpringBoot启动过程的不同阶段用来发射内置的生命周期事件;</li>
<li><strong>准备环境变量</strong>，包括系统变量，环境变量，命令行参数，默认变量，<code>servlet</code>相关配置变量，随机值以及配置文件（比如<code>application.properties</code>）等;</li>
<li>控制台<strong>打印SpringBoot的<code>bannner</code>标志</strong>；</li>
<li><strong>根据不同类型环境创建不同类型的<code>applicationcontext</code>容器</strong>，因为这里是<code>servlet</code>环境，所以创建的是<code>AnnotationConfigServletWebServerApplicationContext</code>容器对象；</li>
<li>从<code>spring.factories</code>配置文件中<strong>加载<code>FailureAnalyzers</code>对象</strong>,用来报告SpringBoot启动过程中的异常；</li>
<li><strong>为刚创建的容器对象做一些初始化工作</strong>，准备一些容器属性值等，对<code>ApplicationContext</code>应用一些相关的后置处理和调用各个<code>ApplicationContextInitializer</code>的初始化方法来执行一些初始化逻辑等；</li>
<li><strong>刷新容器</strong>，这一步至关重要。比如调用<code>bean factory</code>的后置处理器，注册<code>BeanPostProcessor</code>后置处理器，初始化事件广播器且广播事件，初始化剩下的单例<code>bean</code>和SpringBoot创建内嵌的<code>Tomcat</code>服务器等等重要且复杂的逻辑都在这里实现，主要步骤可见代码的注释，关于这里的逻辑会在以后的spring源码分析专题详细分析；</li>
<li><strong>执行刷新容器后的后置处理逻辑</strong>，注意这里为空方法；</li>
<li><strong>调用<code>ApplicationRunner</code>和<code>CommandLineRunner</code>的run方法</strong>，我们实现这两个接口可以在spring容器启动后需要的一些东西比如加载一些业务数据等;</li>
<li><strong>报告启动异常</strong>，即若启动过程中抛出异常，此时用<code>FailureAnalyzers</code>来报告异常;</li>
<li>最终<strong>返回容器对象</strong>，这里调用方法没有声明对象来接收。</li>
</ol>
<p>当然在SpringBoot启动过程中，每个不同的启动阶段会分别发射不同的内置生命周期事件，比如在准备<code>environment</code>前会发射<code>ApplicationStartingEvent</code>事件，在<code>environment</code>准备好后会发射<code>ApplicationEnvironmentPreparedEvent</code>事件，在刷新容器前会发射<code>ApplicationPreparedEvent</code>事件等，总之SpringBoot总共内置了7个生命周期事件，除了标志SpringBoot的不同启动阶段外，同时一些监听器也会监听相应的生命周期事件从而执行一些启动初始化逻辑。</p>
<h2 id="3-Spring-IOC-amp-AOP"><a href="#3-Spring-IOC-amp-AOP" class="headerlink" title="3.Spring IOC &amp; AOP"></a>3.Spring IOC &amp; AOP</h2><h3 id="IoC"><a href="#IoC" class="headerlink" title="IoC"></a>IoC</h3><p>IoC（Inverse of Control:控制反转）是一种<strong>设计思想</strong>，就是 <strong>将原本在程序中手动创建对象的控制权，交由Spring框架来管理。</strong>  IoC 在其他语言中也有应用，并非 Spring 特有。 <strong>IoC 容器是 Spring 用来实现 IoC 的载体，  IoC 容器实际上就是个Map（key，value）,Map 中存放的是各种对象。</strong></p>
<p>将对象之间的相互依赖关系交给 IoC 容器来管理，并由 IoC 容器完成对象的注入。这样可以很大程度上简化应用的开发，把应用从复杂的依赖关系中解放出来。  <strong>IoC 容器就像是一个工厂一样，当我们需要创建一个对象的时候，只需要配置好配置文件/注解即可，完全不用考虑对象是如何被创建出来的。</strong> 在实际项目中一个 Service 类可能有几百甚至上千个类作为它的底层，假如我们需要实例化这个 Service，你可能要每次都要搞清这个 Service 所有底层类的构造函数，这可能会把人逼疯。如果利用 IoC 的话，你只需要配置好，然后在需要的地方引用就行了，这大大增加了项目的可维护性且降低了开发难度。</p>
<p>Spring 时代我们一般通过 XML 文件来配置 Bean，后来开发人员觉得 XML 文件来配置不太好，于是 SpringBoot 注解配置就慢慢开始流行起来。</p>
<p><strong>Spring IoC的初始化过程：</strong> </p>
<p><img src="https://plutowu-blogimgs.oss-cn-guangzhou.aliyuncs.com/img/20210310202931.png"></p>
<h3 id="依赖注入-DI"><a href="#依赖注入-DI" class="headerlink" title="依赖注入(DI)"></a>依赖注入(DI)</h3><p><strong>DI（Dependency Injection）</strong>，Spring IoC 不是一种技术，而是一种思想，通过这种思想，能够指导我们设计出松耦合的程序代码。而Spring IoC这个思想的作用体现在两个方面，一是如何将Bean装配到容器中去以及如何从容器中获取Bean，二是如何解决Bean之间的依赖关系，换句话说，就是如果由IoC容器来管理依赖关系，当一个Bean需要依赖另外一个Bean时，IoC容器如何实现这样的依赖关系。</p>
<p>解决Spring中Bean之间的依赖的实现方式，在Spring的概念中就被称之为<strong>依赖注入（Dependency Injection，DI）</strong>。普遍认为的Spring依赖注入的实现方式有三种：构造方法注入、setter方法注入、注解注入。但，就我而言，我认为应该划分为两种形式——基于XML注入和基于注解注入，然后再细分为下面的形式：</p>
<p><img src="https://plutowu-blogimgs.oss-cn-guangzhou.aliyuncs.com/img/1218435-20200805195048562-1750995069.png"></p>
<hr>
<h3 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h3><p>AOP( Aspect-Oriented Programming : 面向切面编程 ) 能够将那些与业务无关，<strong>却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来</strong>，便于<strong>减少系统的重复代码</strong>，<strong>降低模块间的耦合度</strong>，并<strong>有利于未来的可拓展性和可维护性</strong>。</p>
<p><strong>Spring AOP就是基于动态代理的</strong>，如果要代理的对象，实现了某个接口，那么Spring AOP会使用<strong>JDK Proxy</strong>，去创建代理对象，而对于没有实现接口的对象，就无法使用 JDK Proxy 去进行代理了，这时候Spring AOP会使用<strong>Cglib</strong> ，这时候Spring AOP会使用 <strong>Cglib</strong> 生成一个被代理对象的子类来作为代理，如下图所示：</p>
<p><img src="https://plutowu-blogimgs.oss-cn-guangzhou.aliyuncs.com/img/SpringAOPProcess.jpg" alt="SpringAOPProcess"></p>
<p>当然你也可以使用 AspectJ ,Spring AOP 已经集成了AspectJ  ，AspectJ  应该算的上是 Java 生态系统中最完整的 AOP 框架了。</p>
<p>使用 AOP 之后我们可以把一些通用功能抽象出来，在需要用到的地方直接使用即可，这样大大简化了代码量。我们需要增加新功能时也方便，这样也提高了系统扩展性。日志功能、事务管理等等场景都用到了 AOP 。</p>
<h2 id="4-Spring-框架中的设计模式"><a href="#4-Spring-框架中的设计模式" class="headerlink" title="4.Spring 框架中的设计模式"></a>4.Spring 框架中的设计模式</h2><ul>
<li><strong>工厂设计模式</strong> : Spring使用工厂模式通过 <code>BeanFactory</code>、<code>ApplicationContext</code> 创建 bean 对象。</li>
<li><strong>代理设计模式</strong> : Spring AOP 功能的实现。</li>
<li><strong>单例设计模式</strong> : Spring 中的 Bean 默认都是单例的。</li>
<li><strong>模板方法模式</strong> : Spring 中 <code>jdbcTemplate</code>、<code>hibernateTemplate</code> 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。</li>
<li><strong>包装器设计模式</strong> : 我们的项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们可以根据客户的需求能够动态切换不同的数据源。</li>
<li><strong>观察者模式:</strong> Spring 事件驱动模型就是观察者模式很经典的一个应用。</li>
<li><strong>适配器模式</strong> :Spring AOP 的增强或通知(Advice)使用到了适配器模式、spring MVC 中也是用到了适配器模式适配<code>Controller</code>。</li>
<li>……</li>
</ul>
]]></content>
      <categories>
        <category>面试</category>
        <category>Java</category>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Java</tag>
        <tag>面试</tag>
        <tag>框架</tag>
        <tag>SpringBoot</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Java后端面试笔记-Java8新特性</title>
    <url>/2021/03/10/Java%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AE%B0-Java8%E6%96%B0%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<h1 id="Java8新特性"><a href="#Java8新特性" class="headerlink" title="Java8新特性"></a>Java8新特性</h1><h3 id="接口的默认方法-Default-Methods-for-Interfaces"><a href="#接口的默认方法-Default-Methods-for-Interfaces" class="headerlink" title="接口的默认方法(Default Methods for Interfaces)"></a>接口的默认方法(Default Methods for Interfaces)</h3><p>Java 8使我们能够通过使用 <code>default</code> 关键字向接口添加非抽象方法实现。 此功能也称为<a href="http://stackoverflow.com/a/24102730">虚拟扩展方法</a>。</p>
<p>第一个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Formula</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">calculate</span><span class="params">(<span class="keyword">int</span> a)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">double</span> <span class="title">sqrt</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Math.sqrt(a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Formula 接口中除了抽象方法计算接口公式还定义了默认方法 <code>sqrt</code>。 实现该接口的类只需要实现抽象方法 <code>calculate</code>。 默认方法<code>sqrt</code> 可以直接使用。当然你也可以直接通过接口创建对象，然后实现接口中的默认方法就可以了，我们通过代码演示一下这种方式。</p>
<a id="more"></a>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 通过匿名内部类方式访问接口</span></span><br><span class="line">    Formula formula = <span class="keyword">new</span> Formula() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">calculate</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> sqrt(a * <span class="number">100</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    System.out.println(formula.calculate(<span class="number">100</span>));     <span class="comment">// 100.0</span></span><br><span class="line">    System.out.println(formula.sqrt(<span class="number">16</span>));           <span class="comment">// 4.0</span></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> formula 是作为匿名对象实现的。该代码非常容易理解，6行代码实现了计算 <code>sqrt(a * 100)</code>。在下一节中，我们将会看到在 Java 8 中实现单个方法对象有一种更好更方便的方法。</p>
<p><strong>译者注：</strong> 不管是抽象类还是接口，都可以通过匿名内部类的方式访问。不能通过抽象类或者接口直接创建对象。对于上面通过匿名内部类方式访问接口，我们可以这样理解：一个内部类实现了接口里的抽象方法并且返回一个内部类对象，之后我们让接口的引用来指向这个对象。</p>
<h3 id="Lambda表达式-Lambda-expressions"><a href="#Lambda表达式-Lambda-expressions" class="headerlink" title="Lambda表达式(Lambda expressions)"></a>Lambda表达式(Lambda expressions)</h3><p>首先看看在老版本的Java中是如何排列字符串的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; names = Arrays.asList(<span class="string">&quot;peter&quot;</span>, <span class="string">&quot;anna&quot;</span>, <span class="string">&quot;mike&quot;</span>, <span class="string">&quot;xenia&quot;</span>);</span><br><span class="line"></span><br><span class="line">Collections.sort(names, <span class="keyword">new</span> Comparator&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String a, String b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> b.compareTo(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>只需要给静态方法<code> Collections.sort</code> 传入一个 List 对象以及一个比较器来按指定顺序排列。通常做法都是创建一个匿名的比较器对象然后将其传递给 <code>sort</code> 方法。</p>
<p>在Java 8 中你就没必要使用这种传统的匿名对象的方式了，Java 8提供了更简洁的语法，lambda表达式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collections.sort(names, (String a, String b) -&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> b.compareTo(a);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>可以看出，代码变得更段且更具有可读性，但是实际上还可以写得更短：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collections.sort(names, (String a, String b) -&gt; b.compareTo(a));</span><br></pre></td></tr></table></figure>

<p>对于函数体只有一行代码的，你可以去掉大括号{}以及return关键字，但是你还可以写得更短点：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">names.sort((a, b) -&gt; b.compareTo(a));</span><br></pre></td></tr></table></figure>

<p>List 类本身就有一个 <code>sort</code> 方法。并且Java编译器可以自动推导出参数类型，所以你可以不用再写一次类型。接下来我们看看lambda表达式还有什么其他用法。</p>
<h3 id="函数式接口-Functional-Interfaces"><a href="#函数式接口-Functional-Interfaces" class="headerlink" title="函数式接口(Functional Interfaces)"></a>函数式接口(Functional Interfaces)</h3><p><strong>译者注：</strong> 原文对这部分解释不太清楚，故做了修改！</p>
<p>Java 语言设计者们投入了大量精力来思考如何使现有的函数友好地支持Lambda。最终采取的方法是：增加函数式接口的概念。<strong>“函数式接口”是指仅仅只包含一个抽象方法,但是可以有多个非抽象方法(也就是上面提到的默认方法)的接口。</strong> 像这样的接口，可以被隐式转换为lambda表达式。<code>java.lang.Runnable</code> 与 <code>java.util.concurrent.Callable</code> 是函数式接口最典型的两个例子。Java 8增加了一种特殊的注解<code>@FunctionalInterface</code>,但是这个注解通常不是必须的(某些情况建议使用)，只要接口只包含一个抽象方法，虚拟机会自动判断该接口为函数式接口。一般建议在接口上使用<code>@FunctionalInterface</code> 注解进行声明，这样的话，编译器如果发现你标注了这个注解的接口有多于一个抽象方法的时候会报错的，如下图所示</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-2/@FunctionalInterface.png" alt="@FunctionalInterface 注解"></p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Converter</span>&lt;<span class="title">F</span>, <span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function">T <span class="title">convert</span><span class="params">(F from)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// TODO 将数字字符串转换为整数类型</span></span><br><span class="line">Converter&lt;String, Integer&gt; converter = (from) -&gt; Integer.valueOf(from);</span><br><span class="line">Integer converted = converter.convert(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">System.out.println(converted.getClass()); <span class="comment">//class java.lang.Integer</span></span><br></pre></td></tr></table></figure>

<p><strong>译者注：</strong> 大部分函数式接口都不用我们自己写，Java8都给我们实现好了，这些接口都在java.util.function包里。</p>
<h3 id="方法和构造函数引用-Method-and-Constructor-References"><a href="#方法和构造函数引用-Method-and-Constructor-References" class="headerlink" title="方法和构造函数引用(Method and Constructor References)"></a>方法和构造函数引用(Method and Constructor References)</h3><p>前一节中的代码还可以通过静态方法引用来表示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Converter&lt;String, Integer&gt; converter = Integer::valueOf;</span><br><span class="line">Integer converted = converter.convert(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">System.out.println(converted.getClass());   <span class="comment">//class java.lang.Integer</span></span><br></pre></td></tr></table></figure>

<p>Java 8允许您通过<code>::</code>关键字传递方法或构造函数的引用。 上面的示例显示了如何引用静态方法。 但我们也可以引用对象方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Something</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">startsWith</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> String.valueOf(s.charAt(<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Something something = <span class="keyword">new</span> Something();</span><br><span class="line">Converter&lt;String, String&gt; converter = something::startsWith;</span><br><span class="line">String converted = converter.convert(<span class="string">&quot;Java&quot;</span>);</span><br><span class="line">System.out.println(converted);    <span class="comment">// &quot;J&quot;</span></span><br></pre></td></tr></table></figure>

<p>接下来看看构造函数是如何使用<code>::</code>关键字来引用的，首先我们定义一个包含多个构造函数的简单类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    String firstName;</span><br><span class="line">    String lastName;</span><br><span class="line"></span><br><span class="line">    Person() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    Person(String firstName, String lastName) &#123;</span><br><span class="line">        <span class="keyword">this</span>.firstName = firstName;</span><br><span class="line">        <span class="keyword">this</span>.lastName = lastName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来我们指定一个用来创建Person对象的对象工厂接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">PersonFactory</span>&lt;<span class="title">P</span> <span class="keyword">extends</span> <span class="title">Person</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">P <span class="title">create</span><span class="params">(String firstName, String lastName)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们使用构造函数引用来将他们关联起来，而不是手动实现一个完整的工厂：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PersonFactory&lt;Person&gt; personFactory = Person::<span class="keyword">new</span>;</span><br><span class="line">Person person = personFactory.create(<span class="string">&quot;Peter&quot;</span>, <span class="string">&quot;Parker&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>我们只需要使用 <code>Person::new</code> 来获取Person类构造函数的引用，Java编译器会自动根据<code>PersonFactory.create</code>方法的参数类型来选择合适的构造函数。</p>
<h3 id="Lamda-表达式作用域-Lambda-Scopes"><a href="#Lamda-表达式作用域-Lambda-Scopes" class="headerlink" title="Lamda 表达式作用域(Lambda Scopes)"></a>Lamda 表达式作用域(Lambda Scopes)</h3><h4 id="访问局部变量"><a href="#访问局部变量" class="headerlink" title="访问局部变量"></a>访问局部变量</h4><p>我们可以直接在 lambda 表达式中访问外部的局部变量：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">Converter&lt;Integer, String&gt; stringConverter =</span><br><span class="line">        (from) -&gt; String.valueOf(from + num);</span><br><span class="line"></span><br><span class="line">stringConverter.convert(<span class="number">2</span>);     <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>但是和匿名对象不同的是，这里的变量num可以不用声明为final，该代码同样正确：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">Converter&lt;Integer, String&gt; stringConverter =</span><br><span class="line">        (from) -&gt; String.valueOf(from + num);</span><br><span class="line"></span><br><span class="line">stringConverter.convert(<span class="number">2</span>);     <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>不过这里的 num 必须不可被后面的代码修改（即隐性的具有final的语义），例如下面的就无法编译：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">Converter&lt;Integer, String&gt; stringConverter =</span><br><span class="line">        (from) -&gt; String.valueOf(from + num);</span><br><span class="line">num = <span class="number">3</span>;<span class="comment">//在lambda表达式中试图修改num同样是不允许的。</span></span><br></pre></td></tr></table></figure>

<h4 id="访问字段和静态变量"><a href="#访问字段和静态变量" class="headerlink" title="访问字段和静态变量"></a>访问字段和静态变量</h4><p>与局部变量相比，我们对lambda表达式中的实例字段和静态变量都有读写访问权限。 该行为和匿名对象是一致的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lambda4</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> outerStaticNum;</span><br><span class="line">    <span class="keyword">int</span> outerNum;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testScopes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Converter&lt;Integer, String&gt; stringConverter1 = (from) -&gt; &#123;</span><br><span class="line">            outerNum = <span class="number">23</span>;</span><br><span class="line">            <span class="keyword">return</span> String.valueOf(from);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Converter&lt;Integer, String&gt; stringConverter2 = (from) -&gt; &#123;</span><br><span class="line">            outerStaticNum = <span class="number">72</span>;</span><br><span class="line">            <span class="keyword">return</span> String.valueOf(from);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="访问默认接口方法"><a href="#访问默认接口方法" class="headerlink" title="访问默认接口方法"></a>访问默认接口方法</h4><p>还记得第一节中的 formula 示例吗？ <code>Formula</code> 接口定义了一个默认方法<code>sqrt</code>，可以从包含匿名对象的每个 formula 实例访问该方法。 这不适用于lambda表达式。</p>
<p>无法从 lambda 表达式中访问默认方法,故以下代码无法编译：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Formula formula = (a) -&gt; sqrt(a * <span class="number">100</span>);</span><br></pre></td></tr></table></figure>

<h3 id="内置函数式接口-Built-in-Functional-Interfaces"><a href="#内置函数式接口-Built-in-Functional-Interfaces" class="headerlink" title="内置函数式接口(Built-in Functional Interfaces)"></a>内置函数式接口(Built-in Functional Interfaces)</h3><p>JDK 1.8 API包含许多内置函数式接口。 其中一些借口在老版本的 Java 中是比较常见的比如： <code>Comparator</code> 或<code>Runnable</code>，这些接口都增加了<code>@FunctionalInterface</code>注解以便能用在 lambda 表达式上。</p>
<p>但是 Java 8 API 同样还提供了很多全新的函数式接口来让你的编程工作更加方便，有一些接口是来自 <a href="https://code.google.com/p/guava-libraries/">Google Guava</a> 库里的，即便你对这些很熟悉了，还是有必要看看这些是如何扩展到lambda上使用的。</p>
<h4 id="Predicate"><a href="#Predicate" class="headerlink" title="Predicate"></a>Predicate</h4><p>Predicate 接口是只有一个参数的返回布尔类型值的 <strong>断言型</strong> 接口。该接口包含多种默认方法来将 Predicate 组合成其他复杂的逻辑（比如：与，或，非）：</p>
<p><strong>译者注：</strong> Predicate 接口源码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.util.function;</span><br><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Predicate</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 该方法是接受一个传入类型,返回一个布尔值.此方法应用于判断.</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">test</span><span class="params">(T t)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//and方法与关系型运算符&quot;&amp;&amp;&quot;相似，两边都成立才返回true</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> Predicate&lt;T&gt; <span class="title">and</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> T&gt; other)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(other);</span><br><span class="line">        <span class="keyword">return</span> (t) -&gt; test(t) &amp;&amp; other.test(t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 与关系运算符&quot;!&quot;相似，对判断进行取反</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> Predicate&lt;T&gt; <span class="title">negate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (t) -&gt; !test(t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//or方法与关系型运算符&quot;||&quot;相似，两边只要有一个成立就返回true</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> Predicate&lt;T&gt; <span class="title">or</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> T&gt; other)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(other);</span><br><span class="line">        <span class="keyword">return</span> (t) -&gt; test(t) || other.test(t);</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">// 该方法接收一个Object对象,返回一个Predicate类型.此方法用于判断第一个test的方法与第二个test方法相同(equal).</span></span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function">Predicate&lt;T&gt; <span class="title">isEqual</span><span class="params">(Object targetRef)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">null</span> == targetRef)</span><br><span class="line">                ? Objects::isNull</span><br><span class="line">                : object -&gt; targetRef.equals(object);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Predicate&lt;String&gt; predicate = (s) -&gt; s.length() &gt; <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">predicate.test(<span class="string">&quot;foo&quot;</span>);              <span class="comment">// true</span></span><br><span class="line">predicate.negate().test(<span class="string">&quot;foo&quot;</span>);     <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">Predicate&lt;Boolean&gt; nonNull = Objects::nonNull;</span><br><span class="line">Predicate&lt;Boolean&gt; isNull = Objects::isNull;</span><br><span class="line"></span><br><span class="line">Predicate&lt;String&gt; isEmpty = String::isEmpty;</span><br><span class="line">Predicate&lt;String&gt; isNotEmpty = isEmpty.negate();</span><br></pre></td></tr></table></figure>

<h4 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h4><p>Function 接口接受一个参数并生成结果。默认方法可用于将多个函数链接在一起（compose, andThen）：</p>
<p><strong>译者注：</strong> Function  接口源码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.util.function;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Function</span>&lt;<span class="title">T</span>, <span class="title">R</span>&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将Function对象应用到输入的参数上，然后返回计算结果。</span></span><br><span class="line">    <span class="function">R <span class="title">apply</span><span class="params">(T t)</span></span>;</span><br><span class="line">    <span class="comment">//将两个Function整合，并返回一个能够执行两个Function对象功能的Function对象。</span></span><br><span class="line">    <span class="keyword">default</span> &lt;V&gt; <span class="function">Function&lt;V, R&gt; <span class="title">compose</span><span class="params">(Function&lt;? <span class="keyword">super</span> V, ? extends T&gt; before)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(before);</span><br><span class="line">        <span class="keyword">return</span> (V v) -&gt; apply(before.apply(v));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="keyword">default</span> &lt;V&gt; <span class="function">Function&lt;T, V&gt; <span class="title">andThen</span><span class="params">(Function&lt;? <span class="keyword">super</span> R, ? extends V&gt; after)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(after);</span><br><span class="line">        <span class="keyword">return</span> (T t) -&gt; after.apply(apply(t));</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function">Function&lt;T, T&gt; <span class="title">identity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t -&gt; t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Function&lt;String, Integer&gt; toInteger = Integer::valueOf;</span><br><span class="line">Function&lt;String, String&gt; backToString = toInteger.andThen(String::valueOf);</span><br><span class="line">backToString.apply(<span class="string">&quot;123&quot;</span>);     <span class="comment">// &quot;123&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="Supplier"><a href="#Supplier" class="headerlink" title="Supplier"></a>Supplier</h4><p>Supplier 接口产生给定泛型类型的结果。 与 Function 接口不同，Supplier 接口不接受参数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Supplier&lt;Person&gt; personSupplier = Person::<span class="keyword">new</span>;</span><br><span class="line">personSupplier.get();   <span class="comment">// new Person</span></span><br></pre></td></tr></table></figure>

<h4 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h4><p>Consumer 接口表示要对单个输入参数执行的操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Consumer&lt;Person&gt; greeter = (p) -&gt; System.out.println(<span class="string">&quot;Hello, &quot;</span> + p.firstName);</span><br><span class="line">greeter.accept(<span class="keyword">new</span> Person(<span class="string">&quot;Luke&quot;</span>, <span class="string">&quot;Skywalker&quot;</span>));</span><br></pre></td></tr></table></figure>

<h4 id="Comparator"><a href="#Comparator" class="headerlink" title="Comparator"></a>Comparator</h4><p>Comparator 是老Java中的经典接口， Java 8在此之上添加了多种默认方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Comparator&lt;Person&gt; comparator = (p1, p2) -&gt; p1.firstName.compareTo(p2.firstName);</span><br><span class="line"></span><br><span class="line">Person p1 = <span class="keyword">new</span> Person(<span class="string">&quot;John&quot;</span>, <span class="string">&quot;Doe&quot;</span>);</span><br><span class="line">Person p2 = <span class="keyword">new</span> Person(<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;Wonderland&quot;</span>);</span><br><span class="line"></span><br><span class="line">comparator.compare(p1, p2);             <span class="comment">// &gt; 0</span></span><br><span class="line">comparator.reversed().compare(p1, p2);  <span class="comment">// &lt; 0</span></span><br></pre></td></tr></table></figure>

<h2 id="Optional"><a href="#Optional" class="headerlink" title="Optional"></a>Optional</h2><p>Optional不是函数式接口，而是用于防止 NullPointerException 的漂亮工具。这是下一节的一个重要概念，让我们快速了解一下Optional的工作原理。</p>
<p>Optional 是一个简单的容器，其值可能是null或者不是null。在Java 8之前一般某个函数应该返回非空对象但是有时却什么也没有返回，而在Java 8中，你应该返回 Optional 而不是 null。</p>
<p>译者注：示例中每个方法的作用已经添加。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//of（）：为非null的值创建一个Optional</span></span><br><span class="line">Optional&lt;String&gt; optional = Optional.of(<span class="string">&quot;bam&quot;</span>);</span><br><span class="line"><span class="comment">// isPresent（）： 如果值存在返回true，否则返回false</span></span><br><span class="line">optional.isPresent();           <span class="comment">// true</span></span><br><span class="line"><span class="comment">//get()：如果Optional有值则将其返回，否则抛出NoSuchElementException</span></span><br><span class="line">optional.get();                 <span class="comment">// &quot;bam&quot;</span></span><br><span class="line"><span class="comment">//orElse（）：如果有值则将其返回，否则返回指定的其它值</span></span><br><span class="line">optional.orElse(<span class="string">&quot;fallback&quot;</span>);    <span class="comment">// &quot;bam&quot;</span></span><br><span class="line"><span class="comment">//ifPresent（）：如果Optional实例有值则为其调用consumer，否则不做处理</span></span><br><span class="line">optional.ifPresent((s) -&gt; System.out.println(s.charAt(<span class="number">0</span>)));     <span class="comment">// &quot;b&quot;</span></span><br></pre></td></tr></table></figure>

<p>推荐阅读：<a href="https://blog.kaaass.net/archives/764">[Java8]如何正确使用Optional</a></p>
<h2 id="Streams-流"><a href="#Streams-流" class="headerlink" title="Streams(流)"></a>Streams(流)</h2><p><code>java.util.Stream</code> 表示能应用在一组元素上一次执行的操作序列。Stream 操作分为中间操作或者最终操作两种，最终操作返回一特定类型的计算结果，而中间操作返回Stream本身，这样你就可以将多个操作依次串起来。Stream 的创建需要指定一个数据源，比如<code> java.util.Collection</code> 的子类，List 或者 Set， Map 不支持。Stream 的操作可以串行执行或者并行执行。</p>
<p>首先看看Stream是怎么用，首先创建实例代码的用到的数据List：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; stringList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">stringList.add(<span class="string">&quot;ddd2&quot;</span>);</span><br><span class="line">stringList.add(<span class="string">&quot;aaa2&quot;</span>);</span><br><span class="line">stringList.add(<span class="string">&quot;bbb1&quot;</span>);</span><br><span class="line">stringList.add(<span class="string">&quot;aaa1&quot;</span>);</span><br><span class="line">stringList.add(<span class="string">&quot;bbb3&quot;</span>);</span><br><span class="line">stringList.add(<span class="string">&quot;ccc&quot;</span>);</span><br><span class="line">stringList.add(<span class="string">&quot;bbb2&quot;</span>);</span><br><span class="line">stringList.add(<span class="string">&quot;ddd1&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>Java 8扩展了集合类，可以通过 Collection.stream() 或者 Collection.parallelStream() 来创建一个Stream。下面几节将详细解释常用的Stream操作：</p>
<h3 id="Filter-过滤"><a href="#Filter-过滤" class="headerlink" title="Filter(过滤)"></a>Filter(过滤)</h3><p>过滤通过一个predicate接口来过滤并只保留符合条件的元素，该操作属于<strong>中间操作</strong>，所以我们可以在过滤后的结果来应用其他Stream操作（比如forEach）。forEach需要一个函数来对过滤后的元素依次执行。forEach是一个最终操作，所以我们不能在forEach之后来执行其他Stream操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 测试 Filter(过滤)</span></span><br><span class="line">stringList</span><br><span class="line">        .stream()</span><br><span class="line">        .filter((s) -&gt; s.startsWith(<span class="string">&quot;a&quot;</span>))</span><br><span class="line">        .forEach(System.out::println);<span class="comment">//aaa2 aaa1</span></span><br></pre></td></tr></table></figure>

<p>forEach 是为 Lambda 而设计的，保持了最紧凑的风格。而且 Lambda 表达式本身是可以重用的，非常方便。</p>
<h3 id="Sorted-排序"><a href="#Sorted-排序" class="headerlink" title="Sorted(排序)"></a>Sorted(排序)</h3><p>排序是一个 <strong>中间操作</strong>，返回的是排序好后的 Stream。<strong>如果你不指定一个自定义的 Comparator 则会使用默认排序。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 测试 Sort (排序)</span></span><br><span class="line">stringList</span><br><span class="line">        .stream()</span><br><span class="line">        .sorted()</span><br><span class="line">        .filter((s) -&gt; s.startsWith(<span class="string">&quot;a&quot;</span>))</span><br><span class="line">        .forEach(System.out::println);<span class="comment">// aaa1 aaa2</span></span><br></pre></td></tr></table></figure>

<p>需要注意的是，排序只创建了一个排列好后的Stream，而不会影响原有的数据源，排序之后原数据stringCollection是不会被修改的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(stringList);<span class="comment">// ddd2, aaa2, bbb1, aaa1, bbb3, ccc, bbb2, ddd1</span></span><br></pre></td></tr></table></figure>

<h3 id="Map-映射"><a href="#Map-映射" class="headerlink" title="Map(映射)"></a>Map(映射)</h3><p>中间操作 map 会将元素根据指定的 Function 接口来依次将元素转成另外的对象。</p>
<p>下面的示例展示了将字符串转换为大写字符串。你也可以通过map来将对象转换成其他类型，map返回的Stream类型是根据你map传递进去的函数的返回值决定的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 测试 Map 操作</span></span><br><span class="line">stringList</span><br><span class="line">        .stream()</span><br><span class="line">        .map(String::toUpperCase)</span><br><span class="line">        .sorted((a, b) -&gt; b.compareTo(a))</span><br><span class="line">        .forEach(System.out::println);<span class="comment">// &quot;DDD2&quot;, &quot;DDD1&quot;, &quot;CCC&quot;, &quot;BBB3&quot;, &quot;BBB2&quot;, &quot;AAA2&quot;, &quot;AAA1&quot;</span></span><br></pre></td></tr></table></figure>



<h3 id="Match-匹配"><a href="#Match-匹配" class="headerlink" title="Match(匹配)"></a>Match(匹配)</h3><p>Stream提供了多种匹配操作，允许检测指定的Predicate是否匹配整个Stream。所有的匹配操作都是 <strong>最终操作</strong> ，并返回一个 boolean 类型的值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 测试 Match (匹配)操作</span></span><br><span class="line"><span class="keyword">boolean</span> anyStartsWithA =</span><br><span class="line">        stringList</span><br><span class="line">                .stream()</span><br><span class="line">                .anyMatch((s) -&gt; s.startsWith(<span class="string">&quot;a&quot;</span>));</span><br><span class="line">System.out.println(anyStartsWithA);      <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> allStartsWithA =</span><br><span class="line">        stringList</span><br><span class="line">                .stream()</span><br><span class="line">                .allMatch((s) -&gt; s.startsWith(<span class="string">&quot;a&quot;</span>));</span><br><span class="line"></span><br><span class="line">System.out.println(allStartsWithA);      <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> noneStartsWithZ =</span><br><span class="line">        stringList</span><br><span class="line">                .stream()</span><br><span class="line">                .noneMatch((s) -&gt; s.startsWith(<span class="string">&quot;z&quot;</span>));</span><br><span class="line"></span><br><span class="line">System.out.println(noneStartsWithZ);      <span class="comment">// true</span></span><br></pre></td></tr></table></figure>



<h3 id="Count-计数"><a href="#Count-计数" class="headerlink" title="Count(计数)"></a>Count(计数)</h3><p>计数是一个 <strong>最终操作</strong>，返回Stream中元素的个数，<strong>返回值类型是 long</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//测试 Count (计数)操作</span></span><br><span class="line">  <span class="keyword">long</span> startsWithB =</span><br><span class="line">          stringList</span><br><span class="line">                  .stream()</span><br><span class="line">                  .filter((s) -&gt; s.startsWith(<span class="string">&quot;b&quot;</span>))</span><br><span class="line">                  .count();</span><br><span class="line">  System.out.println(startsWithB);    <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<h3 id="Reduce-规约"><a href="#Reduce-规约" class="headerlink" title="Reduce(规约)"></a>Reduce(规约)</h3><p>这是一个 <strong>最终操作</strong> ，允许通过指定的函数来讲stream中的多个元素规约为一个元素，规约后的结果是通过Optional 接口表示的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//测试 Reduce (规约)操作</span></span><br><span class="line">Optional&lt;String&gt; reduced =</span><br><span class="line">        stringList</span><br><span class="line">                .stream()</span><br><span class="line">                .sorted()</span><br><span class="line">                .reduce((s1, s2) -&gt; s1 + <span class="string">&quot;#&quot;</span> + s2);</span><br><span class="line"></span><br><span class="line">reduced.ifPresent(System.out::println);<span class="comment">//aaa1#aaa2#bbb1#bbb2#bbb3#ccc#ddd1#ddd2</span></span><br></pre></td></tr></table></figure>



<p><strong>译者注：</strong> 这个方法的主要作用是把 Stream 元素组合起来。它提供一个起始值（种子），然后依照运算规则（BinaryOperator），和前面 Stream 的第一个、第二个、第 n 个元素组合。从这个意义上说，字符串拼接、数值的 sum、min、max、average 都是特殊的 reduce。例如 Stream 的 sum 就相当于<code>Integer sum = integers.reduce(0, (a, b) -&gt; a+b);</code>也有没有起始值的情况，这时会把 Stream 的前面两个元素组合起来，返回的是 Optional。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 字符串连接，concat = &quot;ABCD&quot;</span></span><br><span class="line">String concat = Stream.of(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;D&quot;</span>).reduce(<span class="string">&quot;&quot;</span>, String::concat); </span><br><span class="line"><span class="comment">// 求最小值，minValue = -3.0</span></span><br><span class="line"><span class="keyword">double</span> minValue = Stream.of(-<span class="number">1.5</span>, <span class="number">1.0</span>, -<span class="number">3.0</span>, -<span class="number">2.0</span>).reduce(Double.MAX_VALUE, Double::min); </span><br><span class="line"><span class="comment">// 求和，sumValue = 10, 有起始值</span></span><br><span class="line"><span class="keyword">int</span> sumValue = Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>).reduce(<span class="number">0</span>, Integer::sum);</span><br><span class="line"><span class="comment">// 求和，sumValue = 10, 无起始值</span></span><br><span class="line">sumValue = Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>).reduce(Integer::sum).get();</span><br><span class="line"><span class="comment">// 过滤，字符串连接，concat = &quot;ace&quot;</span></span><br><span class="line">concat = Stream.of(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;D&quot;</span>, <span class="string">&quot;e&quot;</span>, <span class="string">&quot;F&quot;</span>).</span><br><span class="line"> filter(x -&gt; x.compareTo(<span class="string">&quot;Z&quot;</span>) &gt; <span class="number">0</span>).</span><br><span class="line"> reduce(<span class="string">&quot;&quot;</span>, String::concat);</span><br></pre></td></tr></table></figure>

<p>上面代码例如第一个示例的 reduce()，第一个参数（空白字符）即为起始值，第二个参数（String::concat）为 BinaryOperator。这类有起始值的 reduce() 都返回具体的对象。而对于第四个示例没有起始值的 reduce()，由于可能没有足够的元素，返回的是 Optional，请留意这个区别。更多内容查看： <a href="https://www.ibm.com/developerworks/cn/java/j-lo-java8streamapi/index.html">IBM：Java 8 中的 Streams API 详解</a> </p>
<h2 id="Parallel-Streams-并行流"><a href="#Parallel-Streams-并行流" class="headerlink" title="Parallel Streams(并行流)"></a>Parallel Streams(并行流)</h2><p>前面提到过Stream有串行和并行两种，串行Stream上的操作是在一个线程中依次完成，而并行Stream则是在多个线程上同时执行。</p>
<p>下面的例子展示了是如何通过并行Stream来提升性能：</p>
<p>首先我们创建一个没有重复元素的大表：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> max = <span class="number">1000000</span>;</span><br><span class="line">List&lt;String&gt; values = <span class="keyword">new</span> ArrayList&lt;&gt;(max);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; max; i++) &#123;</span><br><span class="line">    UUID uuid = UUID.randomUUID();</span><br><span class="line">    values.add(uuid.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们分别用串行和并行两种方式对其进行排序，最后看看所用时间的对比。</p>
<h3 id="Sequential-Sort-串行排序"><a href="#Sequential-Sort-串行排序" class="headerlink" title="Sequential Sort(串行排序)"></a>Sequential Sort(串行排序)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//串行排序</span></span><br><span class="line"><span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line"><span class="keyword">long</span> count = values.stream().sorted().count();</span><br><span class="line">System.out.println(count);</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> millis = TimeUnit.NANOSECONDS.toMillis(t1 - t0);</span><br><span class="line">System.out.println(String.format(<span class="string">&quot;sequential sort took: %d ms&quot;</span>, millis));</span><br></pre></td></tr></table></figure>

<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">1000000</span></span><br><span class="line">sequential sort took: <span class="number">709</span> ms<span class="comment">//串行排序所用的时间</span></span><br></pre></td></tr></table></figure>

<h3 id="Parallel-Sort-并行排序"><a href="#Parallel-Sort-并行排序" class="headerlink" title="Parallel Sort(并行排序)"></a>Parallel Sort(并行排序)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//并行排序</span></span><br><span class="line"><span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> count = values.parallelStream().sorted().count();</span><br><span class="line">System.out.println(count);</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> millis = TimeUnit.NANOSECONDS.toMillis(t1 - t0);</span><br><span class="line">System.out.println(String.format(<span class="string">&quot;parallel sort took: %d ms&quot;</span>, millis));</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1000000</span></span><br><span class="line">parallel sort took: <span class="number">475</span> ms<span class="comment">//串行排序所用的时间</span></span><br></pre></td></tr></table></figure>

<p>上面两个代码几乎是一样的，但是并行版的快了 50% 左右，唯一需要做的改动就是将 <code>stream()</code> 改为<code>parallelStream()</code>。</p>
<h2 id="Maps"><a href="#Maps" class="headerlink" title="Maps"></a>Maps</h2><p>前面提到过，Map 类型不支持 streams，不过Map提供了一些新的有用的方法来处理一些日常任务。Map接口本身没有可用的 <code>stream（）</code>方法，但是你可以在键，值上创建专门的流或者通过 <code>map.keySet().stream()</code>,<code>map.values().stream()</code>和<code>map.entrySet().stream()</code>。</p>
<p>此外,Maps 支持各种新的和有用的方法来执行常见任务。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;Integer, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    map.putIfAbsent(i, <span class="string">&quot;val&quot;</span> + i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">map.forEach((id, val) -&gt; System.out.println(val));<span class="comment">//val0 val1 val2 val3 val4 val5 val6 val7 val8 val9</span></span><br></pre></td></tr></table></figure>

<p><code>putIfAbsent</code> 阻止我们在null检查时写入额外的代码;<code>forEach</code>接受一个 consumer 来对 map 中的每个元素操作。</p>
<p>此示例显示如何使用函数在 map 上计算代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">map.computeIfPresent(<span class="number">3</span>, (num, val) -&gt; val + num);</span><br><span class="line">map.get(<span class="number">3</span>);             <span class="comment">// val33</span></span><br><span class="line"></span><br><span class="line">map.computeIfPresent(<span class="number">9</span>, (num, val) -&gt; <span class="keyword">null</span>);</span><br><span class="line">map.containsKey(<span class="number">9</span>);     <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">map.computeIfAbsent(<span class="number">23</span>, num -&gt; <span class="string">&quot;val&quot;</span> + num);</span><br><span class="line">map.containsKey(<span class="number">23</span>);    <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">map.computeIfAbsent(<span class="number">3</span>, num -&gt; <span class="string">&quot;bam&quot;</span>);</span><br><span class="line">map.get(<span class="number">3</span>);             <span class="comment">// val33</span></span><br></pre></td></tr></table></figure>

<p>接下来展示如何在Map里删除一个键值全都匹配的项：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">map.remove(<span class="number">3</span>, <span class="string">&quot;val3&quot;</span>);</span><br><span class="line">map.get(<span class="number">3</span>);             <span class="comment">// val33</span></span><br><span class="line">map.remove(<span class="number">3</span>, <span class="string">&quot;val33&quot;</span>);</span><br><span class="line">map.get(<span class="number">3</span>);             <span class="comment">// null</span></span><br></pre></td></tr></table></figure>

<p>另外一个有用的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">map.getOrDefault(<span class="number">42</span>, <span class="string">&quot;not found&quot;</span>);  <span class="comment">// not found</span></span><br></pre></td></tr></table></figure>

<p>对Map的元素做合并也变得很容易了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">map.merge(<span class="number">9</span>, <span class="string">&quot;val9&quot;</span>, (value, newValue) -&gt; value.concat(newValue));</span><br><span class="line">map.get(<span class="number">9</span>);             <span class="comment">// val9</span></span><br><span class="line">map.merge(<span class="number">9</span>, <span class="string">&quot;concat&quot;</span>, (value, newValue) -&gt; value.concat(newValue));</span><br><span class="line">map.get(<span class="number">9</span>);             <span class="comment">// val9concat</span></span><br></pre></td></tr></table></figure>

<p>Merge 做的事情是如果键名不存在则插入，否则则对原键对应的值做合并操作并重新插入到map中。</p>
<h2 id="Date-API-日期相关API"><a href="#Date-API-日期相关API" class="headerlink" title="Date API(日期相关API)"></a>Date API(日期相关API)</h2><p>Java 8在 <code>java.time</code> 包下包含一个全新的日期和时间API。新的Date API与Joda-Time库相似，但它们不一样。以下示例涵盖了此新 API 的最重要部分。译者对这部分内容参考相关书籍做了大部分修改。</p>
<p><strong>译者注(总结)：</strong></p>
<ul>
<li><p>Clock 类提供了访问当前日期和时间的方法，Clock 是时区敏感的，可以用来取代 <code>System.currentTimeMillis()</code> 来获取当前的微秒数。某一个特定的时间点也可以使用 <code>Instant</code> 类来表示，<code>Instant</code> 类也可以用来创建旧版本的<code>java.util.Date</code> 对象。</p>
</li>
<li><p>在新API中时区使用 ZoneId 来表示。时区可以很方便的使用静态方法of来获取到。 抽象类<code>ZoneId</code>（在<code>java.time</code>包中）表示一个区域标识符。 它有一个名为<code>getAvailableZoneIds</code>的静态方法，它返回所有区域标识符。</p>
</li>
<li><p>jdk1.8中新增了 LocalDate 与 LocalDateTime等类来解决日期处理方法，同时引入了一个新的类DateTimeFormatter 来解决日期格式化问题。可以使用Instant代替 Date，LocalDateTime代替 Calendar，DateTimeFormatter 代替 SimpleDateFormat。</p>
</li>
</ul>
<h3 id="Clock"><a href="#Clock" class="headerlink" title="Clock"></a>Clock</h3><p>Clock 类提供了访问当前日期和时间的方法，Clock 是时区敏感的，可以用来取代 <code>System.currentTimeMillis()</code> 来获取当前的微秒数。某一个特定的时间点也可以使用 <code>Instant</code> 类来表示，<code>Instant</code> 类也可以用来创建旧版本的<code>java.util.Date</code> 对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Clock clock = Clock.systemDefaultZone();</span><br><span class="line"><span class="keyword">long</span> millis = clock.millis();</span><br><span class="line">System.out.println(millis);<span class="comment">//1552379579043</span></span><br><span class="line">Instant instant = clock.instant();</span><br><span class="line">System.out.println(instant);</span><br><span class="line">Date legacyDate = Date.from(instant); <span class="comment">//2019-03-12T08:46:42.588Z</span></span><br><span class="line">System.out.println(legacyDate);<span class="comment">//Tue Mar 12 16:32:59 CST 2019</span></span><br></pre></td></tr></table></figure>

<h3 id="Timezones-时区"><a href="#Timezones-时区" class="headerlink" title="Timezones(时区)"></a>Timezones(时区)</h3><p>在新API中时区使用 ZoneId 来表示。时区可以很方便的使用静态方法of来获取到。 抽象类<code>ZoneId</code>（在<code>java.time</code>包中）表示一个区域标识符。 它有一个名为<code>getAvailableZoneIds</code>的静态方法，它返回所有区域标识符。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//输出所有区域标识符</span></span><br><span class="line">System.out.println(ZoneId.getAvailableZoneIds());</span><br><span class="line"></span><br><span class="line">ZoneId zone1 = ZoneId.of(<span class="string">&quot;Europe/Berlin&quot;</span>);</span><br><span class="line">ZoneId zone2 = ZoneId.of(<span class="string">&quot;Brazil/East&quot;</span>);</span><br><span class="line">System.out.println(zone1.getRules());<span class="comment">// ZoneRules[currentStandardOffset=+01:00]</span></span><br><span class="line">System.out.println(zone2.getRules());<span class="comment">// ZoneRules[currentStandardOffset=-03:00]</span></span><br></pre></td></tr></table></figure>

<h3 id="LocalTime-本地时间"><a href="#LocalTime-本地时间" class="headerlink" title="LocalTime(本地时间)"></a>LocalTime(本地时间)</h3><p>LocalTime 定义了一个没有时区信息的时间，例如 晚上10点或者 17:30:15。下面的例子使用前面代码创建的时区创建了两个本地时间。之后比较时间并以小时和分钟为单位计算两个时间的时间差：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalTime now1 = LocalTime.now(zone1);</span><br><span class="line">LocalTime now2 = LocalTime.now(zone2);</span><br><span class="line">System.out.println(now1.isBefore(now2));  <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> hoursBetween = ChronoUnit.HOURS.between(now1, now2);</span><br><span class="line"><span class="keyword">long</span> minutesBetween = ChronoUnit.MINUTES.between(now1, now2);</span><br><span class="line"></span><br><span class="line">System.out.println(hoursBetween);       <span class="comment">// -3</span></span><br><span class="line">System.out.println(minutesBetween);     <span class="comment">// -239</span></span><br></pre></td></tr></table></figure>

<p>LocalTime 提供了多种工厂方法来简化对象的创建，包括解析时间字符串.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalTime late = LocalTime.of(<span class="number">23</span>, <span class="number">59</span>, <span class="number">59</span>);</span><br><span class="line">System.out.println(late);       <span class="comment">// 23:59:59</span></span><br><span class="line">DateTimeFormatter germanFormatter =</span><br><span class="line">    DateTimeFormatter</span><br><span class="line">        .ofLocalizedTime(FormatStyle.SHORT)</span><br><span class="line">        .withLocale(Locale.GERMAN);</span><br><span class="line"></span><br><span class="line">LocalTime leetTime = LocalTime.parse(<span class="string">&quot;13:37&quot;</span>, germanFormatter);</span><br><span class="line">System.out.println(leetTime);   <span class="comment">// 13:37</span></span><br></pre></td></tr></table></figure>

<h3 id="LocalDate-本地日期"><a href="#LocalDate-本地日期" class="headerlink" title="LocalDate(本地日期)"></a>LocalDate(本地日期)</h3><p>LocalDate 表示了一个确切的日期，比如 2014-03-11。该对象值是不可变的，用起来和LocalTime基本一致。下面的例子展示了如何给Date对象加减天/月/年。另外要注意的是这些对象是不可变的，操作返回的总是一个新实例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalDate today = LocalDate.now();<span class="comment">//获取现在的日期</span></span><br><span class="line">System.out.println(<span class="string">&quot;今天的日期: &quot;</span>+today);<span class="comment">//2019-03-12</span></span><br><span class="line">LocalDate tomorrow = today.plus(<span class="number">1</span>, ChronoUnit.DAYS);</span><br><span class="line">System.out.println(<span class="string">&quot;明天的日期: &quot;</span>+tomorrow);<span class="comment">//2019-03-13</span></span><br><span class="line">LocalDate yesterday = tomorrow.minusDays(<span class="number">2</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;昨天的日期: &quot;</span>+yesterday);<span class="comment">//2019-03-11</span></span><br><span class="line">LocalDate independenceDay = LocalDate.of(<span class="number">2019</span>, Month.MARCH, <span class="number">12</span>);</span><br><span class="line">DayOfWeek dayOfWeek = independenceDay.getDayOfWeek();</span><br><span class="line">System.out.println(<span class="string">&quot;今天是周几:&quot;</span>+dayOfWeek);<span class="comment">//TUESDAY</span></span><br></pre></td></tr></table></figure>

<p>从字符串解析一个 LocalDate 类型和解析 LocalTime 一样简单,下面是使用  <code>DateTimeFormatter</code> 解析字符串的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str1 = <span class="string">&quot;2014==04==12 01时06分09秒&quot;</span>;</span><br><span class="line">    <span class="comment">// 根据需要解析的日期、时间字符串定义解析所用的格式器</span></span><br><span class="line">    DateTimeFormatter fomatter1 = DateTimeFormatter</span><br><span class="line">            .ofPattern(<span class="string">&quot;yyyy==MM==dd HH时mm分ss秒&quot;</span>);</span><br><span class="line"></span><br><span class="line">    LocalDateTime dt1 = LocalDateTime.parse(str1, fomatter1);</span><br><span class="line">    System.out.println(dt1); <span class="comment">// 输出 2014-04-12T01:06:09</span></span><br><span class="line"></span><br><span class="line">    String str2 = <span class="string">&quot;2014$$$四月$$$13 20小时&quot;</span>;</span><br><span class="line">    DateTimeFormatter fomatter2 = DateTimeFormatter</span><br><span class="line">            .ofPattern(<span class="string">&quot;yyy$$$MMM$$$dd HH小时&quot;</span>);</span><br><span class="line">    LocalDateTime dt2 = LocalDateTime.parse(str2, fomatter2);</span><br><span class="line">    System.out.println(dt2); <span class="comment">// 输出 2014-04-13T20:00</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>再来看一个使用 <code>DateTimeFormatter</code> 格式化日期的示例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalDateTime rightNow=LocalDateTime.now();</span><br><span class="line">String date=DateTimeFormatter.ISO_LOCAL_DATE_TIME.format(rightNow);</span><br><span class="line">System.out.println(date);<span class="comment">//2019-03-12T16:26:48.29</span></span><br><span class="line">DateTimeFormatter formatter=DateTimeFormatter.ofPattern(<span class="string">&quot;YYYY-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">System.out.println(formatter.format(rightNow));<span class="comment">//2019-03-12 16:26:48</span></span><br></pre></td></tr></table></figure>

<h3 id="LocalDateTime-本地日期时间"><a href="#LocalDateTime-本地日期时间" class="headerlink" title="LocalDateTime(本地日期时间)"></a>LocalDateTime(本地日期时间)</h3><p>LocalDateTime 同时表示了时间和日期，相当于前两节内容合并到一个对象上了。LocalDateTime 和 LocalTime还有 LocalDate 一样，都是不可变的。LocalDateTime 提供了一些能访问具体字段的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalDateTime sylvester = LocalDateTime.of(<span class="number">2014</span>, Month.DECEMBER, <span class="number">31</span>, <span class="number">23</span>, <span class="number">59</span>, <span class="number">59</span>);</span><br><span class="line"></span><br><span class="line">DayOfWeek dayOfWeek = sylvester.getDayOfWeek();</span><br><span class="line">System.out.println(dayOfWeek);      <span class="comment">// WEDNESDAY</span></span><br><span class="line"></span><br><span class="line">Month month = sylvester.getMonth();</span><br><span class="line">System.out.println(month);          <span class="comment">// DECEMBER</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> minuteOfDay = sylvester.getLong(ChronoField.MINUTE_OF_DAY);</span><br><span class="line">System.out.println(minuteOfDay);    <span class="comment">// 1439</span></span><br></pre></td></tr></table></figure>

<p>只要附加上时区信息，就可以将其转换为一个时间点Instant对象，Instant时间点对象可以很容易的转换为老式的<code>java.util.Date</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Instant instant = sylvester</span><br><span class="line">        .atZone(ZoneId.systemDefault())</span><br><span class="line">        .toInstant();</span><br><span class="line"></span><br><span class="line">Date legacyDate = Date.from(instant);</span><br><span class="line">System.out.println(legacyDate);     <span class="comment">// Wed Dec 31 23:59:59 CET 2014</span></span><br></pre></td></tr></table></figure>

<p>格式化LocalDateTime和格式化时间和日期一样的，除了使用预定义好的格式外，我们也可以自己定义格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DateTimeFormatter formatter =</span><br><span class="line">    DateTimeFormatter</span><br><span class="line">        .ofPattern(<span class="string">&quot;MMM dd, yyyy - HH:mm&quot;</span>);</span><br><span class="line">LocalDateTime parsed = LocalDateTime.parse(<span class="string">&quot;Nov 03, 2014 - 07:13&quot;</span>, formatter);</span><br><span class="line">String string = formatter.format(parsed);</span><br><span class="line">System.out.println(string);     <span class="comment">// Nov 03, 2014 - 07:13</span></span><br></pre></td></tr></table></figure>

<p>和java.text.NumberFormat不一样的是新版的DateTimeFormatter是不可变的，所以它是线程安全的。<br>关于时间日期格式的详细信息在<a href="https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html">这里</a>。</p>
<h2 id="Annotations-注解"><a href="#Annotations-注解" class="headerlink" title="Annotations(注解)"></a>Annotations(注解)</h2><p>在Java 8中支持多重注解了，先看个例子来理解一下是什么意思。<br>首先定义一个包装类Hints注解用来放置一组具体的Hint注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@interface</span> Hints &#123;</span><br><span class="line">    Hint[] value();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Repeatable(Hints.class)</span></span><br><span class="line"><span class="meta">@interface</span> Hint &#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java 8允许我们把同一个类型的注解使用多次，只需要给该注解标注一下<code>@Repeatable</code>即可。</p>
<p>例 1: 使用包装类当容器来存多个注解（老方法）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Hints(&#123;@Hint(&quot;hint1&quot;), @Hint(&quot;hint2&quot;)&#125;)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>例 2：使用多重注解（新方法）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Hint(&quot;hint1&quot;)</span></span><br><span class="line"><span class="meta">@Hint(&quot;hint2&quot;)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>第二个例子里java编译器会隐性的帮你定义好@Hints注解，了解这一点有助于你用反射来获取这些信息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Hint hint = Person.class.getAnnotation(Hint.class);</span><br><span class="line">System.out.println(hint);                   <span class="comment">// null</span></span><br><span class="line">Hints hints1 = Person.class.getAnnotation(Hints.class);</span><br><span class="line">System.out.println(hints1.value().length);  <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">Hint[] hints2 = Person.class.getAnnotationsByType(Hint.class);</span><br><span class="line">System.out.println(hints2.length);          <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>即便我们没有在 <code>Person</code>类上定义 <code>@Hints</code>注解，我们还是可以通过 <code>getAnnotation(Hints.class) </code>来获取 <code>@Hints</code>注解，更加方便的方法是使用 <code>getAnnotationsByType</code> 可以直接获取到所有的<code>@Hint</code>注解。<br>另外Java 8的注解还增加到两种新的target上了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE_PARAMETER, ElementType.TYPE_USE&#125;)</span></span><br><span class="line"><span class="meta">@interface</span> MyAnnotation &#123;&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>面试</category>
        <category>Java</category>
        <category>笔记</category>
      </categories>
  </entry>
  <entry>
    <title>Java后端面试笔记-SQL</title>
    <url>/2021/03/10/Java%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AE%B0-SQL/</url>
    <content><![CDATA[<h1 id="SQL相关"><a href="#SQL相关" class="headerlink" title="SQL相关"></a>SQL相关</h1><h2 id="1-什么是索引？-MySQL中的索引"><a href="#1-什么是索引？-MySQL中的索引" class="headerlink" title="1.什么是索引？ MySQL中的索引"></a>1.什么是索引？ MySQL中的索引</h2><p><strong>索引是一种用于快速查询和检索数据的数据结构。常见的索引结构有: B 树， B+树和 Hash。</strong></p>
<p>索引的作用就相当于目录的作用。打个比方: 我们在查字典的时候，如果没有目录，那我们就只能一页一页的去找我们需要查的那个字，速度很慢。如果有目录了，我们只需要先去目录里查找字的位置，然后直接翻到那一页就行了。</p>
<p>MySQL索引使用的数据结构主要有<strong>BTree索引</strong> 和 <strong>哈希索引</strong> 。对于哈希索引来说，底层的数据结构就是哈希表，因此在绝大多数需求为单条记录查询的时候，可以选择哈希索引，查询性能最快；其余大部分场景，建议选择BTree索引。</p>
<p>MySQL的BTree索引使用的是B树中的B+Tree，但对于主要的两种存储引擎的实现方式是不同的。</p>
<ul>
<li><p><strong>MyISAM:</strong> B+Tree叶节点的data域存放的是数据记录的地址。在索引检索的时候，首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其 data 域的值，然后以 data 域的值为地址读取相应的数据记录。这被称为“非聚簇索引”。</p>
</li>
<li><p><strong>InnoDB:</strong> 其数据文件本身就是索引文件。相比MyISAM，索引文件和数据文件是分离的，其表数据文件本身就是按B+Tree组织的一个索引结构，树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。这被称为“聚簇索引（或聚集索引）”。而其余的索引都作为辅助索引，辅助索引的data域存储相应记录主键的值而不是地址，这也是和MyISAM不同的地方。<strong>在根据主索引搜索时，直接找到key所在的节点即可取出数据；在根据辅助索引查找时，则需要先取出主键的值，再走一遍主索引。</strong> <strong>因此，在设计表的时候，不建议使用过长的字段作为主键，也不建议使用非单调的字段作为主键，这样会造成主索引频繁分裂。</strong> </p>
<a id="more"></a>

</li>
</ul>
<h2 id="2-索引的优缺点"><a href="#2-索引的优缺点" class="headerlink" title="2.索引的优缺点"></a>2.索引的优缺点</h2><h3 id="索引的优点"><a href="#索引的优点" class="headerlink" title="索引的优点"></a>索引的优点</h3><p><strong>可以大大加快 数据的检索速度（大大减少的检索的数据量）, 这也是创建索引的最主要的原因。毕竟大部分系统的读请求总是大于写请求的。</strong> 另外，通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。</p>
<h3 id="索引的缺点"><a href="#索引的缺点" class="headerlink" title="索引的缺点"></a>索引的缺点</h3><ol>
<li><strong>创建索引和维护索引需要耗费许多时间</strong>：当对表中的数据进行增删改的时候，如果数据有索引，那么索引也需要动态的修改，会降低 SQL 执行效率。</li>
<li><strong>占用物理存储空间</strong> ：索引需要使用物理文件存储，也会耗费一定空间。</li>
</ol>
<h2 id="3-索引创建的原则"><a href="#3-索引创建的原则" class="headerlink" title="3.索引创建的原则"></a>3.索引创建的原则</h2><h3 id="单列索引"><a href="#单列索引" class="headerlink" title="单列索引"></a>单列索引</h3><p>单列索引即由一列属性组成的索引。</p>
<h3 id="联合索引-多列索引"><a href="#联合索引-多列索引" class="headerlink" title="联合索引(多列索引)"></a>联合索引(多列索引)</h3><p>联合索引即由多列属性组成索引。</p>
<h3 id="最左前缀原则"><a href="#最左前缀原则" class="headerlink" title="最左前缀原则"></a>最左前缀原则</h3><p>假设创建的联合索引由三个字段组成:</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">ALTER TABLE table ADD INDEX index_name (num,name,age)</span><br></pre></td></tr></table></figure>

<p>那么当查询的条件有为:num / (num AND name) / (num AND name AND age)时，索引才生效。所以在创建联合索引时，尽量把查询最频繁的那个字段作为最左(第一个)字段。查询的时候也尽量以这个字段为第一条件。</p>
<h2 id="4-聚集索引与非聚集索引"><a href="#4-聚集索引与非聚集索引" class="headerlink" title="4.聚集索引与非聚集索引"></a>4.聚集索引与非聚集索引</h2><h3 id="聚集索引"><a href="#聚集索引" class="headerlink" title="聚集索引"></a>聚集索引</h3><p><strong>聚集索引即索引结构和数据一起存放的索引。主键索引属于聚集索引。</strong></p>
<p>在 Mysql 中，InnoDB 引擎的表的 <code>.ibd</code>文件就包含了该表的索引和数据，对于 InnoDB 引擎表来说，该表的索引(B+树)的每个非叶子节点存储索引，叶子节点存储索引和索引对应的数据。</p>
<h4 id="聚集索引的优点"><a href="#聚集索引的优点" class="headerlink" title="聚集索引的优点"></a>聚集索引的优点</h4><p>聚集索引的查询速度非常的快，因为整个 B+树本身就是一颗多叉平衡树，叶子节点也都是有序的，定位到索引的节点，就相当于定位到了数据。</p>
<h4 id="聚集索引的缺点"><a href="#聚集索引的缺点" class="headerlink" title="聚集索引的缺点"></a>聚集索引的缺点</h4><ol>
<li><strong>依赖于有序的数据</strong> ：因为 B+树是多路平衡树，如果索引的数据不是有序的，那么就需要在插入时排序，如果数据是整型还好，否则类似于字符串或 UUID 这种又长又难比较的数据，插入或查找的速度肯定比较慢。</li>
<li><strong>更新代价大</strong> ： 如果对索引列的数据被修改时，那么对应的索引也将会被修改，<br>而且况聚集索引的叶子节点还存放着数据，修改代价肯定是较大的，<br>所以对于主键索引来说，主键一般都是不可被修改的。</li>
</ol>
<h3 id="非聚集索引"><a href="#非聚集索引" class="headerlink" title="非聚集索引"></a>非聚集索引</h3><p><strong>非聚集索引即索引结构和数据分开存放的索引。</strong></p>
<p><strong>二级索引属于非聚集索引。</strong></p>
<blockquote>
<p>MYISAM 引擎的表的.MYI 文件包含了表的索引，<br>该表的索引(B+树)的每个叶子非叶子节点存储索引，<br>叶子节点存储索引和索引对应数据的指针，指向.MYD 文件的数据。</p>
<p><strong>非聚集索引的叶子节点并不一定存放数据的指针，<br>因为二级索引的叶子节点就存放的是主键，根据主键再回表查数据。</strong></p>
</blockquote>
<h4 id="非聚集索引的优点"><a href="#非聚集索引的优点" class="headerlink" title="非聚集索引的优点"></a>非聚集索引的优点</h4><p><strong>更新代价比聚集索引要小</strong> 。非聚集索引的更新代价就没有聚集索引那么大了，非聚集索引的叶子节点是不存放数据的</p>
<h4 id="非聚集索引的缺点"><a href="#非聚集索引的缺点" class="headerlink" title="非聚集索引的缺点"></a>非聚集索引的缺点</h4><ol>
<li>跟聚集索引一样，非聚集索引也依赖于有序的数据</li>
<li><strong>可能会二次查询(回表)</strong> :这应该是非聚集索引最大的缺点了。 当查到索引对应的指针或主键后，可能还需要根据指针或主键再到数据文件或表中查询。</li>
</ol>
<h2 id="5-覆盖索引"><a href="#5-覆盖索引" class="headerlink" title="5.覆盖索引"></a>5.覆盖索引</h2><p>如果一个索引包含（或者说覆盖）所有需要查询的字段的值，我们就称之为“覆盖索引”。我们知道在 InnoDB 存储引擎中，如果不是主键索引，叶子节点存储的是主键+列值。最终还是要“回表”，也就是要通过主键再查找一次。这样就会比较慢覆盖索引就是把要查询出的列和索引是对应的，不做回表操作！</p>
<p><strong>覆盖索引即需要查询的字段正好是索引的字段，那么直接根据该索引，就可以查到数据了，而无需回表查询。</strong></p>
<blockquote>
<p>如主键索引，如果一条 SQL 需要查询主键，那么正好根据主键索引就可以查到主键。</p>
<p>再如普通索引，如果一条 SQL 需要查询 name，name 字段正好有索引，<br>那么直接根据这个索引就可以查到数据，也无需回表。</p>
</blockquote>
<h2 id="6-事务的含义与特性-ACID"><a href="#6-事务的含义与特性-ACID" class="headerlink" title="6.事务的含义与特性(ACID)"></a>6.事务的含义与特性(ACID)</h2><p>事务是逻辑上的一组操作，要么都执行，要么都不执行。</p>
<p>事务最经典也经常被拿出来说例子就是转账了。假如小明要给小红转账1000元，这个转账会涉及到两个关键操作就是：将小明的余额减少1000元，将小红的余额增加1000元。万一在这两个操作之间突然出现错误比如银行系统崩溃，导致小明余额减少而小红的余额没有增加，这样就不对了。事务就是保证这两个关键操作要么都成功，要么都要失败。</p>
<p><img src="https://plutowu-blogimgs.oss-cn-guangzhou.aliyuncs.com/img/20210310193336.png"></p>
<ol>
<li> <strong>原子性：</strong> 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</li>
<li> <strong>一致性：</strong> 执行事务前后，数据保持一致，例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的；</li>
<li> <strong>隔离性：</strong> 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；</li>
<li> <strong>持久性：</strong> 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</li>
</ol>
<h2 id="7-并发事务带来的问题"><a href="#7-并发事务带来的问题" class="headerlink" title="7.并发事务带来的问题"></a>7.并发事务带来的问题</h2><p>在典型的应用程序中，多个事务并发运行，经常会操作相同的数据来完成各自的任务（多个用户对统一数据进行操作）。并发虽然是必须的，但可能会导致以下的问题。</p>
<ul>
<li><strong>脏读（Dirty read）:</strong> 当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。</li>
<li><strong>丢失修改（Lost to modify）:</strong> 指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。    例如：事务1读取某表中的数据A=20，事务2也读取A=20，事务1修改A=A-1，事务2也修改A=A-1，最终结果A=19，事务1的修改被丢失。</li>
<li><strong>不可重复读（Unrepeatableread）:</strong> 指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。</li>
<li><strong>幻读（Phantom read）:</strong> 幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。</li>
</ul>
<p><strong>不可重复度和幻读区别：</strong></p>
<p>不可重复读的重点是修改，幻读的重点在于新增或者删除。</p>
<p>例1（同样的条件, 你读取过的数据, 再次读取出来发现值不一样了）：事务1中的A先生读取自己的工资为1000的操作还没完成，事务2中的B先生就修改了A的工资为2000，导致A再读自己的工资时工资变为  2000；这就是不可重复读。</p>
<p> 例2（同样的条件, 第1次和第2次读出来的记录数不一样 ）：假某工资单表中工资大于3000的有4人，事务1读取了所有工资大于3000的人，共查到4条记录，这时事务2又插入了一条工资大于3000的记录，事务1再次读取时查到的记录就变为了5条，这样就导致了幻读。</p>
<h2 id="8-事务隔离级别"><a href="#8-事务隔离级别" class="headerlink" title="8.事务隔离级别"></a>8.事务隔离级别</h2><p><strong>SQL 标准定义了四个隔离级别：</strong></p>
<ul>
<li><strong>READ-UNCOMMITTED(读取未提交)：</strong> 最低的隔离级别，允许读取尚未提交的数据变更，<strong>可能会导致脏读、幻读或不可重复读</strong>。</li>
<li><strong>READ-COMMITTED(读取已提交)：</strong> 允许读取并发事务已经提交的数据，<strong>可以阻止脏读，但是幻读或不可重复读仍有可能发生</strong>。</li>
<li><strong>REPEATABLE-READ(可重复读)：</strong>  对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，<strong>可以阻止脏读和不可重复读，但幻读仍有可能发生</strong>。</li>
<li><strong>SERIALIZABLE(可串行化)：</strong> 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，<strong>该级别可以防止脏读、不可重复读以及幻读</strong>。</li>
</ul>
<table>
<thead>
<tr>
<th align="center">隔离级别</th>
<th align="center">脏读</th>
<th align="center">不可重复读</th>
<th align="center">幻影读</th>
</tr>
</thead>
<tbody><tr>
<td align="center">READ-UNCOMMITTED</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center">READ-COMMITTED</td>
<td align="center">×</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center">REPEATABLE-READ</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center">SERIALIZABLE</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">×</td>
</tr>
</tbody></table>
<p>MySQL InnoDB 存储引擎的默认支持的隔离级别是 <strong>REPEATABLE-READ（可重读）</strong></p>
<p>这里需要注意的是：与 SQL 标准不同的地方在于InnoDB 存储引擎在 <strong>REPEATABLE-READ（可重读）</strong> 事务隔离级别下，允许应用使用 Next-Key Lock 锁算法来避免幻读的产生。这与其他数据库系统(如 SQL Server)是不同的。所以说虽然 InnoDB 存储引擎的默认支持的隔离级别是 <strong>REPEATABLE-READ（可重读）</strong> ，但是可以通过应用加锁读（例如 <code>select * from table for update</code> 语句）来保证不会产生幻读，而这个加锁度使用到的机制就是 Next-Key Lock 锁算法。从而达到了 SQL 标准的 <strong>SERIALIZABLE(可串行化)</strong> 隔离级别。</p>
<p>因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是<strong>READ-COMMITTED(读取提交内容):**，但是你要知道的是InnoDB 存储引擎默认使用 **REPEATABLE-READ（可重读）</strong> 并不会有任何性能损失。</p>
<p>InnoDB 存储引擎在 <strong>分布式事务</strong> 的情况下一般会用到<strong>SERIALIZABLE(可串行化)</strong> 隔离级别。</p>
<h2 id="9-Redis简单介绍"><a href="#9-Redis简单介绍" class="headerlink" title="9.Redis简单介绍"></a>9.Redis简单介绍</h2><p>简单来说 <strong>Redis 就是一个使用 C 语言开发的数据库</strong>，不过与传统数据库不同的是 <strong>Redis 的数据是存在内存中的</strong> ，也就是它是内存数据库，所以读写速度非常快，因此 Redis 被广泛应用于缓存方向。</p>
<p>另外，<strong>Redis 除了做缓存之外，Redis 也经常用来做分布式锁，甚至是消息队列。</strong></p>
<p><strong>Redis 提供了多种数据类型来支持不同的业务场景。Redis 还支持事务 、持久化、Lua 脚本、多种集群方案。</strong></p>
<p><strong>采用Redis或缓存是因为“高性能”和“高并发”</strong></p>
<h2 id="10-Redis-和-Memcached-的区别和共同点"><a href="#10-Redis-和-Memcached-的区别和共同点" class="headerlink" title="10.Redis 和 Memcached 的区别和共同点"></a>10.Redis 和 Memcached 的区别和共同点</h2><p><strong>共同点</strong> ：</p>
<ol>
<li>都是基于内存的数据库，一般都用来当做缓存使用。</li>
<li>都有过期策略。</li>
<li>两者的性能都非常高。</li>
</ol>
<p><strong>区别</strong> ：</p>
<ol>
<li><strong>Redis 支持更丰富的数据类型（支持更复杂的应用场景）</strong>。Redis 不仅仅支持简单的 k/v 类型的数据，同时还提供 list，set，zset，hash 等数据结构的存储。Memcached 只支持最简单的 k/v 数据类型。</li>
<li><strong>Redis 支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用,而 Memcached 把数据全部存在内存之中。</strong></li>
<li><strong>Redis 有灾难恢复机制。</strong> 因为可以把缓存中的数据持久化到磁盘上。</li>
<li><strong>Redis 在服务器内存使用完之后，可以将不用的数据放到磁盘上。但是，Memcached 在服务器内存使用完之后，就会直接报异常。</strong></li>
<li><strong>Memcached 没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据；但是 Redis 目前是原生支持 cluster 模式的.</strong></li>
<li><strong>Memcached 是多线程，非阻塞 IO 复用的网络模型；Redis 使用单线程的多路 IO 复用模型。</strong> （Redis 6.0 引入了多线程 IO ）</li>
<li><strong>Redis 支持发布订阅模型、Lua 脚本、事务等功能，而 Memcached 不支持。并且，Redis 支持更多的编程语言。</strong></li>
<li><strong>Memcached过期数据的删除策略只用了惰性删除，而 Redis 同时使用了惰性删除与定期删除。</strong></li>
</ol>
<h2 id="11-Redis常见数据结构"><a href="#11-Redis常见数据结构" class="headerlink" title="11.Redis常见数据结构"></a>11.Redis常见数据结构</h2><h3 id="11-1-string"><a href="#11-1-string" class="headerlink" title="11.1. string"></a>11.1. string</h3><ol>
<li><strong>介绍</strong> ：string 数据结构是简单的 key-value 类型。虽然 Redis 是用 C 语言写的，但是 Redis 并没有使用 C 的字符串表示，而是自己构建了一种 <strong>简单动态字符串</strong>（simple dynamic string，<strong>SDS</strong>）。相比于 C 的原生字符串，Redis 的 SDS 不光可以保存文本数据还可以保存二进制数据，并且获取字符串长度复杂度为 O(1)（C 字符串为 O(N)）,除此之外,Redis 的 SDS API 是安全的，不会造成缓冲区溢出。</li>
<li><strong>常用命令:</strong> <code>set,get,strlen,exists,dect,incr,setex</code> 等等。</li>
<li><strong>应用场景</strong> ：一般常用在需要计数的场景，比如用户的访问次数、热点文章的点赞转发数量等等。</li>
</ol>
<p>下面我们简单看看它的使用！</p>
<p><strong>普通字符串的基本操作：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> key value <span class="comment">#设置 key-value 类型的值</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get key <span class="comment"># 根据 key 获得对应的 value</span></span><br><span class="line"><span class="string">&quot;value&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; exists key  <span class="comment"># 判断某个 key 是否存在</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; strlen key <span class="comment"># 返回 key 所储存的字符串值的长度。</span></span><br><span class="line">(<span class="built_in">integer</span>) 5</span><br><span class="line">127.0.0.1:6379&gt; del key <span class="comment"># 删除某个 key 对应的值</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; get key</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure>

<p><strong>批量设置</strong> :</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; mset key1 value1 key2 value2 <span class="comment"># 批量设置 key-value 类型的值</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; mget key1 key2 <span class="comment"># 批量获取多个 key 对应的 value</span></span><br><span class="line">1) <span class="string">&quot;value1&quot;</span></span><br><span class="line">2) <span class="string">&quot;value2&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>计数器（字符串的内容为整数的时候可以使用）：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> number 1</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; incr number <span class="comment"># 将 key 中储存的数字值增一</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; get number</span><br><span class="line"><span class="string">&quot;2&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; decr number <span class="comment"># 将 key 中储存的数字值减一</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; get number</span><br><span class="line"><span class="string">&quot;1&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>过期</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; expire key  60 <span class="comment"># 数据在 60s 后过期</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; setex key 60 value <span class="comment"># 数据在 60s 后过期 (setex:[set] + [ex]pire)</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; ttl key <span class="comment"># 查看数据还有多久过期</span></span><br><span class="line">(<span class="built_in">integer</span>) 56</span><br></pre></td></tr></table></figure>

<h3 id="11-2-list"><a href="#11-2-list" class="headerlink" title="11.2. list"></a>11.2. list</h3><ol>
<li><strong>介绍</strong> ：<strong>list</strong> 即是 <strong>链表</strong>。链表是一种非常常见的数据结构，特点是易于数据元素的插入和删除并且且可以灵活调整链表长度，但是链表的随机访问困难。许多高级编程语言都内置了链表的实现比如 Java 中的 <strong>LinkedList</strong>，但是 C 语言并没有实现链表，所以 Redis 实现了自己的链表数据结构。Redis 的 list 的实现为一个 <strong>双向链表</strong>，即可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销。</li>
<li><strong>常用命令:</strong> <code>rpush,lpop,lpush,rpop,lrange、llen</code> 等。</li>
<li><strong>应用场景:</strong> 发布与订阅或者说消息队列、慢查询。</li>
</ol>
<p>下面我们简单看看它的使用！</p>
<p><strong>通过 <code>rpush/lpop</code> 实现队列：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; rpush myList value1 <span class="comment"># 向 list 的头部（右边）添加元素</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; rpush myList value2 value3 <span class="comment"># 向list的头部（最右边）添加多个元素</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; lpop myList <span class="comment"># 将 list的尾部(最左边)元素取出</span></span><br><span class="line"><span class="string">&quot;value1&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; lrange myList 0 1 <span class="comment"># 查看对应下标的list列表， 0 为 start,1为 end</span></span><br><span class="line">1) <span class="string">&quot;value2&quot;</span></span><br><span class="line">2) <span class="string">&quot;value3&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; lrange myList 0 -1 <span class="comment"># 查看列表中的所有元素，-1表示倒数第一</span></span><br><span class="line">1) <span class="string">&quot;value2&quot;</span></span><br><span class="line">2) <span class="string">&quot;value3&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>通过 <code>rpush/rpop</code> 实现栈：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; rpush myList2 value1 value2 value3</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; rpop myList2 <span class="comment"># 将 list的头部(最右边)元素取出</span></span><br><span class="line"><span class="string">&quot;value3&quot;</span></span><br></pre></td></tr></table></figure>

<p>我专门花了一个图方便小伙伴们来理解：</p>
<p><img src="https://plutowu-blogimgs.oss-cn-guangzhou.aliyuncs.com/img/redis-list.png" alt="redis list"></p>
<p><strong>通过 <code>lrange</code> 查看对应下标范围的列表元素：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; rpush myList value1 value2 value3</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; lrange myList 0 1 <span class="comment"># 查看对应下标的list列表， 0 为 start,1为 end</span></span><br><span class="line">1) <span class="string">&quot;value1&quot;</span></span><br><span class="line">2) <span class="string">&quot;value2&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; lrange myList 0 -1 <span class="comment"># 查看列表中的所有元素，-1表示倒数第一</span></span><br><span class="line">1) <span class="string">&quot;value1&quot;</span></span><br><span class="line">2) <span class="string">&quot;value2&quot;</span></span><br><span class="line">3) <span class="string">&quot;value3&quot;</span></span><br></pre></td></tr></table></figure>

<p>通过 <code>lrange</code> 命令，你可以基于 list 实现分页查询，性能非常高！</p>
<p><strong>通过 <code>llen</code> 查看链表长度：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; llen myList</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br></pre></td></tr></table></figure>

<h3 id="11-3-hash"><a href="#11-3-hash" class="headerlink" title="11.3. hash"></a>11.3. hash</h3><ol>
<li><strong>介绍</strong> ：hash 类似于 JDK1.8 前的 HashMap，内部实现也差不多(数组 + 链表)。不过，Redis 的 hash 做了更多优化。另外，hash 是一个 string 类型的 field 和 value 的映射表，<strong>特别适合用于存储对象</strong>，后续操作的时候，你可以直接仅仅修改这个对象中的某个字段的值。 比如我们可以 hash 数据结构来存储用户信息，商品信息等等。</li>
<li><strong>常用命令：</strong> <code>hset,hmset,hexists,hget,hgetall,hkeys,hvals</code> 等。</li>
<li><strong>应用场景:</strong> 系统中对象数据的存储。</li>
</ol>
<p>下面我们简单看看它的使用！</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hset userInfoKey name <span class="string">&quot;guide&quot;</span> description <span class="string">&quot;dev&quot;</span> age <span class="string">&quot;24&quot;</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; hexists userInfoKey name <span class="comment"># 查看 key 对应的 value中指定的字段是否存在。</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; hget userInfoKey name <span class="comment"># 获取存储在哈希表中指定字段的值。</span></span><br><span class="line"><span class="string">&quot;guide&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; hget userInfoKey age</span><br><span class="line"><span class="string">&quot;24&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; hgetall userInfoKey <span class="comment"># 获取在哈希表中指定 key 的所有字段和值</span></span><br><span class="line">1) <span class="string">&quot;name&quot;</span></span><br><span class="line">2) <span class="string">&quot;guide&quot;</span></span><br><span class="line">3) <span class="string">&quot;description&quot;</span></span><br><span class="line">4) <span class="string">&quot;dev&quot;</span></span><br><span class="line">5) <span class="string">&quot;age&quot;</span></span><br><span class="line">6) <span class="string">&quot;24&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; hkeys userInfoKey <span class="comment"># 获取 key 列表</span></span><br><span class="line">1) <span class="string">&quot;name&quot;</span></span><br><span class="line">2) <span class="string">&quot;description&quot;</span></span><br><span class="line">3) <span class="string">&quot;age&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; hvals userInfoKey <span class="comment"># 获取 value 列表</span></span><br><span class="line">1) <span class="string">&quot;guide&quot;</span></span><br><span class="line">2) <span class="string">&quot;dev&quot;</span></span><br><span class="line">3) <span class="string">&quot;24&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; hset userInfoKey name <span class="string">&quot;GuideGeGe&quot;</span> <span class="comment"># 修改某个字段对应的值</span></span><br><span class="line">127.0.0.1:6379&gt; hget userInfoKey name</span><br><span class="line"><span class="string">&quot;GuideGeGe&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="11-4-set"><a href="#11-4-set" class="headerlink" title="11.4. set"></a>11.4. set</h3><ol>
<li><strong>介绍 ：</strong> set 类似于 Java 中的 <code>HashSet</code> 。Redis 中的 set 类型是一种无序集合，集合中的元素没有先后顺序。当你需要存储一个列表数据，又不希望出现重复数据时，set 是一个很好的选择，并且 set 提供了判断某个成员是否在一个 set 集合内的重要接口，这个也是 list 所不能提供的。可以基于 set 轻易实现交集、并集、差集的操作。比如：你可以将一个用户所有的关注人存在一个集合中，将其所有粉丝存在一个集合。Redis 可以非常方便的实现如共同关注、共同粉丝、共同喜好等功能。这个过程也就是求交集的过程。</li>
<li><strong>常用命令：</strong> <code>sadd,spop,smembers,sismember,scard,sinterstore,sunion</code> 等。</li>
<li><strong>应用场景:</strong> 需要存放的数据不能重复以及需要获取多个数据源交集和并集等场景</li>
</ol>
<p>下面我们简单看看它的使用！</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sadd mySet value1 value2 <span class="comment"># 添加元素进去</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; sadd mySet value1 <span class="comment"># 不允许有重复元素</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; smembers mySet <span class="comment"># 查看 set 中所有的元素</span></span><br><span class="line">1) <span class="string">&quot;value1&quot;</span></span><br><span class="line">2) <span class="string">&quot;value2&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; scard mySet <span class="comment"># 查看 set 的长度</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; sismember mySet value1 <span class="comment"># 检查某个元素是否存在set 中，只能接收单个元素</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd mySet2 value2 value3</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; sinterstore mySet3 mySet mySet2 <span class="comment"># 获取 mySet 和 mySet2 的交集并存放在 mySet3 中</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; smembers mySet3</span><br><span class="line">1) <span class="string">&quot;value2&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="11-5-sorted-set"><a href="#11-5-sorted-set" class="headerlink" title="11.5. sorted set"></a>11.5. sorted set</h3><ol>
<li><strong>介绍：</strong> 和 set 相比，sorted set 增加了一个权重参数 score，使得集合中的元素能够按 score 进行有序排列，还可以通过 score 的范围来获取元素的列表。有点像是 Java 中 HashMap 和 TreeSet 的结合体。</li>
<li><strong>常用命令：</strong> <code>zadd,zcard,zscore,zrange,zrevrange,zrem</code> 等。</li>
<li><strong>应用场景：</strong> 需要对数据根据某个权重进行排序的场景。比如在直播系统中，实时排行信息包含直播间在线用户列表，各种礼物排行榜，弹幕消息（可以理解为按消息维度的消息排行榜）等信息。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zadd myZset 3.0 value1 <span class="comment"># 添加元素到 sorted set 中 3.0 为权重</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; zadd myZset 2.0 value2 1.0 value3 <span class="comment"># 一次添加多个元素</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; zcard myZset <span class="comment"># 查看 sorted set 中的元素数量</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; zscore myZset value1 <span class="comment"># 查看某个 value 的权重</span></span><br><span class="line"><span class="string">&quot;3&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; zrange  myZset 0 -1 <span class="comment"># 顺序输出某个范围区间的元素，0 -1 表示输出所有元素</span></span><br><span class="line">1) <span class="string">&quot;value3&quot;</span></span><br><span class="line">2) <span class="string">&quot;value2&quot;</span></span><br><span class="line">3) <span class="string">&quot;value1&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; zrange  myZset 0 1 <span class="comment"># 顺序输出某个范围区间的元素，0 为 start  1 为 stop</span></span><br><span class="line">1) <span class="string">&quot;value3&quot;</span></span><br><span class="line">2) <span class="string">&quot;value2&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; zrevrange  myZset 0 1 <span class="comment"># 逆序输出某个范围区间的元素，0 为 start  1 为 stop</span></span><br><span class="line">1) <span class="string">&quot;value1&quot;</span></span><br><span class="line">2) <span class="string">&quot;value2&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="12-Redis-内存淘汰机制"><a href="#12-Redis-内存淘汰机制" class="headerlink" title="12. Redis 内存淘汰机制"></a>12. Redis 内存淘汰机制</h2><blockquote>
<p>相关问题：MySQL 里有 2000w 数据，Redis 中只存 20w 的数据，如何保证 Redis 中的数据都是热点数据?</p>
</blockquote>
<p>Redis 提供 6 种数据淘汰策略：</p>
<ol>
<li><strong>volatile-lru（least recently used）</strong>：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰</li>
<li><strong>volatile-ttl</strong>：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰</li>
<li><strong>volatile-random</strong>：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰</li>
<li><strong>allkeys-lru（least recently used）</strong>：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 key（这个是最常用的）</li>
<li><strong>allkeys-random</strong>：从数据集（server.db[i].dict）中任意选择数据淘汰</li>
<li><strong>no-eviction</strong>：禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。这个应该没人使用吧！</li>
</ol>
<p>4.0 版本后增加以下两种：</p>
<ol start="7">
<li><strong>volatile-lfu（least frequently used）</strong>：从已设置过期时间的数据集(server.db[i].expires)中挑选最不经常使用的数据淘汰</li>
<li><strong>allkeys-lfu（least frequently used）</strong>：当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的 key</li>
</ol>
<h2 id="13-缓存穿透"><a href="#13-缓存穿透" class="headerlink" title="13.缓存穿透"></a>13.缓存穿透</h2><h3 id="13-1-什么是缓存穿透？"><a href="#13-1-什么是缓存穿透？" class="headerlink" title="13.1. 什么是缓存穿透？"></a>13.1. 什么是缓存穿透？</h3><p>缓存穿透说简单点就是大量请求的 key 根本不存在于缓存中，导致请求直接到了数据库上，根本没有经过缓存这一层。举个例子：某个黑客故意制造我们缓存中不存在的 key 发起大量请求，导致大量请求落到数据库。</p>
<h3 id="13-2-缓存穿透情况的处理流程是怎样的？"><a href="#13-2-缓存穿透情况的处理流程是怎样的？" class="headerlink" title="13.2. 缓存穿透情况的处理流程是怎样的？"></a>13.2. 缓存穿透情况的处理流程是怎样的？</h3><p>如下图所示，用户的请求最终都要跑到数据库中查询一遍。</p>
<p><img src="https://plutowu-blogimgs.oss-cn-guangzhou.aliyuncs.com/img/%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E6%83%85%E5%86%B5.png" alt="缓存穿透情况"></p>
<h3 id="13-3-有哪些解决办法？"><a href="#13-3-有哪些解决办法？" class="headerlink" title="13.3. 有哪些解决办法？"></a>13.3. 有哪些解决办法？</h3><p>最基本的就是首先做好参数校验，一些不合法的参数请求直接抛出异常信息返回给客户端。比如查询的数据库 id 不能小于 0、传入的邮箱格式不对的时候直接返回错误消息给客户端等等。</p>
<p><strong>1）缓存无效 key</strong></p>
<p>如果缓存和数据库都查不到某个 key 的数据就写一个到 Redis 中去并设置过期时间，具体命令如下： <code>SET key value EX 10086</code> 。这种方式可以解决请求的 key 变化不频繁的情况，如果黑客恶意攻击，每次构建不同的请求 key，会导致 Redis 中缓存大量无效的 key 。很明显，这种方案并不能从根本上解决此问题。如果非要用这种方式来解决穿透问题的话，尽量将无效的 key 的过期时间设置短一点比如 1 分钟。</p>
<p>另外，这里多说一嘴，一般情况下我们是这样设计 key 的： <code>表名:列名:主键名:主键值</code> 。</p>
<p>如果用 Java 代码展示的话，差不多是下面这样的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getObjectInclNullById</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从缓存中获取数据</span></span><br><span class="line">    Object cacheValue = cache.get(id);</span><br><span class="line">    <span class="comment">// 缓存为空</span></span><br><span class="line">    <span class="keyword">if</span> (cacheValue == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 从数据库中获取</span></span><br><span class="line">        Object storageValue = storage.get(key);</span><br><span class="line">        <span class="comment">// 缓存空对象</span></span><br><span class="line">        cache.set(key, storageValue);</span><br><span class="line">        <span class="comment">// 如果存储数据为空，需要设置一个过期时间(300秒)</span></span><br><span class="line">        <span class="keyword">if</span> (storageValue == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 必须设置过期时间，否则有被攻击的风险</span></span><br><span class="line">            cache.expire(key, <span class="number">60</span> * <span class="number">5</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> storageValue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cacheValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2）布隆过滤器</strong></p>
<p>布隆过滤器是一个非常神奇的数据结构，通过它我们可以非常方便地判断一个给定数据是否存在于海量数据中。我们需要的就是判断 key 是否合法，有没有感觉布隆过滤器就是我们想要找的那个“人”。</p>
<p>具体是这样做的：把所有可能存在的请求的值都存放在布隆过滤器中，当用户请求过来，先判断用户发来的请求的值是否存在于布隆过滤器中。不存在的话，直接返回请求参数错误信息给客户端，存在的话才会走下面的流程。</p>
<p>加入布隆过滤器之后的缓存处理流程图如下。</p>
<p><img src="https://plutowu-blogimgs.oss-cn-guangzhou.aliyuncs.com/img/%E5%8A%A0%E5%85%A5%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E5%90%8E%E7%9A%84%E7%BC%93%E5%AD%98%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B.png" alt="image"></p>
<p>但是，需要注意的是布隆过滤器可能会存在误判的情况。总结来说就是： <strong>布隆过滤器说某个元素存在，小概率会误判。布隆过滤器说某个元素不在，那么这个元素一定不在。</strong></p>
<p><em>为什么会出现误判的情况呢? 我们还要从布隆过滤器的原理来说！</em></p>
<p>我们先来看一下，<strong>当一个元素加入布隆过滤器中的时候，会进行哪些操作：</strong></p>
<ol>
<li>使用布隆过滤器中的哈希函数对元素值进行计算，得到哈希值（有几个哈希函数得到几个哈希值）。</li>
<li>根据得到的哈希值，在位数组中把对应下标的值置为 1。</li>
</ol>
<p>我们再来看一下，<strong>当我们需要判断一个元素是否存在于布隆过滤器的时候，会进行哪些操作：</strong></p>
<ol>
<li>对给定元素再次进行相同的哈希计算；</li>
<li>得到值之后判断位数组中的每个元素是否都为 1，如果值都为 1，那么说明这个值在布隆过滤器中，如果存在一个值不为 1，说明该元素不在布隆过滤器中。</li>
</ol>
<p>然后，一定会出现这样一种情况：<strong>不同的字符串可能哈希出来的位置相同。</strong> （可以适当增加位数组大小或者调整我们的哈希函数来降低概率）</p>
<h2 id="14-缓存雪崩"><a href="#14-缓存雪崩" class="headerlink" title="14. 缓存雪崩"></a>14. 缓存雪崩</h2><h3 id="14-1-什么是缓存雪崩？"><a href="#14-1-什么是缓存雪崩？" class="headerlink" title="14.1. 什么是缓存雪崩？"></a>14.1. 什么是缓存雪崩？</h3><p>实际上，缓存雪崩描述的就是这样一个简单的场景：<strong>缓存在同一时间大面积的失效，后面的请求都直接落到了数据库上，造成数据库短时间内承受大量请求。</strong> 这就好比雪崩一样，摧枯拉朽之势，数据库的压力可想而知，可能直接就被这么多请求弄宕机了。</p>
<p>举个例子：系统的缓存模块出了问题比如宕机导致不可用。造成系统的所有访问，都要走数据库。</p>
<p>还有一种缓存雪崩的场景是：<strong>有一些被大量访问数据（热点缓存）在某一时刻大面积失效，导致对应的请求直接落到了数据库上。</strong> 这样的情况，有下面几种解决办法：</p>
<p>举个例子 ：秒杀开始 12 个小时之前，我们统一存放了一批商品到 Redis 中，设置的缓存过期时间也是 12 个小时，那么秒杀开始的时候，这些秒杀的商品的访问直接就失效了。导致的情况就是，相应的请求直接就落到了数据库上，就像雪崩一样可怕。</p>
<h3 id="14-2-有哪些解决办法？"><a href="#14-2-有哪些解决办法？" class="headerlink" title="14.2. 有哪些解决办法？"></a>14.2. 有哪些解决办法？</h3><p><strong>针对 Redis 服务不可用的情况：</strong></p>
<ol>
<li>采用 Redis 集群，避免单机出现问题整个缓存服务都没办法使用。</li>
<li>限流，避免同时处理大量的请求。</li>
</ol>
<p><strong>针对热点缓存失效的情况：</strong></p>
<ol>
<li>设置不同的失效时间比如随机设置缓存的失效时间。</li>
<li>缓存永不失效。</li>
</ol>
<h2 id="15-MySQL的内连接和外连接"><a href="#15-MySQL的内连接和外连接" class="headerlink" title="15.MySQL的内连接和外连接"></a>15.MySQL的内连接和外连接</h2><blockquote>
<p>内连接</p>
</blockquote>
<p><img src="https://plutowu-blogimgs.oss-cn-guangzhou.aliyuncs.com/img/986203-20170328114511029-1891784394.png" alt="img"></p>
<blockquote>
<p>左外连接</p>
</blockquote>
<p><img src="https://plutowu-blogimgs.oss-cn-guangzhou.aliyuncs.com/img/986203-20170328114619748-1184886553.png" alt="img"></p>
<blockquote>
<p>右外连接</p>
</blockquote>
<p><img src="https://plutowu-blogimgs.oss-cn-guangzhou.aliyuncs.com/img/986203-20170328114729811-38208863.png" alt="img"></p>
<blockquote>
<p>全连接（全外连接）</p>
</blockquote>
<p><strong>MySQL目前不支持此方式</strong></p>
]]></content>
      <categories>
        <category>面试</category>
        <category>SQL</category>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Java</tag>
        <tag>面试</tag>
        <tag>SQL</tag>
        <tag>MySQL</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Java后端面试笔记-I/O</title>
    <url>/2021/03/10/Java%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AE%B0-I-O/</url>
    <content><![CDATA[<h1 id="I-O相关"><a href="#I-O相关" class="headerlink" title="I/O相关"></a>I/O相关</h1><h2 id="1-常见的I-O模型有哪些？Java中BIO、NIO、AIO的区别？"><a href="#1-常见的I-O模型有哪些？Java中BIO、NIO、AIO的区别？" class="headerlink" title="1.常见的I/O模型有哪些？Java中BIO、NIO、AIO的区别？"></a>1.常见的I/O模型有哪些？Java中BIO、NIO、AIO的区别？</h2><h3 id="BIO-Blocking-I-O"><a href="#BIO-Blocking-I-O" class="headerlink" title="BIO (Blocking I/O)"></a>BIO (Blocking I/O)</h3><p><strong>BIO 属于同步阻塞 IO 模型</strong> 。</p>
<p>同步阻塞 IO 模型中，应用程序发起 read 调用后，会一直阻塞，直到在内核把数据拷贝到用户空间。</p>
<p><img src="https://plutowu-blogimgs.oss-cn-guangzhou.aliyuncs.com/img/20210310124137.png"></p>
<p>在客户端连接数量不高的情况下，是没问题的。但是，当面对十万甚至百万级连接的时候，传统的 BIO 模型是无能为力的。因此，我们需要一种更高效的 I/O 处理模型来应对更高的并发量。</p>
<a id="more"></a>

<h3 id="NIO-Non-blocking-New-I-O"><a href="#NIO-Non-blocking-New-I-O" class="headerlink" title="NIO (Non-blocking/New I/O)"></a>NIO (Non-blocking/New I/O)</h3><p>Java 中的 NIO 于 Java 1.4 中引入，对应 <code>java.nio</code> 包，提供了 <code>Channel</code> , <code>Selector</code>，<code>Buffer</code> 等抽象。NIO 中的 N 可以理解为 Non-blocking，不单纯是 New。它支持面向缓冲的，基于通道的 I/O 操作方法。 对于高负载、高并发的（网络）应用，应使用 NIO 。</p>
<p>Java 中的 NIO 可以看作是 <strong>I/O 多路复用模型</strong>。也有很多人认为，Java 中的 NIO 属于同步非阻塞 IO 模型。</p>
<p>跟着我的思路往下看看，相信你会得到答案！</p>
<p>我们先来看看 <strong>同步非阻塞 IO 模型</strong>。</p>
<p><img src="https://plutowu-blogimgs.oss-cn-guangzhou.aliyuncs.com/img/20210310124333.png"></p>
<p>同步非阻塞 IO 模型中，应用程序会一直发起 read 调用，等待数据从内核空间拷贝到用户空间的这段时间里，线程依然是阻塞的，直到在内核把数据拷贝到用户空间。</p>
<p>相比于同步阻塞 IO 模型，同步非阻塞 IO 模型确实有了很大改进。通过轮询操作，避免了一直阻塞。</p>
<p>但是，这种 IO 模型同样存在问题：<strong>应用程序不断进行 I/O 系统调用轮询数据是否已经准备好的过程是十分消耗 CPU 资源的。</strong></p>
<p>这个时候，<strong>I/O 多路复用模型</strong> 就上场了。</p>
<p><img src="https://plutowu-blogimgs.oss-cn-guangzhou.aliyuncs.com/img/20210310124406.png"></p>
<p>IO 多路复用模型中，线程首先发起 select 调用，询问内核数据是否准备就绪，等内核把数据准备好了，用户线程再发起 read 调用。read 调用的过程（数据从内核空间-&gt;用户空间）还是阻塞的。</p>
<blockquote>
<p>目前支持 IO 多路复用的系统调用，有 select，epoll 等等。select 系统调用，是目前几乎在所有的操作系统上都有支持</p>
<ul>
<li><strong>select 调用</strong> ：内核提供的系统调用，它支持一次查询多个系统调用的可用状态。几乎所有的操作系统都支持。</li>
<li><strong>epoll 调用</strong> ：linux 2.6 内核，属于 select 调用的增强版本，优化了 IO 的执行效率。</li>
</ul>
</blockquote>
<p><strong>IO 多路复用模型，通过减少无效的系统调用，减少了对 CPU 资源的消耗。</strong></p>
<p>Java 中的 NIO ，有一个非常重要的<strong>选择器 ( Selector )</strong> 的概念，也可以被称为 <strong>多路复用器</strong>。通过它，只需要一个线程便可以管理多个客户端连接。当客户端数据到了之后，才会为其服务。</p>
<p><img src="https://plutowu-blogimgs.oss-cn-guangzhou.aliyuncs.com/img/20210310124438.png"></p>
<h3 id="AIO-Asynchronous-I-O"><a href="#AIO-Asynchronous-I-O" class="headerlink" title="AIO (Asynchronous I/O)"></a>AIO (Asynchronous I/O)</h3><p>AIO 也就是 NIO 2。Java 7 中引入了 NIO 的改进版 NIO 2,它是异步 IO 模型。</p>
<p>异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。</p>
<p><img src="https://plutowu-blogimgs.oss-cn-guangzhou.aliyuncs.com/img/20210310124459.png"></p>
<p>目前来说 AIO 的应用还不是很广泛。Netty 之前也尝试使用过 AIO，不过又放弃了。这是因为，Netty 使用了 AIO 之后，在 Linux 系统上的性能并没有多少提升。</p>
<p>最后，来一张图，简单总结一下 Java 中的 BIO、NIO、AIO。</p>
<p><img src="https://plutowu-blogimgs.oss-cn-guangzhou.aliyuncs.com/img/20210310124518.png"></p>
]]></content>
      <categories>
        <category>面试</category>
        <category>Java</category>
        <category>笔记</category>
      </categories>
  </entry>
  <entry>
    <title>Java后端面试笔记-JVM</title>
    <url>/2021/03/09/Java%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AE%B0-JVM/</url>
    <content><![CDATA[<h1 id="JVM相关"><a href="#JVM相关" class="headerlink" title="JVM相关"></a>JVM相关</h1><h2 id="1-修改Java字节码"><a href="#1-修改Java字节码" class="headerlink" title="1.修改Java字节码"></a>1.修改Java字节码</h2><p>在OpenJDK里有一个<code>AsmTools</code>项目，用来生成正确的或者不正确的java <code>.class</code>文件，主要用来测试和验证。</p>
<p><code>AsmTools</code>引入了两种表示<code>.class</code>文件的语法：</p>
<ul>
<li><p>JASM</p>
<p>用类似java本身的语法来定义类和函数，字节码指令则很像传统的汇编。</p>
</li>
<li><p>JCOD</p>
<p>整个<code>.class</code>用容器的方式来表示，可以很清楚表示类文件的结构。</p>
</li>
</ul>
<p>重要的是两种语法的文件都是可以和<code>.class</code>互相转换的。</p>
<p>在这里主要使用<code>JASM</code>语法。</p>
<a id="more"></a>

<h3 id="生成asmtools-jar"><a href="#生成asmtools-jar" class="headerlink" title="生成asmtools.jar"></a>生成asmtools.jar</h3><p>如果你的机器没有安装 <code>Mercurial</code>，请先安装(Mericurial 类似 Git 和 SVN，是一个分布式版本控制系统，使用 Python 编写，OpenJDK 就托管在 Mercurial 平台上)</p>
<p>然后执行以下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">// Clone代码</span><br><span class="line">hg clone ://hg.openjdk.java.net/code-tools/asmtools</span><br><span class="line"></span><br><span class="line">// 编译</span><br><span class="line">cd asmtools/build</span><br><span class="line">ant</span><br></pre></td></tr></table></figure>

<p>即可得到asmtools.jar文件。</p>
<h3 id="准备一个Example"><a href="#准备一个Example" class="headerlink" title="准备一个Example"></a>准备一个Example</h3><p>Foo.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">  <span class="keyword">if</span> (flag) System.out.println(<span class="string">&quot;Hello, Java!&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (flag == <span class="keyword">true</span>) System.out.println(<span class="string">&quot;Hello, JVM!&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>javac Foo.java</code>命令生成Foo.class文件，使用JD-GUI打开内容如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.PrintStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] paramArrayOfString)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (i != <span class="number">0</span>) &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Hello, Java!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">1</span>) &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Hello, JVM!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>java Foo</code>命令运行Foo.class文件输出结果：</p>
<figure class="highlight autohotkey"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Hello,</span> Java!</span><br><span class="line"><span class="built_in">Hello,</span> JVM!</span><br></pre></td></tr></table></figure>

<h3 id="由class文件生成jasm文件"><a href="#由class文件生成jasm文件" class="headerlink" title="由class文件生成jasm文件"></a>由class文件生成jasm文件</h3><p>如下命令将class文件中的内容转换成对应的jasm语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -jar asmtools.jar jdis Foo.class</span><br></pre></td></tr></table></figure>

<p>上面输出的内容会直接打印在终端，当然你也可以把它输入到文件中：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">java -jar asmtools.jar jdis <span class="module-access"><span class="module"><span class="identifier">Foo</span>.</span></span><span class="keyword">class</span> &gt; <span class="module-access"><span class="module"><span class="identifier">Foo</span>.</span></span>jasm</span><br></pre></td></tr></table></figure>

<p>Foo.jasm 文件内容如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">super</span> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span></span><br><span class="line">    version 52:0</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Method <span class="string">&quot;&lt;init&gt;&quot;</span>:<span class="string">&quot;()V&quot;</span></span><br><span class="line">    stack <span class="number">1</span> locals <span class="number">1</span></span><br><span class="line">&#123;</span><br><span class="line">        aload_0;</span><br><span class="line">        invokespecial   Method java/lang/Object.<span class="string">&quot;&lt;init&gt;&quot;</span>:<span class="string">&quot;()V&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Method main:<span class="string">&quot;([Ljava/lang/String;)V&quot;</span></span><br><span class="line">    stack <span class="number">2</span> locals <span class="number">2</span></span><br><span class="line">&#123;</span><br><span class="line">        iconst_1;</span><br><span class="line">        istore_1;</span><br><span class="line">        iload_1;</span><br><span class="line">        ifeq    L14;</span><br><span class="line">        getstatic   Field java/lang/System.out:<span class="string">&quot;Ljava/io/PrintStream;&quot;</span>;</span><br><span class="line">        ldc String <span class="string">&quot;Hello, Java!&quot;</span>;</span><br><span class="line">        invokevirtual   Method java/io/PrintStream.println:<span class="string">&quot;(Ljava/lang/String;)V&quot;</span>;</span><br><span class="line">    L14:    stack_frame_type append;</span><br><span class="line">        locals_map <span class="keyword">int</span>;</span><br><span class="line">        iload_1;</span><br><span class="line">        iconst_1;</span><br><span class="line">        if_icmpne   L27;</span><br><span class="line">        getstatic   Field java/lang/System.out:<span class="string">&quot;Ljava/io/PrintStream;&quot;</span>;</span><br><span class="line">        ldc String <span class="string">&quot;Hello, JVM!&quot;</span>;</span><br><span class="line">        invokevirtual   Method java/io/PrintStream.println:<span class="string">&quot;(Ljava/lang/String;)V&quot;</span>;</span><br><span class="line">    L27:    stack_frame_type same;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// end Class Foo</span></span><br></pre></td></tr></table></figure>

<p>为了将 Foo.class 中的 <code>int i = 1;</code> 修改成 <code>int i = 2;</code>，我们需要替换 Foo.jasm 文件中的 <code>iconst_1</code> 为 <code>iconst_2</code>。</p>
<h3 id="由jasm文件生成class文件"><a href="#由jasm文件生成class文件" class="headerlink" title="由jasm文件生成class文件"></a>由jasm文件生成class文件</h3><p>执行如下命令：</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">java </span>-<span class="keyword">jar </span>asmtools.<span class="keyword">jar </span><span class="keyword">jasm </span>Foo.<span class="keyword">jasm</span></span><br></pre></td></tr></table></figure>

<p>这时再用 JD-GUI 打开 Foo.class 文件，内容如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.PrintStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] paramArrayOfString)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (i != <span class="number">0</span>) &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Hello, Java!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">1</span>) &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Hello, JVM!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看到 i 的确由 1 变成 2 了。</p>
<p><code>java Foo</code> 输出内容如下：</p>
<figure class="highlight autohotkey"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Hello,</span> Java!</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>其实就两个命令：</p>
<ul>
<li>由 class 文件生成 jasm 文件：<code>java -jar asmtools.jar jdis Foo.class &gt; Foo.jasm</code></li>
<li>由 jasm 文件生成 class 文件：<code>java -jar asmtools.jar jasm Foo.jasm</code></li>
</ul>
]]></content>
      <categories>
        <category>面试</category>
        <category>Java</category>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Java</tag>
        <tag>面试</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>睡前故事-白雪为嫁</title>
    <url>/2020/11/23/%E7%9D%A1%E5%89%8D%E6%95%85%E4%BA%8B-%E7%99%BD%E9%9B%AA%E4%B8%BA%E5%AB%81/</url>
    <content><![CDATA[<p>风暴戾地撞着窗，这个冬天格外冰冷。</p>
<p>“你听话呀。”母亲的声音疲惫而心疼，“他家条件差得很，还有两个兄弟没成家。你跟过去吃没得吃、穿没得穿，只有受苦啊！”</p>
<p>她和母亲并排躺在床上，抿着嘴唇并不出声，唯有泪珠成串滚落，很快浸湿枕巾。</p>
<p>母亲侧着身，用右手柔柔帮她擦着泪，也有些哽咽：“妈妈都是为你好，你醒点事，好么？他平日里就会打架闹事，不是个有出息的人。”</p>
<p>她吸了一下鼻子，眼睛执拗地闭着，无声哭泣。</p>
<p>“明天去把孩子拿掉就好了。”母亲的声音在耳边继续着，她有她的苦心与疼爱，“时间久了你就不难过了，妈妈给你找个好婆家，保证比他强，过日子总归是要吃饱穿暖。”</p>
<p>她抬了抬右手，没能抬动。</p>
<p>母亲警觉地握紧了她的手。</p>
<p>她的右手和母亲的左手紧紧绑在一起，布条还打了死结。</p>
<p>“你们三兄妹里，妈妈最疼你，哪里能看着你吃苦。”母亲见止不住她的泪，自己的眼泪也落了下来，“你这个苕伢子……”</p>
<p>母亲哭了一阵，帮她掖好被子，终于结束了劝慰，“很晚了，好好睡一觉，天亮妈妈就带你去医院。”</p>
<a id="more"></a>

<hr>
<p>时间，怎么这么难熬呢？</p>
<p>眼泪，好像流干了。</p>
<p>眼睛涩涩的，她一动不动，静静听着旁边的呼吸声。</p>
<p>呼吸很平稳，应是已睡熟了。但她仍不敢动，她知道机会只有一次。</p>
<p>她很累，东躲西藏，最终还是被家人抓回来，已经身心俱疲。但她一点睡意也没有，她在心里默默地算着时间。</p>
<p>这会儿应该是凌晨了，外面的房间很久没有动静，父亲应该也睡了。</p>
<p>她试探着侧转身体，面对母亲。母亲闭着眼睛，毫无反应。</p>
<p>母亲也很累了，这阵子她一定也很难过吧？她那么疼爱儿女。</p>
<p>可是，对不起妈妈，这次我不能听话。她在黑夜里看着母亲隐约的脸，心里默默说道。</p>
<p>沉默不是顺从，是在等这唯一的机会。</p>
<p>她小心翼翼地去解绑着手的布条，死结很难解，她只能一点一点的艰难挪动。</p>
<p>她心里很着急，但她强迫自己的动作更轻柔一些。</p>
<p>结慢慢、慢慢松开，母亲突然嘟囔了一句什么！</p>
<p>她全身都僵硬了！一动不敢动，假装自己熟睡着。但心脏跳动得如此剧烈，几乎提到了嗓子眼。</p>
<p>但母亲接下来并没有其他动作，那句话也听不清楚，只是一句梦呓。</p>
<p>她平复着心跳，缓慢地将布条解开。</p>
<p>一只手压着被子，不让寒意透进来，身体小心翼翼往床下挪。</p>
<p>终于，双脚落地。</p>
<p>地面冰凉刺骨，但她已经顾不得那么多。</p>
<p>时间紧迫！机会过了明天就不再有！</p>
<p>她甚至来不及去穿一双鞋子，去拿一件外套。</p>
<p>她踮着赤脚，做贼一般地挪出房间。</p>
<p>从父亲的床边蹑手蹑脚走过，掩耳盗铃般地不敢看他一眼。</p>
<p>来到堂屋，她轻轻抬起门栓，将大门缓缓拉开。</p>
<p>嘶~！</p>
<p>外面的寒风猛地灌了进来，将她整个人都浇凉。</p>
<p>但她却精神一振，把门拉开到仅容一人进出的空间，就赶紧侧身钻了出去。</p>
<p>她缓缓合上大门，仅着睡衣，赤足投入了漫天风雪中。</p>
<hr>
<p>这夜可真冷呵！</p>
<p>她冻得牙齿打颤，全身上下没一处不冷。</p>
<p>尤其踩在雪上的赤足，已经麻木得似乎没有了感觉。</p>
<p>但她只管捂着她的小腹，一脚深一脚浅地往前迈。</p>
<p>这是孩子。</p>
<p>这是我的孩子。</p>
<p>这是我和他的孩子！</p>
<p>她开始跑，用劲跑，使出全身力气的跑。</p>
<p>跑在这条那么熟悉的路上！跑在去他家的路上！</p>
<p>不到两公里的距离，她乌黑的头发上已经披满白雪。</p>
<p>她全身都快冻僵了，但总有一股子力气不知从哪里涌出来。</p>
<p>她终于站到了他家门前。</p>
<p>她敲门，用力敲门，大声喊他的名字。</p>
<p>房间里响起重物坠地的声音，继而是急促的脚步声，男人猛地撞出来，拉开房门！</p>
<p>他看到了怎样的一幅情景？</p>
<p>门外立着的，是面色苍白、瑟瑟发抖却灼灼与他对视的女子。</p>
<p>她的皮肤如雪，十里八乡没有哪个女子有这般白净。</p>
<p>她紧抿着已冻得乌青的唇，就那么俏生生立在雪中！</p>
<p>眼泪一下子就涌了出来，这是他以为将永远失去的她！</p>
<p>他一把将她从雪地里抱起，牢牢抱进怀里。</p>
<p>白茫茫的雪夜啊，风刀割不开的恋人。</p>
<p>这一夜。</p>
<p>有多少人见证了漫天风雪，就有多少人看到了白色婚纱。</p>
]]></content>
      <categories>
        <category>睡前故事</category>
      </categories>
      <tags>
        <tag>Hide</tag>
        <tag>睡前故事</tag>
      </tags>
  </entry>
  <entry>
    <title>睡前故事-女巫</title>
    <url>/2020/11/22/%E7%9D%A1%E5%89%8D%E6%95%85%E4%BA%8B-%E5%A5%B3%E5%B7%AB/</url>
    <content><![CDATA[<p>“你知道吗，从遇见你的那天起，我心里，就种下了一个愿望……”</p>
<p>女巫瘫坐在地上，她仰起脸，怔怔地望着身前伤痕累累的男人，两行晶莹的泪水从脸颊滑落。</p>
<a id="more"></a>

<hr>
<p>十五年前。</p>
<p>女巫骑着扫帚在天上散心，远远地望见一道黑烟。</p>
<p>她飞到黑烟的源头察看，这里本来是一处村落，现在变成了一片废墟，四处都是断壁残垣，空气中弥漫着烧焦的木头与鲜血的混合气味。</p>
<p>她在废墟中翻找了很久，最终在一个大水缸下面发现一个幸存的小男孩。</p>
<p>女巫兴奋地把他抱了起来。</p>
<p>年仅五岁的小男孩在空中流着眼泪，瑟瑟发抖地问：“女……女巫阿姨，你会吃掉我吗？”</p>
<p>女巫皱了皱好看的柳叶眉，捏着他白皙的脸颊，说：“叫姐姐！”</p>
<p>这时，一群拿着锄头和镰刀的村民赶了过来。</p>
<p>他们远远地望见女巫抱着的小男孩。</p>
<p>人群顿时沸沸扬扬地呼喊了起来。</p>
<p>“快，抓住她！一定是那个女巫毁了这个村子！”</p>
<p>“我的上帝啊，谁能救救那个可怜的孩子！”</p>
<p>见村民们赶来，女巫连忙抱起小男孩，骑上扫帚飞走了。</p>
<hr>
<p>不久之后，女巫被冠以屠村的罪名，全国通缉。</p>
<p>对此，她毫不在乎，优哉游哉地在自己的魔法小屋里玩养成游戏，他每天教小男孩调配药剂，感应魔法。</p>
<p>只要他一偷懒，她的魔杖便会毫不留情地敲打他的脑袋。</p>
<p>只不过，每当女巫想要教训他的时候，他就用胖乎乎的小手捂着头顶，瞪着水汪汪的大眼睛可怜巴巴地望着她。</p>
<p>于是，女巫的处罚常常会半途而废。</p>
<p>这样的日子过得很快，转眼男孩就长大了。</p>
<p>他二十岁的时候，已经长得比女巫要高大得多，女巫踮起脚尖只能勉强碰到他的额头。</p>
<p>她再也不能随心所欲地敲打他的头顶了，每当她要处罚他的时候，他只要伸直胳膊按住女巫的头，她不管怎么挥舞魔杖也碰不到他。</p>
<p>女巫只好自己躲到书房，一边生闷气一边翻阅《男人的一百种烹饪方法》。</p>
<p>每当这时候，他都会做她最爱吃的蛋包饭，宠溺地看着她一边傲娇地说不好吃一边不停嘴地吃光一整盘蛋包饭。</p>
<hr>
<p>这天是采购日，他自己骑着扫帚出门采购食材，她待在家里百无聊赖地翻着书。</p>
<p>突然，一支燃烧的箭矢射了进来。</p>
<p>女巫黑色袍子上的防御法阵瞬间触发。</p>
<p>她挡住了箭，拿着法杖飘到了屋外。</p>
<p>那是一大群赏金猎人，其中不乏职业的女巫杀手。</p>
<p>“终于还是来了吗？”</p>
<p>他带着一堆食材返回的时候，家已经变成了一堆废墟，女巫拄着魔杖站在地上，她身上的法袍已经残破不堪，白皙的肌肤上，殷红的鲜血直流。</p>
<p>女巫抬头望见了他，他的眼中燃烧着怒火。</p>
<p>“滚开！小屁孩不要在这里碍事！”</p>
<p>女巫朝他吼道。</p>
<p>他缓缓走向了她，摸了摸她的头，说：“十五年了，我还不了解你嘛。”</p>
<p>他拿着魔杖，背对着她说：“你知道吗，从遇见你的那天起，我心里，就种下了一个愿望……”</p>
<p>话还没说完，无数的箭矢就朝着他射了过来，他的魔杖闪烁着光芒，站在他身前抵挡着一切攻击。</p>
<p>女巫瘫坐在地上，她仰起脸，怔怔地望着身前伤痕累累的男人，两行晶莹的泪水从脸颊滑落。</p>
<p>这场战斗不知道持续了多久，他的魔杖终于折断了，而对面还站着的赏金猎人也寥寥无几。</p>
<p>“再加把劲，只要把这个女巫的尸体带回去，咱们就有一辈子都花不完的赏金啦！”</p>
<p>话音刚落，一支箭矢就朝着女巫射了过去。</p>
<p>他飞身扑到了她的身前，紧紧地抱住了她，用背部挡住了那支箭。</p>
<p>这时，一个骑士骑着马飞奔了过来，他朝着赏金猎人们大喊着：“国王有令，屠村的罪魁祸首已经落网，是一群山贼，女巫无罪！女巫无罪！”</p>
<p>女巫流着泪摸着他渐渐失去血色的脸颊。</p>
<p>“为什么……为什么？”</p>
<p>他笑了笑，宠溺地摸了摸她的额头，说：“我种下的愿望是……保护你，一辈子。”</p>
<p>他撑着地面站起身来，背对着不知所措的人群，横着抱起女巫，缓缓地离开了。</p>
<p>女巫被他用公主抱的姿势抱在怀里，她说：“你的伤，没关系吗？”</p>
<p>他笑了笑，说：“没关系，一会把箭取出来，你给我用魔法治疗一下就好啦。”</p>
<p>“我……我们要去哪儿。”</p>
<p>“我们一起，去找一个新家。”</p>
<p>晚安</p>
<p>早安</p>
]]></content>
      <categories>
        <category>睡前故事</category>
      </categories>
      <tags>
        <tag>Hide</tag>
        <tag>睡前故事</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot-bug解决</title>
    <url>/2020/11/21/SpringBoot-bug%E8%A7%A3%E5%86%B3/</url>
    <content><![CDATA[<h1 id="SpringBoot-BUG解决"><a href="#SpringBoot-BUG解决" class="headerlink" title="SpringBoot-BUG解决"></a>SpringBoot-BUG解决</h1><h2 id="1-跨域配置失效（SpringBoot版本问题）"><a href="#1-跨域配置失效（SpringBoot版本问题）" class="headerlink" title="1.跨域配置失效（SpringBoot版本问题）"></a>1.跨域配置失效（SpringBoot版本问题）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CrosConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addCorsMappings</span><span class="params">(CorsRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addMapping(<span class="string">&quot;/**&quot;</span>)</span><br><span class="line">                .allowedOrigins(<span class="string">&quot;*&quot;</span>)</span><br><span class="line">                .allowedMethods(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;HEAD&quot;</span>, <span class="string">&quot;POST&quot;</span>, <span class="string">&quot;PUT&quot;</span>, <span class="string">&quot;DELETE&quot;</span>, <span class="string">&quot;OPTIONS&quot;</span>)</span><br><span class="line">                .allowCredentials(<span class="keyword">true</span>)</span><br><span class="line">                .maxAge(<span class="number">3600</span>)</span><br><span class="line">                .allowedHeaders(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>采用SpringBoot 2.4.0版本下，配置跨域，报错</p>
<a id="more"></a>

<p><em>java.lang.IllegalArgumentException: When allowCredentials is true, allowedOrigins cannot contain the special value “＊”since that cannot be set on the “Access-Control-Allow-Origin” response header. To allow credentials to a set of origins, list them explicitly or consider using “allowedOriginPatterns” instead</em></p>
<p>错误为：当设置了<code>allowCredentials=true</code>的时候，服务器端响应的<code>Access-Control-Allow-Origin</code>头，它的值不能是<code>*</code>，必须要明确的指定出客户端的<code>origin</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">.allowedOrigins(<span class="string">&quot;http://localhost&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>指明具体客户端<code>origin</code>后，虽无报错，但浏览器访问仍然显示跨域失败。</p>
<p>==最终方法：将SpringBoot版本切换为2.2.x，成功解决==</p>
<p>…..尚未完结，持续更新</p>
]]></content>
      <categories>
        <category>编程</category>
        <category>Java Web</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Java Web</tag>
        <tag>Swagger</tag>
      </tags>
  </entry>
  <entry>
    <title>vue-搭建vue+element ui项目</title>
    <url>/2020/11/21/vue-%E6%90%AD%E5%BB%BAvue+element-ui%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<h1 id="搭建Vue-Element-UI项目（通过Vue-UI）"><a href="#搭建Vue-Element-UI项目（通过Vue-UI）" class="headerlink" title="搭建Vue+Element-UI项目（通过Vue-UI）"></a>搭建Vue+Element-UI项目（通过Vue-UI）</h1><h2 id="1-启动命令行，进入Vue-UI"><a href="#1-启动命令行，进入Vue-UI" class="headerlink" title="1.启动命令行，进入Vue-UI"></a>1.启动命令行，进入Vue-UI</h2><p><img src="https://plutowu-blogimgs.oss-cn-guangzhou.aliyuncs.com/img/image-20201121094336554.png" alt="image-20201121094336554"></p>
<p>输入<a href="http://localhost:8000，即可进入UI界面">http://localhost:8000，即可进入UI界面</a></p>
<p><img src="https://plutowu-blogimgs.oss-cn-guangzhou.aliyuncs.com/img/image-20201121094647023.png" alt="image-20201121094647023"></p>
<a id="more"></a>

<h2 id="2-进入Vue项目管理器，新建项目"><a href="#2-进入Vue项目管理器，新建项目" class="headerlink" title="2.进入Vue项目管理器，新建项目"></a>2.进入Vue项目管理器，新建项目</h2><p>进入Vue项目管理器，进行新建或删除项目等操作</p>
<p><img src="https://plutowu-blogimgs.oss-cn-guangzhou.aliyuncs.com/img/image-20201121094734271.png" alt="image-20201121094734271"></p>
<p><img src="https://plutowu-blogimgs.oss-cn-guangzhou.aliyuncs.com/img/image-20201121094904195.png" alt="image-20201121094904195"></p>
<p>存在三种选项，管理现有项目、新建项目和导入项目，我们选择创建项目</p>
<p><img src="https://plutowu-blogimgs.oss-cn-guangzhou.aliyuncs.com/img/image-20201121095201637.png" alt="image-20201121095201637"></p>
<ul>
<li>创建新项目Step1-详情</li>
</ul>
<p><img src="https://plutowu-blogimgs.oss-cn-guangzhou.aliyuncs.com/img/image-20201121095418245.png" alt="image-20201121095418245"></p>
<ul>
<li>创建新项目Step2-预设</li>
</ul>
<p><img src="https://plutowu-blogimgs.oss-cn-guangzhou.aliyuncs.com/img/image-20201121095637943.png" alt="image-20201121095637943"></p>
<ul>
<li>创建新项目Step3-功能选择</li>
</ul>
<p><img src="https://plutowu-blogimgs.oss-cn-guangzhou.aliyuncs.com/img/image-20201121100002708.png" alt="image-20201121100002708"></p>
<ul>
<li>创建新项目Step4-配置</li>
</ul>
<p><img src="https://plutowu-blogimgs.oss-cn-guangzhou.aliyuncs.com/img/image-20201121100134876.png" alt="image-20201121100134876"></p>
<p>此时会询问是否创建为预设，可选择否或保留此预设，保留预设可免去重复配置</p>
<p><img src="https://plutowu-blogimgs.oss-cn-guangzhou.aliyuncs.com/img/image-20201121100207810.png" alt="image-20201121100207810"></p>
<h2 id="3-配置新项目"><a href="#3-配置新项目" class="headerlink" title="3.配置新项目"></a>3.配置新项目</h2><p><img src="https://plutowu-blogimgs.oss-cn-guangzhou.aliyuncs.com/img/image-20201121100350314.png" alt="image-20201121100350314"></p>
<p>进入项目管理器下，插件选项，安装所需插件</p>
<p>这里我们选择Element-ui与axios</p>
<p><img src="https://plutowu-blogimgs.oss-cn-guangzhou.aliyuncs.com/img/image-20201121100526996.png" alt="image-20201121100526996"></p>
<p><img src="https://plutowu-blogimgs.oss-cn-guangzhou.aliyuncs.com/img/image-20201121100551055.png" alt="image-20201121100551055"></p>
<p>均点击安装即可</p>
<p>安装完成，即完成项目搭建</p>
<h2 id="4-进入VS-Code查看成果"><a href="#4-进入VS-Code查看成果" class="headerlink" title="4.进入VS Code查看成果"></a>4.进入VS Code查看成果</h2><p><img src="https://plutowu-blogimgs.oss-cn-guangzhou.aliyuncs.com/img/image-20201121101030358.png" alt="image-20201121101030358"></p>
<p>开启NPM脚本-serve，开启热部署</p>
<p><img src="https://plutowu-blogimgs.oss-cn-guangzhou.aliyuncs.com/img/image-20201121101123455.png" alt="image-20201121101123455"></p>
<p>可进入相应端口，实时查看项目，编辑完项目后CTRL+S保存即可完成更新，NPM脚本会重新编译</p>
<p><img src="https://plutowu-blogimgs.oss-cn-guangzhou.aliyuncs.com/img/image-20201121101327645.png" alt="image-20201121101327645"></p>
<hr>
<p><strong>至此，Vue+Element项目搭建完成，接下来就可以开始你的渐进式开发了！</strong></p>
]]></content>
      <categories>
        <category>编程</category>
        <category>Vue</category>
        <category>Element UI</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>Element UI</tag>
      </tags>
  </entry>
  <entry>
    <title>睡前故事-放开那条恶龙</title>
    <url>/2020/11/20/%E7%9D%A1%E5%89%8D%E6%95%85%E4%BA%8B-%E6%94%BE%E5%BC%80%E9%82%A3%E6%9D%A1%E6%81%B6%E9%BE%99/</url>
    <content><![CDATA[<p>龙宝宝有个梦想——抓一只……呸，抓一位公主。</p>
<p>为什么要抓公主呢？</p>
<p>因为龙族有一项特殊的成人礼——抓公主。</p>
<p>只有在王宫骑士重重包围之下抓走公主的龙，才能成为一条伟大的巨龙。</p>
<a id="more"></a>

<hr>
<p>为了实现自己的梦想，龙宝宝变身成一个俊美的少年，每天都背着一个小麻袋，拎着一根小木棍，在王城里瞎逛。</p>
<p>他的计划是：</p>
<p>遇见公主</p>
<p>打晕公主</p>
<p>装进麻袋</p>
<p>溜之大吉</p>
<p>一个月过去了，他始终没能见到公主。</p>
<p>渐渐的，他失去了瞎逛的动力。每天只是把袋子和棍子扔在一边，坐在墙角看着来往的路人，看看哪一个有可能是公主。</p>
<p>有时候一天下来，袋子里还能多几个铜币。</p>
<p>这天，他像往常一样坐在墙角。</p>
<p>迎面走过来一个牵着白马的少女。</p>
<p>“喂，小乞丐。”</p>
<p>“我不是小乞丐！”</p>
<p>他一下子站起来，瞪着少女说。</p>
<p>龙宝宝心想，要不是你长得还挺漂亮，我一口吃掉你，你信不信。</p>
<p>但就算你好看，也不能侮辱龙族的尊严！</p>
<p>“那你是什么？”</p>
<p>“我是龙……龙……”</p>
<p>他正支支吾吾不知道怎么隐瞒自己的身份，一支王国骑士巡逻队远远地朝这里走来。</p>
<p>“来不及了，小乞丐，把棍子给我！”</p>
<p>“哦，好。”</p>
<p>龙宝宝呆呆地把棍子递了过去。</p>
<p>“可能会很疼，你忍着点儿哈。”</p>
<p>“啊？为什……”</p>
<p>他的话还没说完，只觉得眼前一黑，失去了意识。</p>
<p>他再次睁开眼睛的时候，眼前一片漆黑。</p>
<p>他使劲扭动着身体，发现自己被绳子绑住了。</p>
<p>少女那清脆的嗓音从外面传来。</p>
<p>“小乞丐，你别乱动，我放你出来。”</p>
<p>说完，少女把他从麻袋里倒了出来。</p>
<p>他一边大口呼吸着新鲜空气，又一边观察着下四周，这是在城外的森林里，只有火堆，白马和少女。</p>
<p>少女坐在火堆旁，拍了拍他的肩膀，说：“实话跟你说吧，我是王国的公主，最近离家出走，缺个仆人，我观察你很久了，觉得你是个很好的人选。”</p>
<p>龙宝宝目瞪口呆地听着，少女自顾自地说着。</p>
<p>“我的计划就是接近你，打晕你，装进麻袋，然后溜之大吉。”</p>
<p>“你看，多么完美的计划，你还自带麻袋和木棍，简直太贴心了！”</p>
<p>龙宝宝心想，这计划似曾相识啊，等等，她说她是谁来着，公……公主？</p>
<p>我……我成功啦？</p>
<p>“话说，你为什么要离家出走呢？”</p>
<p>“我想成为一位伟大的战士，每一位伟大的战士都要经历一场特殊的成人礼。”</p>
<hr>
<p>“什么？”</p>
<p>“屠龙！”</p>
<p>“……”</p>
<p>于是，龙宝宝和公主踏上了“屠龙”的旅程。</p>
<p>公主似乎很虚弱，他们足足走了半个月，才走出了森林。</p>
<p>但是，在森林的边缘，他们终于还是遇到了王国骑士团。</p>
<p>骑士们不敢对公主动手，所有火力都迎向了公主身边的少年。</p>
<p>一番激战过后，少年被揍得伤痕累累，奄奄一息地倒在地上。</p>
<p>“住手！”</p>
<p>“你们别打了，我跟你们回去。”</p>
<p>公主伏在少年的耳边轻轻地说：“回家吧，龙宝宝，别再想着抓公主啦。”</p>
<p>少年的眼睛圆瞪着，难以置信地望向她。</p>
<p>公主回头，留给他一个含泪的微笑。</p>
<p>有人说成长是一个过程，但龙宝宝的成长，只是一个瞬间。</p>
<p>他站起身来，身上逐渐布满了黑色的鳞片，一对翅膀从背后钻了出来，瞬间就遮蔽了整片天空。</p>
<p>巨大的翅膀扇动起来，飓风席卷了整片森林。</p>
<p>只是一次呼吸的时间，黑影就笼罩了整个骑士团。</p>
<p>“把公主还给我！”</p>
<p>巨龙把公主带回了自己的洞穴，又变成了奄奄一息的少年。</p>
<p>“现在，你只要杀了我，就可以变成伟大的战士了。”</p>
<p>公主把剑抽了出来，刺向了少年。</p>
<p>少年缓缓闭上眼睛。</p>
<p>他听到剑摔落的声音，感到一丝丝热气喷在自己的耳朵上。</p>
<p>他睁开眼睛，公主倒在自己的身上。</p>
<p>“你是怎么发现我是龙的？”</p>
<p>“每一位屠龙战士，血脉里都隐藏着分辨龙的能力，只不过，当他们爱上一条龙的时候，便虚弱的再也挥不动剑了。”</p>
<p>他盯着她，说：“你知道吗，当我第一次看到你的时候，就已经想好孩子叫什么了。”</p>
<p>晚安</p>
<p>早安</p>
]]></content>
      <categories>
        <category>睡前故事</category>
      </categories>
      <tags>
        <tag>Hide</tag>
        <tag>睡前故事</tag>
      </tags>
  </entry>
  <entry>
    <title>睡前故事-喝酒</title>
    <url>/2020/11/19/%E7%9D%A1%E5%89%8D%E6%95%85%E4%BA%8B-%E5%96%9D%E9%85%92/</url>
    <content><![CDATA[<p>山上有一只小狐狸。</p>
<p>她在山上修炼了一百年，终于化出了人形。</p>
<p>一出关，她就迫不及待地跑下了山。</p>
<p>“一百年啦，也不知道人间变成什么样了。”</p>
<a id="more"></a>

<hr>
<p>没走多远，她就嗅到一股香气，她仔细闻了闻，是酒香！</p>
<p>她擦了擦口水，摇身一变化成一个妙龄少女，又把尾巴往裙子里塞了塞。</p>
<p>她寻着酒香来到了山下的小镇上，小镇里车水马龙，远处的集市人声鼎沸。</p>
<p>她瞪着好奇宝宝一般的大眼睛，望着青石板的小路，络绎不绝的马车，以及，不远处的酒肆。</p>
<p>她一路小跑着来到了酒肆，叫道：“小二，来一碗酒！”</p>
<p>酒肆的小伙计瞅了瞅她，心里嘀咕道“大白天的一个人姑娘家出来喝酒，还真是少见。”想归想，他还是盛了一碗酒，送到小狐狸面前。</p>
<p>“客官，请慢用。”</p>
<p>小狐狸端起碗一饮而尽，这酒可真香啊！</p>
<p>她喝了一碗又一碗，直到喝得酩酊大醉，才满意地摸了摸小肚子，出了门。</p>
<p>自此，小狐狸天天下山喝酒，她的积蓄也越来越少。</p>
<p>她仔细琢磨了一下，再这样喝下去，钱肯定不够花，不如把小石子变成铜钱付账。可是，小石子的法术只能维持一会儿，用不了多久就会变回去，这样不就把酒肆给坑了？人家做个小本生意也不容易，左思右想，小狐狸决定在小镇上用法术行医赚钱，赚到的钱再用来买酒喝，嗯，就这么办！</p>
<hr>
<p>第二天，小狐狸就变成少女的模样，扛着一个“再世华佗”的小旗子，下了山。</p>
<p>她在小镇的集市上摆了个小摊子，生意就算是开张了。</p>
<p>一开始，小镇上的百姓还不相她，觉得这么年轻的姑娘，哪里会什么医术。没过多久，李家爷爷多年的老寒腿被她轻轻松松治好了，她的小摊子前立马排起了长队。</p>
<p>来找她看病的都是在医馆买不起药的穷人，小狐狸心软，不忍心收他们的钱。</p>
<p>天色晚了，小狐狸打起自己的小包袱收摊回家，她的小包袱里装得满满的，有宋家奶奶塞的馍馍，还有刘家爷爷送的萝卜，只是一个铜板都没有。</p>
<p>她挑着包袱路过酒肆，闻着酒香擦了擦口水，可她摸了摸自己的包袱，叹了口气，心想：“算了，起码今晚能吃顿饱饭。”</p>
<p>这样想着，她慢慢走开了。</p>
<p>这时，酒肆的小伙计追了出来。</p>
<p>望着她的背影喊道：“唉，姑娘留步，我请你喝酒！”</p>
<p>她的两个小耳朵立马树了起来，几乎飞一般地跑到小伙计面前，盯着他说：“你说什么？再说一遍！”</p>
<p>小伙计擦了擦汗，说：“我……我请你喝酒。”</p>
<p>“哈哈哈哈，原来这家酒馆就是你开的呀，看不出来啊，小掌柜！”</p>
<p>小狐狸一边抱着酒坛子，一边拍着小伙计的肩膀说。</p>
<p>小伙计腼腆地笑了笑，说：“你治好了那么多乡亲，都不要钱，请你喝点酒算什么！以后，你若是想喝酒，尽管来便是了。”</p>
<p>她的脸上布满了红晕，打着酒嗝说：“嘿嘿嘿，你可真……真是个好人！”</p>
<p>小伙计的脸红了红，讪讪地笑着，挠了挠头。</p>
<hr>
<p>夜深了，小狐狸喝得酩酊大醉，露出了原形，倒头便睡。</p>
<p>小伙计叹了口气，把她背在了身上，往山上走去。</p>
<p>风一吹，小狐狸毛绒绒的耳朵动了动，蹭的小伙计的脖子发痒，他说：“你醒啦。”</p>
<p>小狐狸的声音有些发颤，说：“你……你是什么时候发现的？”</p>
<p>他笑着说：“你每次来店里喝酒，喝醉了连尾巴都藏不住，你说呢？”</p>
<p>小狐狸哼唧着用小爪子在他背上锤了几下，说：“你……你……”</p>
<p>“好啦好啦，其实，小狐狸就挺可爱的。”</p>
<p>小狐狸的脸红了，她用蚊子一般的声音说：“那你觉得，我变成人，和变回小狐狸，哪个好看？”</p>
<p>小伙计笑了笑，毫不犹豫地回答：“都好看！”</p>
<p>小狐狸的脸红得发烫，她把脸埋进了小伙计的背上，用小爪子捂着，没过多久，又睡着了。</p>
<p>晚安</p>
<p>早安</p>
]]></content>
      <categories>
        <category>睡前故事</category>
      </categories>
      <tags>
        <tag>Hide</tag>
        <tag>睡前故事</tag>
      </tags>
  </entry>
  <entry>
    <title>Swagger笔记</title>
    <url>/2020/11/19/Swagger%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="Swagger"><a href="#Swagger" class="headerlink" title="Swagger"></a>Swagger</h1><ul>
<li>了解Swagger的概念及作用</li>
<li>了解前后端分离</li>
<li>在springboot中集成swagger</li>
</ul>
<h2 id="Swagger简介"><a href="#Swagger简介" class="headerlink" title="Swagger简介"></a>Swagger简介</h2><ul>
<li><h3 id="前言："><a href="#前言：" class="headerlink" title="前言："></a><strong>前言</strong>：</h3></li>
</ul>
<p>　　接口文档对于前后端开发人员都十分重要。尤其近几年流行前后端分离后接口文档又变成重中之重。接口文档固然重要，但是由于项 目周期等原因后端人员经常出现无法及时更新，导致前端人员抱怨接 口文档和实际情况不一致。</p>
<p>　　很多人员会抱怨别人写的接口文档不规范，不及时更新。当时当 自己写的时候确实最烦去写接口文档。这种痛苦只有亲身经历才会牢 记于心。</p>
<p>　　如果接口文档可以实时动态生成就不会出现上面问题。</p>
<p>　　<strong>Swagger</strong> 可以完美的解决上面的问题。</p>
<a id="more"></a>

<ul>
<li><h3 id="Open-API："><a href="#Open-API：" class="headerlink" title="Open API："></a><strong>Open API</strong>：</h3></li>
</ul>
<p>　　Open API 规范(OpenAPI Specification)以前叫做 Swagger 规范，是REST API 的 API 描述格式。</p>
<p>　　Open API 文件允许描述整个 API，包括：</p>
<p>　　　　· 每个访问地址的类型。POST 或 GET。</p>
<p>　　　　·每个操作的参数。包括输入输出参数。</p>
<p>　　　　·认证方法。</p>
<p>　　　　·连接信息，声明，使用团队和其他信息。</p>
<p>　　Open API 规范可以使用 YAML 或 JSON 格式进行编写。这样更利于我们和机器进行阅读。</p>
<p>　　OpenAPI 规范（OAS）为 RESTful API 定义了一个与语言无关的标 准接口，允许人和计算机发现和理解服务的功能，而无需访问源代码， 文档或通过网络流量检查。正确定义后，消费者可以使用最少量的实 现逻辑来理解远程服务并与之交互。然后，文档生成工具可以使用 OpenAPI 定义来显示 API，使用各 种编程语言生成服务器和客户端的代码生成工具，测试工具以及许多 其他用例。</p>
<ul>
<li><h3 id="Swagger-简介："><a href="#Swagger-简介：" class="headerlink" title="Swagger 简介："></a><strong>Swagger 简介</strong>：</h3></li>
</ul>
<p>　　Swagger 是一套围绕 Open API 规范构建的开源工具，可以帮助设 计，构建，记录和使用 REST API。</p>
<p>　　Swagger 工具包括的组件：</p>
<p>　　　　Swagger Editor  ：基于浏览器编辑器，可以在里面编写 Open API规范。类似 Markdown 具有实时预览描述文件的功能。</p>
<p>　　　　Swagger UI：将 Open API 规范呈现为交互式 API 文档。用可视化UI 展示描述文件。</p>
<p>　　　　Swagger Codegen：将 OpenAPI 规范生成为服务器存根和客户端 库。通过 Swagger Codegen 可以将描述文件生成 html 格式和 cwiki 形 式的接口文档，同时也可以生成多种言语的客户端和服务端代码。</p>
<p>　　　　Swagger Inspector：和 Swagger UI 有点类似，但是可以返回更多 信息，也会保存请求的实际参数数据。</p>
<p>　　　　Swagger Hub：集成了上面所有项目的各个功能，你可以以项目 和版本为单位，将你的描述文件上传到 Swagger Hub 中。在 Swagger Hub 中可以完成上面项目的所有工作，需要注册账号，分免费版和收费版。</p>
<p>　　　　使用 Swagger，就是把相关的信息存储在它定义的描述文件里面（yml 或 json 格式），再通过维护这个描述文件可以去更新接口文档， 以及生成各端代码。</p>
<ul>
<li><h3 id="官网：https-swagger-io"><a href="#官网：https-swagger-io" class="headerlink" title="官网：https://swagger.io/"></a>官网：<a href="https://swagger.io/">https://swagger.io/</a></h3></li>
</ul>
<h2 id="SpringBoot集成Swagger"><a href="#SpringBoot集成Swagger" class="headerlink" title="SpringBoot集成Swagger"></a>SpringBoot集成Swagger</h2><p><strong>SpringBoot集成Swagger</strong> =&gt; <strong>springfox</strong>，两个jar包</p>
<ul>
<li><strong><a href="https://mvnrepository.com/artifact/io.springfox/springfox-swagger2">Springfox-swagger2</a></strong></li>
<li><a href="https://mvnrepository.com/artifact/io.springfox/springfox-swagger-ui">springfox-swagger-ui</a></li>
</ul>
<p><strong>使用Swagger</strong></p>
<p>要求：jdk 1.8 + 否则swagger2无法运行</p>
<p>步骤：</p>
<ol>
<li><p>新建一个SpringBoot-web项目</p>
</li>
<li><p>添加Maven依赖（注意：2.9.2版本之前，之后的不行）</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/io.springfox/springfox-swagger-ui --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- https://mvnrepository.com/artifact/io.springfox/springfox-swagger2 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>编写HelloController，测试Swagger</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="4">
<li><p>在配置类编写SwaggerConfig，并配置注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableSwagger2</span>         <span class="comment">//开启Swagger2</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SwaggerConfig</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>访问<a href="http://localhost:8080/swagger-ui.html#%EF%BC%8C%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%88%B0Swagger-ui%E7%95%8C%E9%9D%A2">http://localhost:8080/swagger-ui.html#，可以看到Swagger-ui界面</a></p>
<p><img src="https://plutowu-blogimgs.oss-cn-guangzhou.aliyuncs.com/img/image-20201119192400412.png" alt="image-20201119192400412"></p>
</li>
</ol>
<h2 id="配置Swagger"><a href="#配置Swagger" class="headerlink" title="配置Swagger"></a>配置Swagger</h2><ol>
<li>Swagger通过Docekt的bean实例实现</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 配置了Swagger的Docket的bean实例</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Docket <span class="title">docket</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2)</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>配置Swagger信息可以通过——&gt;apiInfo    </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//配置Swagger信息-&gt;apiInfo</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ApiInfo <span class="title">apiInfo</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        Contact contact = <span class="keyword">new</span> Contact(<span class="string">&quot;PlutoWu&quot;</span>, <span class="string">&quot;https://www.plutowu.top/&quot;</span>, <span class="string">&quot;p1utowu@qq.com&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ApiInfo(</span><br><span class="line">                <span class="string">&quot;Pluto的SwaggerAPI文档&quot;</span>,</span><br><span class="line">                <span class="string">&quot;PlutoWu Swagger&quot;</span>,</span><br><span class="line">                <span class="string">&quot;v1.0&quot;</span>,</span><br><span class="line">                <span class="string">&quot;https://www.plutowu.top/&quot;</span>,</span><br><span class="line">                contact,</span><br><span class="line">                <span class="string">&quot;Apache 2.0&quot;</span>,</span><br><span class="line">                <span class="string">&quot;http://www.apache.org/licenses/LICENSE-2.0&quot;</span>,</span><br><span class="line">                <span class="keyword">new</span> ArrayList());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Docekt关联apiInfo以实现Swagger-UI页面的自主化</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Docket <span class="title">docket</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2)</span><br><span class="line">                .apiInfo(apiInfo());</span><br><span class="line">                &#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><p>重新访问<a href="http://localhost:8080/swagger-ui.html#%EF%BC%8C%E5%A6%82%E4%B8%8B%E5%9B%BE%E6%89%80%E7%A4%BA">http://localhost:8080/swagger-ui.html#，如下图所示</a></p>
<p><img src="https://plutowu-blogimgs.oss-cn-guangzhou.aliyuncs.com/img/image-20201119185622792.png" alt="image-20201119185622792"></p>
</li>
</ol>
<h2 id="配置Swagger扫描接口"><a href="#配置Swagger扫描接口" class="headerlink" title="配置Swagger扫描接口"></a>配置Swagger扫描接口</h2><ol>
<li><p>通过设置Docket下的select()实现对扫描接口的配置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Docket <span class="title">docket</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2)</span><br><span class="line">            .apiInfo(apiInfo())</span><br><span class="line">            .select()</span><br><span class="line">            <span class="comment">// RequestHandlerSelectors，配置要扫描接口的方式</span></span><br><span class="line">            <span class="comment">// basePackage指定要扫描的包</span></span><br><span class="line">            <span class="comment">// any()：扫描全部</span></span><br><span class="line">            <span class="comment">// none()：不扫描</span></span><br><span class="line">            <span class="comment">// withClassAnnotation：扫描类上的注解，参数是一个注解的反射对象</span></span><br><span class="line">            <span class="comment">// withMethodAnnotation：扫描方法上的注解</span></span><br><span class="line">            .apis(RequestHandlerSelectors.basePackage(<span class="string">&quot;com.pluto.swagger.controller&quot;</span>))</span><br><span class="line">            <span class="comment">// path()：过滤什么路径</span></span><br><span class="line">            <span class="comment">// .paths(PathSelectors.ant(&quot;/pluto/**&quot;))</span></span><br><span class="line">            .build();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>现在只能扫描到controller包下的接口</p>
<p><img src="https://plutowu-blogimgs.oss-cn-guangzhou.aliyuncs.com/img/image-20201119193024261.png" alt="image-20201119193024261"></p>
</li>
<li><p>以下为可选的方式包括指定接口、包以及路径</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// RequestHandlerSelectors，配置要扫描接口的方式</span></span><br><span class="line"><span class="comment">// basePackage指定要扫描的包</span></span><br><span class="line"><span class="comment">// any()：扫描全部</span></span><br><span class="line"><span class="comment">// none()：不扫描</span></span><br><span class="line"><span class="comment">// regex(final String pathRegex)：通过正则表达式控制</span></span><br><span class="line"><span class="comment">// ant(final String antPattern)：通过ant()控制</span></span><br><span class="line"><span class="comment">// withClassAnnotation：扫描类上的注解，参数是一个注解的反射对象</span></span><br><span class="line"><span class="comment">// withMethodAnnotation：扫描方法上的注解</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// path()：过滤什么路径</span></span><br><span class="line">.paths(PathSelectors.ant(<span class="string">&quot;/pluto/**&quot;</span>))</span><br></pre></td></tr></table></figure>



<h2 id="配置Swagger开关"><a href="#配置Swagger开关" class="headerlink" title="配置Swagger开关"></a>配置Swagger开关</h2><ol>
<li><p>在Docket下添加如下配置即可实现开关Swagger</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Docket <span class="title">docket</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2)</span><br><span class="line">            .apiInfo(apiInfo())</span><br><span class="line">            .enable(<span class="keyword">false</span>) <span class="comment">// 开关Swagger</span></span><br><span class="line">            .build();</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>

<p>置于false即可看到以下页面</p>
<p><img src="https://plutowu-blogimgs.oss-cn-guangzhou.aliyuncs.com/img/image-20201119193738092.png" alt="image-20201119193738092"></p>
</li>
<li><p>如何动态配置当项目处于test、dev环境时显示swagger，处于prod时不显示？</p>
<ul>
<li>判断是否为生产环境  flag = false</li>
</ul>
<ul>
<li>注入enable  (flag)</li>
</ul>
</li>
</ol>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 应用名称</span></span><br><span class="line"><span class="meta">spring.application.name</span>=<span class="string">swagger-demo</span></span><br><span class="line"><span class="comment"># 应用服务 WEB 访问端口</span></span><br><span class="line"><span class="meta">server.port</span>=<span class="string">8080</span></span><br><span class="line"><span class="meta">spring.profiles.active</span>=<span class="string">dev</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Docket <span class="title">docket</span><span class="params">(Environment environment)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置要显示的Swagger环境</span></span><br><span class="line">        Profiles profiles = Profiles.of(<span class="string">&quot;dev&quot;</span>,<span class="string">&quot;test&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过environment.acceptsProfiles判断自己是否处于自己设定的环境中</span></span><br><span class="line">        <span class="keyword">boolean</span> flag = environment.acceptsProfiles(profiles);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2)</span><br><span class="line">               .apiInfo(apiInfo())</span><br><span class="line">               .enable(<span class="keyword">true</span>)</span><br><span class="line">               .select()</span><br><span class="line">               .apis(RequestHandlerSelectors.basePackage(<span class="string">&quot;com.pluto.swagger.controller&quot;</span>))</span><br><span class="line">               .paths(PathSelectors.ant(<span class="string">&quot;/pluto/**&quot;</span>))</span><br><span class="line">               .build();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://plutowu-blogimgs.oss-cn-guangzhou.aliyuncs.com/img/image-20201119195647700.png" alt="image-20201119195647700"></p>
<p><strong>同理，配置文件更改环境为prod即可切换为发布版本，端口也要相应更改为8082。</strong></p>
<h2 id="配置API分组"><a href="#配置API分组" class="headerlink" title="配置API分组"></a>配置API分组</h2><ol>
<li>默认分组为default，可以通过groupName()方法进行配置分组</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2)</span><br><span class="line">                .apiInfo(apiInfo())</span><br><span class="line">                .groupName(<span class="string">&quot;Pluto&quot;</span>) <span class="comment">// 配置分组</span></span><br><span class="line">                .enable(<span class="keyword">true</span>)</span><br><span class="line">                .select()</span><br><span class="line">                ......</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>重启服务页面显示分组</li>
</ol>
<p><img src="https://plutowu-blogimgs.oss-cn-guangzhou.aliyuncs.com/img/image-20201119200703587.png" alt="image-20201119200703587"></p>
<ol start="3">
<li>配置多个分组——配置多个Docket（别忘了@Bean注解，否则无法注册为实例）</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Docket <span class="title">docket1</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2).groupName(<span class="string">&quot;YaYa&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Docket <span class="title">docket2</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2).groupName(<span class="string">&quot;XiaoGuo&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Docket <span class="title">docket3</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2).groupName(<span class="string">&quot;Lily&quot;</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>重启服务，页面可见多个分组</li>
</ol>
<p><img src="https://plutowu-blogimgs.oss-cn-guangzhou.aliyuncs.com/img/image-20201119201309428.png" alt="image-20201119201309428"></p>
<h2 id="实体配置"><a href="#实体配置" class="headerlink" title="实体配置"></a>实体配置</h2><ol>
<li>新建实体类</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ApiModel(&quot;用户实体类&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;用户名&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String username;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;密码&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String password;</span><br><span class="line">    </span><br><span class="line">    ......</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>配置Controller类，添加请求接口</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 只要我们的接口中，返回值存在实体类，它就会被扫描到Swagger中</span></span><br><span class="line">    <span class="meta">@PostMapping(value = &quot;/user&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">user</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> User();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>重启服务，查看实体类被扫描</li>
</ol>
<p><img src="https://plutowu-blogimgs.oss-cn-guangzhou.aliyuncs.com/img/image-20201119202436940.png" alt="image-20201119202436940"></p>
<p><strong><em>注意：并非@ApiModel让实体类被扫描，而是只要出现在接口方法的返回值上的实体类都会被扫描到，@ApiModelProperty和@ApiModel只是为实体类添加注释所用。</em></strong></p>
<ul>
<li>@ApiModel为类添加注释</li>
<li>@ApiModelProperty为类具体属性添加注释</li>
</ul>
<h2 id="常用Swagger注解"><a href="#常用Swagger注解" class="headerlink" title="常用Swagger注解"></a>常用Swagger注解</h2><p>Swagger的所有注解定义在io.swagger.annotations包下</p>
<p>下面列一些经常用到的，未列举出来的可以另行查阅说明：</p>
<table>
<thead>
<tr>
<th align="center"><strong>Swagger注解</strong></th>
<th align="center"><strong>简单说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center">@Api(tags = “xxx模块说明”)</td>
<td align="center">作用在模块类上</td>
</tr>
<tr>
<td align="center">@ApiOperation(“xxx接口说明”)</td>
<td align="center">作用在接口方法上</td>
</tr>
<tr>
<td align="center">@ApiModel(“xxxPOJO说明”)</td>
<td align="center">作用在模型类上：如VO、BO</td>
</tr>
<tr>
<td align="center">@ApiModelProperty(value = “xxx属性说明”,hidden = true)</td>
<td align="center">作用在类方法和属性上，hidden设置为true可以隐藏该属性</td>
</tr>
<tr>
<td align="center">@ApiParam(“xxx参数说明”)</td>
<td align="center">作用在参数、方法和字段上，类似@ApiModelProperty</td>
</tr>
</tbody></table>
<h2 id="Swagger-GET-POST-测试功能"><a href="#Swagger-GET-POST-测试功能" class="headerlink" title="Swagger(GET/POST)测试功能"></a>Swagger(GET/POST)测试功能</h2><ol>
<li>Controller方法前添加==@ApiOeration==注释</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ApiOperation(&quot;Post测试类&quot;)</span></span><br><span class="line">    <span class="meta">@PostMapping(value = &quot;/post&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">post</span><span class="params">(<span class="meta">@ApiParam(&quot;用户名&quot;)</span> User user)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>重启服务进入Swagger-ui界面进行测试</li>
</ol>
<p><img src="https://plutowu-blogimgs.oss-cn-guangzhou.aliyuncs.com/img/image-20201119205520715.png" alt="image-20201119205520715"></p>
<p><img src="https://plutowu-blogimgs.oss-cn-guangzhou.aliyuncs.com/img/image-20201119205838266.png" alt="image-20201119205838266"></p>
<p><img src="https://plutowu-blogimgs.oss-cn-guangzhou.aliyuncs.com/img/image-20201119205659138.png" alt="image-20201119205659138"></p>
<p><strong>总结：</strong></p>
<ul>
<li>添加注释到一些较难理解的接口或属性，以便增加可读性</li>
<li>可在线测试</li>
<li>API实时更新</li>
</ul>
<p>==注意：在正式版本发布时，需关闭Swagger！！！==</p>
<ul>
<li>处于安全考虑</li>
<li>节省内存</li>
</ul>
<h2 id="拓展（Swagger皮肤切换）"><a href="#拓展（Swagger皮肤切换）" class="headerlink" title="拓展（Swagger皮肤切换）"></a>拓展（Swagger皮肤切换）</h2><ul>
<li>bootstrap-ui <strong>访问 <a href="http://localhost:8080/doc.html">http://localhost:8080/doc.html</a></strong>进入UI</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 引入swagger-bootstrap-ui包 /doc.html--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.xiaoymin<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>swagger-bootstrap-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://plutowu-blogimgs.oss-cn-guangzhou.aliyuncs.com/img/image-20201119210101794.png" alt="image-20201119210101794"></p>
<ul>
<li>mg-ui <strong>访问 <a href="http://localhost:8080/document.html">http://localhost:8080/document.html</a></strong>进入UI</li>
</ul>
<p><img src="https://plutowu-blogimgs.oss-cn-guangzhou.aliyuncs.com/img/image-20201119210351394.png" alt="image-20201119210351394"></p>
]]></content>
      <categories>
        <category>编程</category>
        <category>Java Web</category>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Java Web</tag>
        <tag>Swagger</tag>
      </tags>
  </entry>
  <entry>
    <title>睡前故事-活了100万次的猫</title>
    <url>/2020/11/18/%E7%9D%A1%E5%89%8D%E6%95%85%E4%BA%8B-%E6%B4%BB%E4%BA%86100%E4%B8%87%E6%AC%A1%E7%9A%84%E7%8C%AB/</url>
    <content><![CDATA[<p>有一只100万年也不死的猫。</p>
<p>其实猫死了100万次，又活了100万次。</p>
<p>是一只漂亮的虎斑猫。 有100万个人宠爱过这只猫，有100万个人在这只猫死的时候哭过。</p>
<p>可是猫连一次也没有哭过。</p>
<a id="more"></a>

<hr>
<p>有一回，猫是国王的猫。</p>
<p>猫讨厌什么国王。</p>
<p>国王爱打仗，总是发动战争。而且，他还把猫用一个漂亮的篮子装起来，带到战场上。有一天，猫被一支飞来的箭射死了。</p>
<p>正打着仗，国王却抱着猫哭了起来。</p>
<p>国王仗也不打了，回到了王宫，然后，把猫埋到了王宫的院子里。</p>
<hr>
<p>有一回，猫是水手的猫。</p>
<p>猫讨厌什么水手。</p>
<p>水手带着猫走遍了全世界的大海和全世界的码头。</p>
<p>有一天，猫从船上掉了下来。</p>
<p>因为猫不会游泳，水手连忙用网子捞了上来，可猫还是淹死了。</p>
<p>水手抱着湿得像一块抹布似的猫，大声地哭起来。然后，把猫埋到了遥远的港口小镇的公园的树下。</p>
<hr>
<p>有一回，猫是马戏团魔术师的猫。</p>
<p>猫讨厌什么马戏团。</p>
<p>魔术师每天把猫装到一个箱子里，用锯子锯成两半儿，接着再把完好无损的猫从箱子里取出来，换来一片拍手声。</p>
<p>有一天，魔术师失手了，真的把猫锯成了两半儿。</p>
<p>魔术师两手拎着两半儿的猫，大声地哭起来。</p>
<p>这次，谁也没有拍手。</p>
<p>魔术师把猫埋到了马戏场的后面。</p>
<hr>
<p>有一回，猫是小偷的猫。</p>
<p>猫讨厌什么小偷。</p>
<p>小偷和猫一起，在漆黑的小镇上，像猫一样轻轻地转来转去。</p>
<p>小偷只偷养狗的人家。趁着狗冲猫叫的时候，小偷撬开保险箱。</p>
<p>一天，猫被狗给咬死了。</p>
<p>小偷抱着偷来的钻石和猫，在夜晚的小镇上一边大声地哭，一边走。然后，回到家里，把猫埋到了小小的院子里。</p>
<hr>
<p>有一回，猫是一个孤零零的老太太的猫。</p>
<p>猫讨厌什么老太太。</p>
<p>老太太每天抱着猫，从小窗户看着外面。</p>
<p>猫整天在老太太的腿上睡大觉。</p>
<p>不久，猫老死了。摇摇晃晃的老太太抱着摇摇晃晃的死了的猫，哭了一整天。</p>
<p>老太太把猫埋到了院子的树底下。</p>
<hr>
<p>有一回，猫是一个小女孩的猫。</p>
<p>猫讨厌什么小女孩。</p>
<p>小女孩有时把猫背在背上玩，有时紧紧抱着猫睡觉。她哭的时候，还会用猫的后背来擦眼泪。</p>
<p>有一天，猫被小女孩后背的带子给勒死了。</p>
<p>小女孩抱着耷拉着脑袋的猫，哭了一整天。然后，她把猫埋到了院子的树底下。</p>
<hr>
<p>猫已经不在乎死亡了。</p>
<p>有一回，猫不再是别人的猫了。</p>
<p>成了一只野猫。</p>
<p>猫头一次变成了自己的猫。</p>
<p>猫太喜欢自己了。</p>
<p>怎么说呢，漂亮的虎斑猫终于变成了漂亮的野猫。</p>
<p>不管是哪一只母猫，都想成为猫的新娘。</p>
<p>有的送条大鱼当礼物，有的献上新鲜的老鼠，有的送来了少见的木天蓼，还有的去舔猫那漂亮的虎斑纹。</p>
<p>可猫却说：</p>
<p>“我可死过100万次呢！我才不吃这一套！”</p>
<p>因为猫比谁都喜欢自己。</p>
<hr>
<p>只有一只猫连看也不看他一眼，是一只美丽的白猫。</p>
<p>猫走过去说：“我可死过100万次呢！”</p>
<p>“噢。”</p>
<p>白猫只说了这么一声。</p>
<p>猫有点生气了，怎么说呢，因为他太喜欢自己了。</p>
<p>第二天、第三天，猫都走到白猫的身边，说：“你还一次也没活完吧？”</p>
<p>“噢。”</p>
<p>白猫只说了这么一声。</p>
<p>有一天，猫在白猫面前一连翻了三个跟头，说：</p>
<p>“我呀，曾经是马戏团的猫呢。”</p>
<p>“噢。”</p>
<p>白猫只说了这么一声。</p>
<p>“我呀，我死过100万次……”</p>
<p>说到一半的时候，猫问白猫：“我可以待在你身边吗？”</p>
<p>“行呀。”</p>
<p>白猫说。</p>
<p>就这样，他一直待在了白猫的身边。</p>
<p>白猫生了好多可爱的小猫。</p>
<p>猫再也不说“我呀，我死过100万次……”了。</p>
<p>猫比喜欢自己还要喜欢白猫和小猫们。</p>
<p>小猫们很快就长大了，一个个走掉了。</p>
<p>“他们都成了漂亮的野猫啦。”</p>
<p>“是啊。”</p>
<p>白猫说，然后她的嗓子眼儿里发出了温柔的“咕噜咕噜”声。</p>
<p>白猫已经成了一个老奶奶了。</p>
<p>猫对白猫更温柔了，嗓子眼儿里也发出了“咕噜咕噜”声。</p>
<p>猫多想和白猫永远地一起活下去呀！</p>
<hr>
<p>有一天，白猫静静地躺倒在猫的怀里一动也不动了。</p>
<p>猫抱着白猫，流下了大滴大滴的眼泪，猫头一次哭了。从晚上哭到早上，又从早上哭到晚上。哭啊哭啊，猫哭了有100万次。</p>
<p>早上、晚上……一天中午，猫的哭声停止了。</p>
<p>猫也静静地、一动不动地躺在了白猫的身边。</p>
<p>猫再也没有起死回生过。</p>
<hr>
<p>“在天愿作比翼鸟，在地愿为连理枝。”在绘本的最后，画着一株并蒂双生的花。这便是最美丽的爱。一百万次生命的经历，使他深深懂得，爱，来之不易、幸福、得之不易。<br>猫在他第一百万零一次生命中，诠释了幸福的真谛，那便是真正的幸福！</p>
]]></content>
      <categories>
        <category>睡前故事</category>
      </categories>
      <tags>
        <tag>Hide</tag>
        <tag>睡前故事</tag>
      </tags>
  </entry>
  <entry>
    <title>git clone加速问题解决方案</title>
    <url>/2020/11/17/git-clone%E5%8A%A0%E9%80%9F%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<h1 id="Git-Clone速度过慢解决方案"><a href="#Git-Clone速度过慢解决方案" class="headerlink" title="Git Clone速度过慢解决方案"></a>Git Clone速度过慢解决方案</h1><h1 id="1-方案一-使用gitclone-com加速"><a href="#1-方案一-使用gitclone-com加速" class="headerlink" title="1.方案一 使用gitclone.com加速"></a>1.方案一 使用gitclone.com加速</h1><p><strong><em>访问gitclone加速的官网<a href="https://gitclone.com,可以通过搜索栏搜索克隆项目/">https://gitclone.com，可以通过搜索栏搜索克隆项目</a></em></strong></p>
<p><img src="https://plutowu-blogimgs.oss-cn-guangzhou.aliyuncs.com/img/image-20201117222630897.png"></p>
<a id="more"></a>

<p><strong>其也提供了三种自定义加速方法（省去在GitClone搜索相应文件）</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">方法一（替换URL）</span><br><span class="line"></span><br><span class="line">git clone https://gitclone.com/github.com/tendermint/tendermint.git</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">方法二（设置git参数）</span><br><span class="line"></span><br><span class="line">git config --global url.&quot;https://gitclone.com/&quot;.insteadOf https://</span><br><span class="line">git clone https://github.com/tendermint/tendermint.git</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">方法三（使用cgit客户端）</span><br><span class="line"></span><br><span class="line">cgit clone https://github.com/tendermint/tendermint.git</span><br></pre></td></tr></table></figure>

<p><strong>搜索图例：</strong></p>
<p><img src="https://plutowu-blogimgs.oss-cn-guangzhou.aliyuncs.com/img/image-20201117223120221.png"></p>
<h1 id="2-方案二-使用Gitee转载仓库"><a href="#2-方案二-使用Gitee转载仓库" class="headerlink" title="2.方案二 使用Gitee转载仓库"></a>2.方案二 使用Gitee转载仓库</h1><h2 id="1-登录gitee-com"><a href="#1-登录gitee-com" class="headerlink" title="1.登录gitee.com"></a>1.登录gitee.com</h2><p><img src="https://plutowu-blogimgs.oss-cn-guangzhou.aliyuncs.com/img/Snipaste_2020-11-17_23-27-48.png"></p>
<h2 id="2-获取GitHub仓库URL"><a href="#2-获取GitHub仓库URL" class="headerlink" title="2.获取GitHub仓库URL"></a>2.获取GitHub仓库URL</h2><p><img src="https://plutowu-blogimgs.oss-cn-guangzhou.aliyuncs.com/img/Snipaste_2020-11-17_23-32-22.png"></p>
<h2 id="3-填写URL"><a href="#3-填写URL" class="headerlink" title="3.填写URL"></a>3.填写URL</h2><p><img src="https://plutowu-blogimgs.oss-cn-guangzhou.aliyuncs.com/img/Snipaste_2020-11-17_23-34-39.png"></p>
<h2 id="4-拉取仓库到Gitee完成"><a href="#4-拉取仓库到Gitee完成" class="headerlink" title="4.拉取仓库到Gitee完成"></a>4.拉取仓库到Gitee完成</h2><p><img src="https://plutowu-blogimgs.oss-cn-guangzhou.aliyuncs.com/img/Snipaste_2020-11-17_23-36-37.png"></p>
<h2 id="5-git-clone仓库"><a href="#5-git-clone仓库" class="headerlink" title="5.git clone仓库"></a>5.git clone仓库</h2><p><img src="https://plutowu-blogimgs.oss-cn-guangzhou.aliyuncs.com/img/Snipaste_2020-11-17_23-38-41.png"></p>
<hr>
<p><strong>总的来说，两种方法中gitclone.com会出现时常不稳定的现象，不过大部分时间都能够以高速克隆仓库。不到必要时刻，不推荐使用gitee二次搬运仓库，因为流程较为繁琐</strong></p>
]]></content>
      <categories>
        <category>教程</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title>Servlet实例总结</title>
    <url>/2020/11/17/Servlet%E5%AE%9E%E4%BE%8B%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="Servlet实例总结-基于Java、SQLserver、Tomcat"><a href="#Servlet实例总结-基于Java、SQLserver、Tomcat" class="headerlink" title="Servlet实例总结-基于Java、SQLserver、Tomcat"></a>Servlet实例总结-基于Java、SQLserver、Tomcat</h1><h2 id="题目及要求"><a href="#题目及要求" class="headerlink" title="题目及要求:"></a>题目及要求:</h2><h3 id="使用Java-Bean-Servlet-Jsp实现下列目标"><a href="#使用Java-Bean-Servlet-Jsp实现下列目标" class="headerlink" title="使用Java Bean+Servlet+Jsp实现下列目标"></a><strong>使用Java Bean+Servlet+Jsp实现下列目标</strong></h3><ol>
<li>任务一：在数据库中建立表格T_BOOK(BID, BNAME, BAUTHER, BPRICE, BAMOUNT, BPUBDATE)，并向表中添加一些记录，T_BOOK数据表结构如下：</li>
</ol>
<p>表1-2 T_BOOK数据表</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>列名</th>
<th>含义</th>
<th>类型</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>BID</td>
<td>书号</td>
<td>VARCHAR(20)</td>
<td>“B0001”</td>
</tr>
<tr>
<td>2</td>
<td>BNAME</td>
<td>书名</td>
<td>VARCHAR(50)</td>
<td></td>
</tr>
<tr>
<td>3</td>
<td>BAUTHER</td>
<td>作者</td>
<td>VARCHAR(50)</td>
<td></td>
</tr>
<tr>
<td>4</td>
<td>BTYPE</td>
<td>类型</td>
<td>VARCHAR(50)</td>
<td>计算机、文学</td>
</tr>
<tr>
<td>5</td>
<td>BPRICE</td>
<td>价格</td>
<td>INT</td>
<td></td>
</tr>
<tr>
<td>6</td>
<td>BAMOUNT</td>
<td>数量</td>
<td>INT</td>
<td></td>
</tr>
<tr>
<td>7</td>
<td>BPUBDATE</td>
<td>出版日期</td>
<td>DATE</td>
<td>2000-1-1</td>
</tr>
</tbody></table>
<ol start="2">
<li><p>任务二：编写程序，在JSP页面中提供表单，用户可填写图书数据，向T_BOOK表中添加一条记录。</p>
</li>
<li><p>任务三：编写程序，在JSP页面提供按书名模糊查询功能，用户输入书名部分或全部内容，查询的结果显示在JSP页面上。</p>
</li>
<li><p>任务四：编写程序，在JSP页面中提供按价格区间查询功能，用户可填写两个价格，查询出两个价格之间的图书结果显示在JSP页面上。</p>
</li>
<li><p>任务五：编写程序，在JSP页面中提供按书号更新书籍数量功能，用户输入书号、数量，可更新数据表中的记录。</p>
</li>
</ol>
<a id="more"></a>

<hr>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现:"></a>实现:</h3><h5 id="任务1：使用图形化建立数据库及建表，如下图："><a href="#任务1：使用图形化建立数据库及建表，如下图：" class="headerlink" title="任务1：使用图形化建立数据库及建表，如下图："></a>任务1：使用图形化建立数据库及建表，如下图：</h5><p><img src="https://img-blog.csdnimg.cn/20201117121051611.jpg#pic_center" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/20201117121051621.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzgyNDEzOQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20201117121051649.jpg#pic_center" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/20201117142430287.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzgyNDEzOQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<!-- more -->

<hr>
<h5 id="任务2：增加记录，使用post传值，设置简易窗口即可，注意SQL语句的正确。"><a href="#任务2：增加记录，使用post传值，设置简易窗口即可，注意SQL语句的正确。" class="headerlink" title="任务2：增加记录，使用post传值，设置简易窗口即可，注意SQL语句的正确。"></a>任务2：增加记录，使用post传值，设置简易窗口即可，注意SQL语句的正确。</h5><p><strong>代码如下：</strong></p>
<p>DbBean.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.etspace.abc.jdbc;</span><br><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DbBean</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Statement stmt=<span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">private</span> Connection conn=<span class="keyword">null</span>;</span><br><span class="line">	ResultSet rs=<span class="keyword">null</span>;</span><br><span class="line">	<span class="comment">//构造函数</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">DbBean</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">	<span class="comment">//打开连接</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">openConnection</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">try</span></span><br><span class="line">		&#123;</span><br><span class="line">			Class.forName(<span class="string">&quot;com.microsoft.sqlserver.jdbc.SQLServerDriver&quot;</span>).newInstance();</span><br><span class="line">			String url=<span class="string">&quot;jdbc:sqlserver://localhost:1433;databaseName=book&quot;</span>;</span><br><span class="line">			String user=<span class="string">&quot;sa&quot;</span>;</span><br><span class="line">			String password=<span class="string">&quot;wsy0910&quot;</span>;</span><br><span class="line">			conn=DriverManager.getConnection(url, user, password);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span>(ClassNotFoundException e)</span><br><span class="line">		&#123;</span><br><span class="line">			System.err.println(<span class="string">&quot;openConn:&quot;</span>+e.getMessage());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span>(SQLException e)</span><br><span class="line">		&#123;</span><br><span class="line">			System.err.println(<span class="string">&quot;openConn:&quot;</span>+e.getMessage());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//执行查询类的SQL语句</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> ResultSet <span class="title">executeQuery</span><span class="params">(String sql)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		rs=<span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">try</span></span><br><span class="line">		&#123;</span><br><span class="line">			stmt=conn.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE);</span><br><span class="line">			rs=stmt.executeQuery(sql);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span>(SQLException e)</span><br><span class="line">		&#123;</span><br><span class="line">			System.err.println(<span class="string">&quot;executeQuery:&quot;</span>+e.getMessage());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> rs;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//执行更新类的SQL语句</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">executeUpdate</span><span class="params">(String sql)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">try</span>&#123;</span><br><span class="line">			stmt=conn.createStatement();</span><br><span class="line">			n=stmt.executeUpdate(sql);</span><br><span class="line">		&#125;<span class="keyword">catch</span>(Exception e)</span><br><span class="line">		&#123;</span><br><span class="line">			System.out.print(e.toString());</span><br><span class="line">		&#125; </span><br><span class="line">		<span class="keyword">return</span> n;</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="comment">//关闭连接</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">closeConnection</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">try</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (rs!=<span class="keyword">null</span>)</span><br><span class="line">				rs.close();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span>(SQLException e)</span><br><span class="line">		&#123;</span><br><span class="line">			System.err.println(<span class="string">&quot;closeRs:&quot;</span>+e.getMessage());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">try</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (stmt!=<span class="keyword">null</span>)</span><br><span class="line">				stmt.close();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span>(SQLException e)</span><br><span class="line">		&#123;</span><br><span class="line">			System.err.println(<span class="string">&quot;closeStmt:&quot;</span>+e.getMessage());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">try</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (conn!=<span class="keyword">null</span>)</span><br><span class="line">				conn.close();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span>(SQLException e)</span><br><span class="line">		&#123;</span><br><span class="line">			System.err.println(<span class="string">&quot;closeConn:&quot;</span>+e.getMessage());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>tszjServlet.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.etspace.abc.servlet;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.etspace.abc.jdbc.DbBean;</span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;serial&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">tszjServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">		doPost(request,response);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">		request.setCharacterEncoding(<span class="string">&quot;gb2312&quot;</span>);</span><br><span class="line">		response.setCharacterEncoding(<span class="string">&quot;gb2312&quot;</span>);</span><br><span class="line">		response.setContentType(<span class="string">&quot;text/html;charset=gb2312&quot;</span>);</span><br><span class="line">		PrintWriter out = response.getWriter();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			String BID =  request.getParameter(<span class="string">&quot;BID&quot;</span>);</span><br><span class="line">			String BNAME =  request.getParameter(<span class="string">&quot;BNAME&quot;</span>);</span><br><span class="line">			String BAUTHER =  request.getParameter(<span class="string">&quot;BAUTHER&quot;</span>);</span><br><span class="line">			String BTYPE =  request.getParameter(<span class="string">&quot;BTYPE&quot;</span>);</span><br><span class="line">			String BPRICE =  request.getParameter(<span class="string">&quot;BPRICE&quot;</span>);</span><br><span class="line">			String BAMOUNT =  request.getParameter(<span class="string">&quot;BAMOUNT&quot;</span>);</span><br><span class="line">			String BPUBDATE =  request.getParameter(<span class="string">&quot;BPUBDATE&quot;</span>);	</span><br><span class="line">			String sql = <span class="string">&quot;insert into T_BOOK(BID,BNAME,BAUTHER,BTYPE,BPRICE,BAMOUNT,BPUBDATE)&quot;</span>;</span><br><span class="line">			sql=sql+<span class="string">&quot; values(&#x27;&quot;</span>+BID+<span class="string">&quot;&#x27;,&#x27;&quot;</span>+BNAME+<span class="string">&quot;&#x27;,&#x27;&quot;</span>+BAUTHER+<span class="string">&quot;&#x27;,&#x27;&quot;</span>+BTYPE+<span class="string">&quot;&#x27;,&#x27;&quot;</span>+BPRICE+<span class="string">&quot;&#x27;,&quot;</span>+BAMOUNT+<span class="string">&quot;,&#x27;&quot;</span>+BPUBDATE+<span class="string">&quot;&#x27;)&quot;</span>;</span><br><span class="line">			<span class="comment">//out.print(sql);</span></span><br><span class="line">			DbBean myDbBean=<span class="keyword">new</span> DbBean();</span><br><span class="line">			myDbBean.openConnection();</span><br><span class="line">	        <span class="keyword">int</span> n = myDbBean.executeUpdate(sql);</span><br><span class="line">	        <span class="keyword">if</span> (n&gt;<span class="number">0</span>)&#123;</span><br><span class="line">	       		out.print(<span class="string">&quot;图书记录增加成功！&quot;</span>);</span><br><span class="line">	        &#125;</span><br><span class="line">	       	<span class="keyword">else</span> &#123;</span><br><span class="line">	       		out.print(<span class="string">&quot;图书记录增加失败！&quot;</span>);</span><br><span class="line">	       	&#125; </span><br><span class="line">			myDbBean.closeConnection();</span><br><span class="line">		&#125; </span><br><span class="line">		<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			out.print(e.toString());			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>tszj.jsp</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=gb2312&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.sql.*&quot;</span>%&gt;</span><br><span class="line">&lt;jsp:useBean id=&quot;myDbBean&quot; scope=&quot;page&quot; class=&quot;org.etspace.abc.jdbc.DbBean&quot;&gt;&lt;/jsp:useBean&gt;</span><br><span class="line">&lt;%request.setCharacterEncoding(<span class="string">&quot;gb2312&quot;</span>); %&gt;</span><br><span class="line">&lt;script language=<span class="string">&quot;JavaScript&quot;</span>&gt;</span><br><span class="line"><span class="function">function <span class="title">check</span><span class="params">(theForm)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (theForm.BID.value.length != <span class="number">5</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    alert(<span class="string">&quot;书号必须为5位！&quot;</span>);</span><br><span class="line">    theForm.BID.focus();</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">false</span>);</span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="keyword">if</span> (theForm.BNAME.value == <span class="string">&quot;&quot;</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    alert(<span class="string">&quot;请输入书名！&quot;</span>);</span><br><span class="line">    theForm.BNAME.focus();</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (theForm.BPUBDATE.value == <span class="string">&quot;&quot;</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    alert(<span class="string">&quot;请输入出版日期！&quot;</span>);</span><br><span class="line">    theForm.BPUBDATE.focus();</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (theForm.BAMOUNT.value == <span class="string">&quot;&quot;</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    alert(<span class="string">&quot;请输入数量！&quot;</span>);</span><br><span class="line">    theForm.BAMOUNT.focus();</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (theForm.BPRICE.value == <span class="string">&quot;&quot;</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    alert(<span class="string">&quot;请输入价格！&quot;</span>);</span><br><span class="line">    theForm.BPRICE.focus();</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (theForm.BAUTHER.value == <span class="string">&quot;&quot;</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    alert(<span class="string">&quot;请输入作者！&quot;</span>);</span><br><span class="line">    theForm.BAUTHER.focus();</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (theForm.BTYPE.value == <span class="string">&quot;&quot;</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    alert(<span class="string">&quot;请输入类型！&quot;</span>);</span><br><span class="line">    theForm.BTYPE.focus();</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">false</span>);</span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;&lt;title&gt;图书增加&lt;/title&gt;&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div align=<span class="string">&quot;center&quot;</span>&gt;</span><br><span class="line">  &lt;P&gt;图书增加&lt;/P&gt;</span><br><span class="line">&lt;form id=<span class="string">&quot;form1&quot;</span> name=<span class="string">&quot;form1&quot;</span> method=<span class="string">&quot;post&quot;</span> action=<span class="string">&quot;tszjServlet&quot;</span> onSubmit=<span class="string">&quot;return check(this)&quot;</span>&gt;</span><br><span class="line">	&lt;table border=<span class="string">&quot;1&quot;</span>&gt;</span><br><span class="line">	&lt;tr&gt;&lt;td&gt;书号&lt;/td&gt;&lt;td&gt;&lt;input name=&quot;BID&quot; type=&quot;text&quot; id=&quot;BID&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;</span><br><span class="line">	&lt;tr&gt;&lt;td&gt;书名&lt;/td&gt;&lt;td&gt;&lt;input name=&quot;BNAME&quot; type=&quot;text&quot; id=&quot;BNAME&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;</span><br><span class="line">	&lt;tr&gt;&lt;td&gt;作者&lt;/td&gt;&lt;td&gt;&lt;input name=&quot;BAUTHER&quot; type=&quot;text&quot; id=&quot;BAUTHER&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;</span><br><span class="line">	&lt;tr&gt;&lt;td&gt;类型&lt;/td&gt;&lt;td&gt;</span><br><span class="line">	&lt;input type=<span class="string">&quot;radio&quot;</span> name=<span class="string">&quot;BTYPE&quot;</span> value=<span class="string">&quot;计算机&quot;</span> checked=<span class="string">&quot;checked&quot;</span> /&gt;计算机 </span><br><span class="line">	&lt;input type=<span class="string">&quot;radio&quot;</span> name=<span class="string">&quot;BTYPE&quot;</span> value=<span class="string">&quot;文学&quot;</span> /&gt;文学 </span><br><span class="line">	&lt;/td&gt;&lt;/tr&gt;</span><br><span class="line">&lt;%</span><br><span class="line">		String sql = <span class="string">&quot;select * from BID order by T_BOOK&quot;</span>;</span><br><span class="line">		myDbBean.openConnection();</span><br><span class="line">		ResultSet rs=myDbBean.executeQuery(sql);</span><br><span class="line">%&gt;</span><br><span class="line">	&lt;/td&gt;&lt;/tr&gt;</span><br><span class="line">	&lt;tr&gt;&lt;td&gt;价格&lt;/td&gt;&lt;td&gt;&lt;input name=&quot;BPRICE&quot; type=&quot;text&quot; id=&quot;BPRICE&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;</span><br><span class="line">	&lt;tr&gt;&lt;td&gt;数量&lt;/td&gt;&lt;td&gt;&lt;input name=&quot;BAMOUNT&quot; type=&quot;text&quot; id=&quot;BAMOUNT&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;</span><br><span class="line">	&lt;tr&gt;&lt;td&gt;出版日期&lt;/td&gt;&lt;td&gt;&lt;input name=&quot;BPUBDATE&quot; type=&quot;text&quot; id=&quot;BPUBDATE&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;</span><br><span class="line">	&lt;/table&gt;</span><br><span class="line">	&lt;br&gt;</span><br><span class="line">  	&lt;input name=<span class="string">&quot;submit&quot;</span> type=<span class="string">&quot;submit&quot;</span>  value=<span class="string">&quot;确定&quot;</span> /&gt;</span><br><span class="line">  	&lt;input name=<span class="string">&quot;reset&quot;</span> type=<span class="string">&quot;reset&quot;</span> value=<span class="string">&quot;重置&quot;</span> /&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p><strong>截图如下：</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20201117121051785.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzgyNDEzOQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20201117121051789.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzgyNDEzOQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<hr>
<h5 id="任务3：模糊查询，设置一个实体类Book，注意SQL语句的准确即可，此题我用直接输出，可用List列表进行输出。"><a href="#任务3：模糊查询，设置一个实体类Book，注意SQL语句的准确即可，此题我用直接输出，可用List列表进行输出。" class="headerlink" title="任务3：模糊查询，设置一个实体类Book，注意SQL语句的准确即可，此题我用直接输出，可用List列表进行输出。"></a>任务3：模糊查询，设置一个实体类Book，注意SQL语句的准确即可，此题我用直接输出，可用List列表进行输出。</h5><p><strong>代码如下：</strong></p>
<p>Book.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.etspace.abc.bean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Book</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> String BID;</span><br><span class="line">	<span class="keyword">public</span> String BNAME;</span><br><span class="line">	<span class="keyword">public</span> String BAUTHER;</span><br><span class="line">	<span class="keyword">public</span> String BTYPE;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">int</span> BPRICE;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">int</span> BAMOUNT;</span><br><span class="line">	<span class="keyword">public</span> String BPUBDATE;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getBID</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> BID;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBID</span><span class="params">(String BID)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.BID = BID;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getBNAME</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> BNAME;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBNAME</span><span class="params">(String BNAME)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.BNAME = BNAME;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getBAUTHER</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> BAUTHER;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBAUTHER</span><span class="params">(String BAUTHER)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.BAUTHER = BAUTHER;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getBTYPE</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> BTYPE;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBTYPE</span><span class="params">(String BTYPE)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.BTYPE = BTYPE;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getBPRICE</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> BPRICE;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBPRICE</span><span class="params">(<span class="keyword">int</span> BPRICE)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.BPRICE = BPRICE;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getBAMOUNT</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> BAMOUNT;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBAMOUNT</span><span class="params">(<span class="keyword">int</span> BAMOUNT)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.BAMOUNT = BAMOUNT;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getBPUBDATE</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> BPUBDATE;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBPUBDATE</span><span class="params">(String BPUBDATE)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.BPUBDATE = BPUBDATE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>mhcxServlet.java</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">package org.etspace.abc.servlet;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.PrintWriter;</span><br><span class="line">import java.sql.ResultSet;</span><br><span class="line"></span><br><span class="line">import javax.servlet.ServletException;</span><br><span class="line">import javax.servlet.annotation.WebServlet;</span><br><span class="line">import javax.servlet.http.HttpServlet;</span><br><span class="line">import javax.servlet.http.HttpServletRequest;</span><br><span class="line">import javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line">import org.etspace.abc.jdbc.DbBean;</span><br><span class="line">@<span class="constructor">WebServlet(<span class="string">&quot;/mhcxServlet&quot;</span>)</span></span><br><span class="line">@<span class="constructor">SuppressWarnings(<span class="string">&quot;serial&quot;</span>)</span></span><br><span class="line">public <span class="keyword">class</span> mhcxServlet extends HttpServlet &#123;</span><br><span class="line">	public void <span class="keyword">do</span><span class="constructor">Get(HttpServletRequest <span class="params">request</span>, HttpServletResponse <span class="params">response</span>)</span></span><br><span class="line">			throws ServletException, IOException &#123;</span><br><span class="line">		<span class="keyword">do</span><span class="constructor">Post(<span class="params">request</span>,<span class="params">response</span>)</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	public void <span class="keyword">do</span><span class="constructor">Post(HttpServletRequest <span class="params">request</span>, HttpServletResponse <span class="params">response</span>)</span></span><br><span class="line">			throws ServletException, IOException &#123;</span><br><span class="line">		request.set<span class="constructor">CharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>)</span>;</span><br><span class="line">		response.set<span class="constructor">CharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>)</span>;</span><br><span class="line">		response.set<span class="constructor">ContentType(<span class="string">&quot;text/html;charset=UTF-8&quot;</span>)</span>;</span><br><span class="line">		PrintWriter out = response.get<span class="constructor">Writer()</span>;</span><br><span class="line">		</span><br><span class="line">			String input = request.get<span class="constructor">Parameter(<span class="string">&quot;input&quot;</span>)</span>;</span><br><span class="line">			String sql = <span class="string">&quot;select * from T_BOOK where BNAME like &#x27;%&quot;</span>+input+<span class="string">&quot;%&#x27;&quot;</span>;</span><br><span class="line">			<span class="comment">//like实现模糊查询</span></span><br><span class="line">			DbBean myDbBean=<span class="keyword">new</span> <span class="constructor">DbBean()</span>;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				myDbBean.<span class="keyword">open</span><span class="constructor">Connection()</span>;</span><br><span class="line">			&#125; catch (Exception e1) &#123;</span><br><span class="line">				<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">				e1.print<span class="constructor">StackTrace()</span>;</span><br><span class="line">			&#125;</span><br><span class="line">	        ResultSet rs = myDbBean.execute<span class="constructor">Query(<span class="params">sql</span>)</span>;</span><br><span class="line">	        <span class="keyword">try</span> &#123;    </span><br><span class="line">	        <span class="keyword">while</span>(rs.next<span class="literal">()</span>)&#123;</span><br><span class="line">	        	out.println(</span><br><span class="line">	        			<span class="string">&quot;&lt;font color=\&#x27;blue\&#x27; size=\&#x27;2\&#x27; face=\&#x27;Arial\&#x27; &gt;&quot;</span></span><br><span class="line">	        			+ <span class="string">&quot;书号：&quot;</span>+rs.get<span class="constructor">String(<span class="string">&quot;BID&quot;</span>)</span>+</span><br><span class="line">	        			<span class="string">&quot;  书名：&quot;</span>+rs.get<span class="constructor">String(<span class="string">&quot;BNAME&quot;</span>)</span>+</span><br><span class="line">	        			<span class="string">&quot;  作者：&quot;</span>+rs.get<span class="constructor">String(<span class="string">&quot;BAUTHER&quot;</span>)</span>+</span><br><span class="line">	        			<span class="string">&quot;  类型：&quot;</span>+rs.get<span class="constructor">String(<span class="string">&quot;BTYPE&quot;</span>)</span>+</span><br><span class="line">	        			<span class="string">&quot;  价格：&quot;</span>+rs.get<span class="constructor">String(<span class="string">&quot;BPRICE&quot;</span>)</span>+</span><br><span class="line">	        			<span class="string">&quot;  数量：&quot;</span>+rs.get<span class="constructor">String(<span class="string">&quot;BAMOUNT&quot;</span>)</span>+</span><br><span class="line">	        			<span class="string">&quot;  出版日期：&quot;</span>+rs.get<span class="constructor">String(<span class="string">&quot;BPUBDATE&quot;</span>)</span></span><br><span class="line">	        			);<span class="comment">//直接打印，并修改字体大小颜色，使适应界面</span></span><br><span class="line">	        	out.println(<span class="string">&quot;&lt;br&gt;&quot;</span>);</span><br><span class="line">	        &#125;</span><br><span class="line">	        rs.close<span class="literal">()</span>;</span><br><span class="line">			myDbBean.close<span class="constructor">Connection()</span>;</span><br><span class="line">		&#125; </span><br><span class="line">		catch (Exception e) &#123;</span><br><span class="line">			out.print(e.<span class="keyword">to</span><span class="constructor">String()</span>);			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>mhcx.jsp</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;%@ page language=<span class="string">&quot;java&quot;</span> contentType=<span class="string">&quot;text/html; charset=UTF-8&quot;</span></span><br><span class="line">    pageEncoding=<span class="string">&quot;UTF-8&quot;</span>%&gt;</span><br><span class="line">&lt;!DOCTYPE html PUBLIC <span class="string">&quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;</span> <span class="string">&quot;http://www.w3.org/TR/html4/loose.dtd&quot;</span>&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta http-equiv=<span class="string">&quot;Content-Type&quot;</span> content=<span class="string">&quot;text/html; charset=UTF-8&quot;</span>&gt;</span><br><span class="line">&lt;title&gt;模糊查询&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">	&lt;div align=<span class="string">&quot;center&quot;</span>&gt;</span><br><span class="line">	&lt;p&gt;模糊查询&lt;/p&gt;</span><br><span class="line">	&lt;form action=<span class="string">&quot;mhcxServlet&quot;</span> method=<span class="string">&quot;post&quot;</span>&gt;</span><br><span class="line">	&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;input&quot;</span>/&gt;&lt;br&gt;</span><br><span class="line">	&lt;input type=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;确定&quot;</span>/&gt;</span><br><span class="line">	&lt;input type=<span class="string">&quot;reset&quot;</span> value=<span class="string">&quot;重置&quot;</span>/&gt;</span><br><span class="line">	&lt;/form&gt;</span><br><span class="line">	&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p><strong>截图如下：</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20201117121051749.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzgyNDEzOQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<hr>
<h5 id="任务4：区间查找，设置了一个success的jsp进行跳转输出列表，请注意SQL代码的正确与初始化列表的先后顺序。"><a href="#任务4：区间查找，设置了一个success的jsp进行跳转输出列表，请注意SQL代码的正确与初始化列表的先后顺序。" class="headerlink" title="任务4：区间查找，设置了一个success的jsp进行跳转输出列表，请注意SQL代码的正确与初始化列表的先后顺序。"></a>任务4：区间查找，设置了一个success的jsp进行跳转输出列表，请注意SQL代码的正确与初始化列表的先后顺序。</h5><p><strong>代码如下：</strong></p>
<p>jgcxServlet,java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.etspace.abc.servlet;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="keyword">import</span> java.sql.ResultSet;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.etspace.abc.bean.Book;</span><br><span class="line"><span class="keyword">import</span> org.etspace.abc.jdbc.DbBean;</span><br><span class="line"><span class="meta">@WebServlet(&quot;/jgcxServlet&quot;)</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;serial&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">jgcxServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">		doPost(request,response);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">		request.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">		response.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">		response.setContentType(<span class="string">&quot;text/html;charset=UTF-8&quot;</span>);</span><br><span class="line">		PrintWriter out = response.getWriter();</span><br><span class="line">		</span><br><span class="line">			<span class="keyword">int</span> Low = Integer.parseInt(request.getParameter(<span class="string">&quot;LowPrice&quot;</span>));</span><br><span class="line">			<span class="keyword">int</span> High = Integer.parseInt(request.getParameter(<span class="string">&quot;HighPrice&quot;</span>));</span><br><span class="line">			</span><br><span class="line">			String sql = <span class="string">&quot;select * from T_BOOK where BPRICE between &quot;</span>+Low+<span class="string">&quot; and &quot;</span>+High;</span><br><span class="line">			<span class="comment">//between实现区间查询</span></span><br><span class="line">			DbBean myDbBean=<span class="keyword">new</span> DbBean();</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				myDbBean.openConnection();</span><br><span class="line">			&#125; <span class="keyword">catch</span> (Exception e1) &#123;</span><br><span class="line">				<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">				e1.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">	        ResultSet rs = myDbBean.executeQuery(sql);</span><br><span class="line">	        List&lt;Book&gt; BookList = <span class="keyword">new</span> ArrayList&lt;Book&gt;();</span><br><span class="line">	        </span><br><span class="line">	        <span class="keyword">try</span> &#123;    </span><br><span class="line">	        <span class="keyword">while</span>(rs.next())&#123;</span><br><span class="line">	        	Book book = <span class="keyword">new</span> Book();</span><br><span class="line">	        	book.setBID(rs.getString(<span class="string">&quot;BID&quot;</span>));</span><br><span class="line">	        	book.setBNAME(rs.getString(<span class="string">&quot;BNAME&quot;</span>));</span><br><span class="line">	        	book.setBAUTHER(rs.getString(<span class="string">&quot;BAUTHER&quot;</span>));</span><br><span class="line">	        	book.setBTYPE(rs.getString(<span class="string">&quot;BTYPE&quot;</span>));</span><br><span class="line">	        	book.setBPRICE(rs.getInt(<span class="string">&quot;BPRICE&quot;</span>));</span><br><span class="line">	        	book.setBAMOUNT(rs.getInt(<span class="string">&quot;BAMOUNT&quot;</span>));</span><br><span class="line">	        	book.setBPUBDATE(rs.getString(<span class="string">&quot;BPUBDATE&quot;</span>));</span><br><span class="line">	        	BookList.add(book);</span><br><span class="line">	        &#125;</span><br><span class="line">	        request.setAttribute(<span class="string">&quot;BookList&quot;</span>, BookList);</span><br><span class="line">	        rs.close();</span><br><span class="line">			myDbBean.closeConnection();</span><br><span class="line">			request.getRequestDispatcher(<span class="string">&quot;/jgcxSuccess.jsp&quot;</span>).forward(request, response);</span><br><span class="line">		&#125; </span><br><span class="line">		<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			out.print(e.toString());			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>jgcx.jsp</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;%@ page language=<span class="string">&quot;java&quot;</span> contentType=<span class="string">&quot;text/html; charset=UTF-8&quot;</span></span><br><span class="line">    pageEncoding=<span class="string">&quot;UTF-8&quot;</span>%&gt;</span><br><span class="line">&lt;!DOCTYPE html PUBLIC <span class="string">&quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;</span> <span class="string">&quot;http://www.w3.org/TR/html4/loose.dtd&quot;</span>&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta http-equiv=<span class="string">&quot;Content-Type&quot;</span> content=<span class="string">&quot;text/html; charset=UTF-8&quot;</span>&gt;</span><br><span class="line">&lt;title&gt;价格区间查询&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">	&lt;div align=<span class="string">&quot;center&quot;</span>&gt;</span><br><span class="line">	&lt;p&gt;价格区间查询&lt;/p&gt;</span><br><span class="line">	&lt;form action=<span class="string">&quot;jgcxServlet&quot;</span> method=<span class="string">&quot;post&quot;</span>&gt;</span><br><span class="line">	请输入您要查询图书的价格:</span><br><span class="line">	&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;LowPrice&quot;</span>/&gt;-</span><br><span class="line">	&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;HighPrice&quot;</span>/&gt;&lt;br&gt;</span><br><span class="line">	&lt;input type=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;确定&quot;</span>/&gt;</span><br><span class="line">	&lt;input type=<span class="string">&quot;reset&quot;</span> value=<span class="string">&quot;重置&quot;</span>/&gt;</span><br><span class="line">	&lt;/form&gt;</span><br><span class="line">	&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>jgcxSuccess.jsp</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;%@ page language=<span class="string">&quot;java&quot;</span> <span class="keyword">import</span>=<span class="string">&quot;java.util.*&quot;</span> pageEncoding=<span class="string">&quot;utf-8&quot;</span>%&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span> = <span class="string">&quot;java.io.IOException&quot;</span>%&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span> = <span class="string">&quot;java.io.PrintWriter&quot;</span>%&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span> = <span class="string">&quot;java.util.ArrayList&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span> = <span class="string">&quot;org.etspace.abc.bean.Book&quot;</span> %&gt;</span><br><span class="line">&lt;%<span class="meta">@page</span> <span class="keyword">import</span>=<span class="string">&quot;java.sql.*&quot;</span> %&gt;</span><br><span class="line">&lt;!DOCTYPE html PUBLIC <span class="string">&quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;</span> <span class="string">&quot;http://www.w3.org/TR/html4/loose.dtd&quot;</span>&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta http-equiv=<span class="string">&quot;Content-Type&quot;</span> content=<span class="string">&quot;text/html; charset=ISO-8859-1&quot;</span>&gt;</span><br><span class="line">&lt;title&gt;查询结果&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">	</span><br><span class="line">	&lt;% ArrayList BookList = (ArrayList)request.getAttribute(<span class="string">&quot;BookList&quot;</span>);</span><br><span class="line">	 </span><br><span class="line">	 %&gt;</span><br><span class="line">	</span><br><span class="line">	&lt;div align=<span class="string">&quot;center&quot;</span>&gt;</span><br><span class="line">	&lt;h2&gt;查询结果&lt;/h2&gt;</span><br><span class="line">	&lt;table align=<span class="string">&quot;center&quot;</span> border = <span class="string">&#x27;1&#x27;</span>&gt;</span><br><span class="line">        	&lt;tr&gt;</span><br><span class="line">            &lt;th&gt;书号&lt;/th&gt;</span><br><span class="line">            &lt;th&gt;书名&lt;/th&gt;</span><br><span class="line">            &lt;th&gt;作者&lt;/th&gt;</span><br><span class="line">            &lt;th&gt;类型&lt;/th&gt;</span><br><span class="line">            &lt;th&gt;价格&lt;/th&gt;</span><br><span class="line">            &lt;th&gt;数量&lt;/th&gt;</span><br><span class="line">            &lt;th&gt;出版日期&lt;/th&gt;</span><br><span class="line">        	&lt;/tr&gt;</span><br><span class="line">        	&lt;%</span><br><span class="line">		    	 <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; BookList.size(); i++)&#123;</span><br><span class="line">			    	 Book book = (Book)BookList.get(i);%&gt;</span><br><span class="line">		    	 	&lt;tr&gt;</span><br><span class="line">		    	 	&lt;td&gt;&lt;%=book.getBID()%&gt;&lt;/td&gt;</span><br><span class="line">		    	 	&lt;td&gt;&lt;%=book.getBNAME()%&gt;&lt;/td&gt;</span><br><span class="line">		    	 	&lt;td&gt;&lt;%=book.getBAUTHER()%&gt;&lt;/td&gt;</span><br><span class="line">		    	 	&lt;td&gt;&lt;%=book.getBTYPE()%&gt;&lt;/td&gt;</span><br><span class="line">		    	 	&lt;td&gt;&lt;%=book.getBPRICE()%&gt;&lt;/td&gt;</span><br><span class="line">		    	 	&lt;td&gt;&lt;%=book.getBAMOUNT()%&gt;&lt;/td&gt;</span><br><span class="line">		    	 	&lt;td&gt;&lt;%=book.getBPUBDATE()%&gt;&lt;/td&gt;</span><br><span class="line">		    	 	&lt;/tr&gt;</span><br><span class="line">		    	 	&lt;%</span><br><span class="line">		    	 &#125;</span><br><span class="line">	    	 </span><br><span class="line">	    	 %&gt;</span><br><span class="line">	   	</span><br><span class="line">	&lt;/table&gt;</span><br><span class="line">	&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p><strong>截图如下：</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20201117121051781.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzgyNDEzOQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<hr>
<h5 id="任务5：修改数据，即确认书号修改数量，保证SQL语句正确，和任务1无异。"><a href="#任务5：修改数据，即确认书号修改数量，保证SQL语句正确，和任务1无异。" class="headerlink" title="任务5：修改数据，即确认书号修改数量，保证SQL语句正确，和任务1无异。"></a>任务5：修改数据，即确认书号修改数量，保证SQL语句正确，和任务1无异。</h5><p><strong>代码如下：</strong></p>
<p>tsxgServlet.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.etspace.abc.servlet;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.etspace.abc.jdbc.DbBean;</span><br><span class="line"><span class="meta">@WebServlet(&quot;/tsxgServlet&quot;)</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;serial&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">tsxgServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">		doPost(request,response);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">		request.setCharacterEncoding(<span class="string">&quot;gb2312&quot;</span>);</span><br><span class="line">		response.setCharacterEncoding(<span class="string">&quot;gb2312&quot;</span>);</span><br><span class="line">		response.setContentType(<span class="string">&quot;text/html;charset=gb2312&quot;</span>);</span><br><span class="line">		PrintWriter out = response.getWriter();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			String BID =  request.getParameter(<span class="string">&quot;BID&quot;</span>);</span><br><span class="line">			String BAMOUNT =  request.getParameter(<span class="string">&quot;BAMOUNT&quot;</span>);</span><br><span class="line">			String sql = <span class="string">&quot;update T_BOOK set BAMOUNT = &quot;</span>+BAMOUNT+<span class="string">&quot; where BID = &#x27;&quot;</span>+BID+<span class="string">&quot;&#x27;&quot;</span>;</span><br><span class="line">			<span class="comment">//out.print(sql);</span></span><br><span class="line">			DbBean myDbBean=<span class="keyword">new</span> DbBean();</span><br><span class="line">			myDbBean.openConnection();</span><br><span class="line">	        <span class="keyword">int</span> n = myDbBean.executeUpdate(sql);</span><br><span class="line">	        <span class="keyword">if</span> (n&gt;<span class="number">0</span>)&#123;</span><br><span class="line">	       		out.print(<span class="string">&quot;图书记录修改成功！&quot;</span>);</span><br><span class="line">	        &#125;</span><br><span class="line">	       	<span class="keyword">else</span> &#123;</span><br><span class="line">	       		out.print(<span class="string">&quot;图书记录修改失败！&quot;</span>);</span><br><span class="line">	       	&#125; </span><br><span class="line">			myDbBean.closeConnection();</span><br><span class="line">		&#125; </span><br><span class="line">		<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			out.print(e.toString());			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>tsxg.jsp</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=gb2312&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.sql.*&quot;</span>%&gt;</span><br><span class="line">&lt;jsp:useBean id=&quot;myDbBean&quot; scope=&quot;page&quot; class=&quot;org.etspace.abc.jdbc.DbBean&quot;&gt;&lt;/jsp:useBean&gt;</span><br><span class="line">&lt;%request.setCharacterEncoding(<span class="string">&quot;gb2312&quot;</span>); %&gt;</span><br><span class="line">&lt;script language=<span class="string">&quot;JavaScript&quot;</span>&gt;</span><br><span class="line"><span class="function">function <span class="title">check</span><span class="params">(theForm)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (theForm.BID.value.length != <span class="number">5</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    alert(<span class="string">&quot;书号必须为5位！&quot;</span>);</span><br><span class="line">    theForm.BID.focus();</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">false</span>);</span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="keyword">if</span> (theForm.BNAME.value == <span class="string">&quot;&quot;</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    alert(<span class="string">&quot;请输入书名！&quot;</span>);</span><br><span class="line">    theForm.BNAME.focus();</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (theForm.BPUBDATE.value == <span class="string">&quot;&quot;</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    alert(<span class="string">&quot;请输入出版日期！&quot;</span>);</span><br><span class="line">    theForm.BPUBDATE.focus();</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (theForm.BAMOUNT.value == <span class="string">&quot;&quot;</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    alert(<span class="string">&quot;请输入数量！&quot;</span>);</span><br><span class="line">    theForm.BAMOUNT.focus();</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (theForm.BPRICE.value == <span class="string">&quot;&quot;</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    alert(<span class="string">&quot;请输入价格！&quot;</span>);</span><br><span class="line">    theForm.BPRICE.focus();</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (theForm.BAUTHER.value == <span class="string">&quot;&quot;</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    alert(<span class="string">&quot;请输入作者！&quot;</span>);</span><br><span class="line">    theForm.BAUTHER.focus();</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (theForm.BTYPE.value == <span class="string">&quot;&quot;</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    alert(<span class="string">&quot;请输入类型！&quot;</span>);</span><br><span class="line">    theForm.BTYPE.focus();</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">false</span>);</span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;&lt;title&gt;图书数量修改&lt;/title&gt;&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div align=<span class="string">&quot;center&quot;</span>&gt;</span><br><span class="line">  &lt;P&gt;图书数量修改&lt;/P&gt;</span><br><span class="line">&lt;form id=<span class="string">&quot;form1&quot;</span> name=<span class="string">&quot;form1&quot;</span> method=<span class="string">&quot;post&quot;</span> action=<span class="string">&quot;tsxgServlet&quot;</span> onSubmit=<span class="string">&quot;return check(this)&quot;</span>&gt;</span><br><span class="line">	&lt;table border=<span class="string">&quot;1&quot;</span>&gt;</span><br><span class="line">	&lt;tr&gt;&lt;td&gt;书号&lt;/td&gt;&lt;td&gt;&lt;input name=&quot;BID&quot; type=&quot;text&quot; id=&quot;BID&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;</span><br><span class="line">&lt;%</span><br><span class="line">		String sql = <span class="string">&quot;select * from BID order by T_BOOK&quot;</span>;</span><br><span class="line">		myDbBean.openConnection();</span><br><span class="line">		ResultSet rs=myDbBean.executeQuery(sql);</span><br><span class="line">%&gt;</span><br><span class="line">	&lt;/td&gt;&lt;/tr&gt;</span><br><span class="line">	&lt;tr&gt;&lt;td&gt;数量&lt;/td&gt;&lt;td&gt;&lt;input name=&quot;BAMOUNT&quot; type=&quot;text&quot; id=&quot;BAMOUNT&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;</span><br><span class="line">	&lt;/table&gt;</span><br><span class="line">	&lt;br&gt;</span><br><span class="line">  	&lt;input name=<span class="string">&quot;submit&quot;</span> type=<span class="string">&quot;submit&quot;</span>  value=<span class="string">&quot;确定&quot;</span> /&gt;</span><br><span class="line">  	&lt;input name=<span class="string">&quot;reset&quot;</span> type=<span class="string">&quot;reset&quot;</span> value=<span class="string">&quot;重置&quot;</span> /&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p><strong>截图如下：</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20201117121051738.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzgyNDEzOQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<hr>
<p><strong>希望能帮到你学习Servlet技术，以及MVC模型的相关知识，感谢观看！</strong></p>
]]></content>
      <categories>
        <category>编程</category>
        <category>Java Web</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Servlet</tag>
        <tag>Java Web</tag>
      </tags>
  </entry>
  <entry>
    <title>三角判断</title>
    <url>/2020/11/17/%E4%B8%89%E8%A7%92%E5%88%A4%E6%96%AD/</url>
    <content><![CDATA[<h1 id="三角判断-基于C语言"><a href="#三角判断-基于C语言" class="headerlink" title="三角判断-基于C语言"></a>三角判断-基于C语言</h1><p><em>目的：此程序是为了判断输入的三角形三边，并判断三角形类型，包括等腰三角形、等边三角形、直角三角形、一般三角形及错值判定。</em></p>
<a id="more"></a>

<p>代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> a, b, c;</span><br><span class="line">   </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入三角形的三边:（用空格隔开，以回车结束）\n&quot;</span>);</span><br><span class="line">    scanf_s(<span class="string">&quot;%f%f%f&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">    <span class="comment">//判断是否满足三角形条件：两边之和是否大于第三边；</span></span><br><span class="line">    <span class="keyword">if</span> (a == <span class="number">0</span> || b == <span class="number">0</span> || c == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;输入边有空值0，错误！\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (a &lt; <span class="number">0</span> || b &lt; <span class="number">0</span> || c &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;输入边有负值，错误！\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (a + b &gt; c &amp;&amp; b + c &gt; a &amp;&amp; a + c &gt; a)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//判断三条边是否相等，三边相等即为等边三角形</span></span><br><span class="line">        <span class="keyword">if</span> (a == b &amp;&amp; a == c)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;等边三角形\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断三角形是否有两天边相等,两边相等即为等腰三角形</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (a == b || a == c || b == c)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;等腰三角形\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断是否有两边的平方和大于第三边的平方，即为直角三角形</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((a * a + b * b == c * c) || (a * a + c * c == b * b) || (b * b + c * c == a * a))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;直角三角形\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//其他情况为一般三角形</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;一般三角形\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//两边之和小于第三边，不能构成三角形</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;三边不能构成三角形\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>总结：最基本的C语言入门程序，对新手可以很好的了解各个运算符的作用以及if函数的运用。</strong></p>
]]></content>
      <categories>
        <category>编程</category>
        <category>C</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>基于C语言的空格统计</title>
    <url>/2020/11/17/%E5%9F%BA%E4%BA%8EC%E8%AF%AD%E8%A8%80%E7%9A%84%E7%A9%BA%E6%A0%BC%E7%BB%9F%E8%AE%A1/</url>
    <content><![CDATA[<h1 id="空格统计小程序-基于C语言"><a href="#空格统计小程序-基于C语言" class="headerlink" title="空格统计小程序-基于C语言"></a>空格统计小程序-基于C语言</h1><p><em>首先，做这个程序的目的，是因为软件工程要求实例Jackson块图的实现，要求如下：</em></p>
<p><em>1）设计程序统计每个记录中空格字符的个数，输出数据的格式是，每读入一个记录（字符串）之后，另起一行打印出这个字符串及其空格数；</em></p>
<p><em>2）最后打印出文件中空格的总个数。</em></p>
<a id="more"></a>



<p><strong>下面列出代码，请参考，如需要求有差异，可自由修改代码以达成目标（此程序经vs测试通过）</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS     <span class="comment">//解决了在vs中使用fopen()函数报错的问题</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;    //调用windows.h头文件实现Sleep()函数，以得到期望的休眠，使得程序不会突兀</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_FILED 128   <span class="comment">//根据估计文字不超过128字节，所以设定为128</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[MAX_FILED];    <span class="comment">//创造数组用来记录文本</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;          <span class="comment">//记录每段文本的空格数</span></span><br><span class="line">    <span class="keyword">int</span> wholecount = <span class="number">0</span>;     <span class="comment">//记录总空格数</span></span><br><span class="line">    <span class="keyword">int</span> len;                <span class="comment">//记录每行字符数</span></span><br><span class="line">    <span class="keyword">char</span> s1[] = <span class="string">&quot;Record 1：How many stages are there in the traditional software development model?&quot;</span>;</span><br><span class="line">    <span class="keyword">char</span> s2[] = <span class="string">&quot;Record 2：After entering the room,walk to the person sitting nearest to you and greet him/her with a “high five”.&quot;</span>;</span><br><span class="line">    <span class="keyword">char</span> s3[] = <span class="string">&quot;Record 3：What are encapsulated into an object?&quot;</span>;</span><br><span class="line">    <span class="keyword">char</span> s4[] = <span class="string">&quot;Record 4：What diagram is the following diagram? Simply describe the meaning of it.&quot;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//使用fopen()函数写入txt文件中的文本</span></span><br><span class="line">    FILE* fpWrite = fopen(<span class="string">&quot;Document.txt&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (fpWrite == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">fprintf</span>(fpWrite, <span class="string">&quot;%s\n&quot;</span>, s1);</span><br><span class="line">    <span class="built_in">fprintf</span>(fpWrite, <span class="string">&quot;%s\n&quot;</span>, s2);</span><br><span class="line">    <span class="built_in">fprintf</span>(fpWrite, <span class="string">&quot;%s\n&quot;</span>, s3);</span><br><span class="line">    <span class="built_in">fprintf</span>(fpWrite, <span class="string">&quot;%s\n&quot;</span>, s4);  </span><br><span class="line">    fclose(fpWrite);</span><br><span class="line">      </span><br><span class="line">    <span class="comment">//使用fopen()函数读取txt文件中的文本</span></span><br><span class="line">    FILE* Readtxt = fopen(<span class="string">&quot;Document.txt&quot;</span>, <span class="string">&quot;r&quot;</span>); <span class="comment">//&quot;r&quot; 以只读方式打开文件，该文件必须存在 | 此文件必须存在于程序根目录下否则无法运行</span></span><br><span class="line">    <span class="keyword">if</span> (Readtxt == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;正在载入程序，统计中请稍等......\n\n&quot;</span>);</span><br><span class="line">    Sleep(<span class="number">5000</span>);    <span class="comment">//调用Sleep()函数休眠五秒</span></span><br><span class="line">       </span><br><span class="line">    <span class="keyword">while</span> (fgets(buf, MAX_FILED, Readtxt) != <span class="literal">NULL</span>)  <span class="comment">//fgets函数功能为从指定的流中读取数据，每次读取一行（配合fopen()使用是实现逐行读取）</span></span><br><span class="line">    &#123;</span><br><span class="line">        len = <span class="built_in">strlen</span>(buf);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; i++)</span><br><span class="line">            <span class="keyword">if</span> (buf[i] == <span class="number">32</span>)   <span class="comment">//判定空格，即空格ASCII码为32</span></span><br><span class="line">                count++;</span><br><span class="line">        wholecount += count;</span><br><span class="line">        buf[len - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;  <span class="comment">//通过判断空字符的结尾来确定换行</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, buf);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;总字数是：%d\n空格字符数是：%d\n&quot;</span>, len - <span class="number">1</span>, count);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;正在计算下一段句子的空格数，请稍等......\n&quot;</span>);</span><br><span class="line">        Sleep(<span class="number">2000</span>);    <span class="comment">////调用Sleep()函数休眠两秒</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;总的空格数为:%d\n&quot;</span>, wholecount);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;文本空格数已全部统计完成，请单击Enter退出程序，谢谢使用此程序^_^\n&quot;</span>);</span><br><span class="line">    fclose(Readtxt);</span><br><span class="line">    system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>此外还有Visio绘制的程序流程图</p>
<p><img src="https://img-blog.csdnimg.cn/20201117142918848.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzgyNDEzOQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<hr>
<p><strong>希望能在读写C语言读写方面对你有所启发和帮助！</strong></p>
]]></content>
      <categories>
        <category>编程</category>
        <category>C</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>狩猎影评</title>
    <url>/2020/11/17/%E7%8B%A9%E7%8C%8E%E5%BD%B1%E8%AF%84/</url>
    <content><![CDATA[<h1 id="狩猎"><a href="#狩猎" class="headerlink" title="狩猎"></a>狩猎</h1><h3 id="秋天萧瑟的气氛，狩猎的季节，猎物却是一个老好人"><a href="#秋天萧瑟的气氛，狩猎的季节，猎物却是一个老好人" class="headerlink" title="-秋天萧瑟的气氛，狩猎的季节，猎物却是一个老好人"></a>-秋天萧瑟的气氛，狩猎的季节，猎物却是一个老好人</h3><p>-节选自知乎个人创作</p>
<p><img src="https://img-blog.csdnimg.cn/2020111714310397.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzgyNDEzOQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p><em>一部好的电影会让观众在观看时和观看后陷入深深的思考，不论思考的是什么，或是伦理道德，亦或是错综复杂的剧情和演员精湛的演技，也可以是勾起你深埋于心底的一段回忆。</em></p>
<a id="more"></a>

<p><img src="https://img-blog.csdnimg.cn/20201117121107735.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzgyNDEzOQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p><em>《狩猎》就是这样一部影片，但是看过一遍后我不想再重温一遍，因为这部影片给我带来了深深的压抑感，这种压抑深入心中，使我无法对电影内涵做更深一步的思考和探索。</em></p>
<p><img src="https://img-blog.csdnimg.cn/20201117121107789.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzgyNDEzOQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p><em>看完《狩猎》，我不自觉的想到了韩国电影《熔炉》，同样的压抑感，同样的结局。你认为好人就该得到好报吗，因果循环吗？你错了，这两部电影都揭示出“坏人“的下场会比好人要好，吃亏的也总是心地善良的人。也许正是因为这两部电影共同的压抑感和带来的反思，让我把这两部电影串联在一起。</em></p>
<p><img src="https://img-blog.csdnimg.cn/20201117121107780.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzgyNDEzOQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p><em>《狩猎》的主要剧情梗概是这样的：男主卢卡斯是一家幼儿园的教师，倍受同事和孩子们的喜爱。但有一个叫卡拉的小女孩在玩游戏的过程中对卢卡斯示好却遭到拒绝。为了报复卢卡斯，卡拉将卢卡斯描述成一个暴露性器官的变态，让他背负了猥亵儿童的罪名，进而成为了小镇排挤的对象。卢卡斯的生活和在小镇的地位发生了巨大的改变，好友、女友、前妻都不在信任他，自己的宠爱的狗也因他而死，儿子被小镇的人侮辱。尽管卡拉告诉了同是卢卡斯朋友的父亲真相，卢卡斯的罪名也不成立，但周围的人已经不能像以前一样对待他，小镇的人们戴上了伪善的面纱，在结尾的一场狩猎中，有人在暗地里开枪差点把卢卡斯打死，电影戛然而止…</em></p>
<p><em>这部影片的关键人物无疑是卡拉，没有她的谎言，也就没有之后发生的故事。谎言的背后一定有一个原因，也许是她对卢卡斯的爱慕，也许是她早熟的性格，但在我看来却是她家庭的教育和环境。从电影一开始对卡拉家庭的描述可以看出父母对她的管教是非常宽松的，以致于她自己乱跑在超市迷了路，她的父母都没有去寻找，只是认为她出去玩了。同时小镇相对封闭的环境却造就了居民之间相对开放的态度，从卢卡斯能随意的在卡拉家的壁橱中拿出杯子喝水和卡拉哥哥的朋友给卡拉看相片都能看出，这也给卡拉父亲有卢卡斯家的钥匙打下理论基础。所以如此典型的成长环境给了卡拉非常宽松的空间与自由，这与《熔炉》中封闭的学校环境相类似。</em></p>
<p><em>从电影中我们可以看出，卡拉的父母在表达情感的时候都是非常直接的，相互表达爱意时会在卡拉面前接吻，出现矛盾时会大声争吵，这势必会对卡拉成长中的行为和内心产生巨大的影响。首先，卡拉吻卢卡斯的行为很可能是跟父母学的，孩子在成长的过程中总是不断的模仿学习，学习的最主要方式就是模仿。父母在孩子看到一些不属于这个年龄段的行为时应该做出引导，解释行为代表的意义。但是，小镇和家庭宽松的环境无法让卡拉得到父母及时的教育，才让卡拉做出不合适的举动。与此同时，父母在孩子面前的争吵也使得孩子的内心受到极大的影响，这也间接助使卡拉的报复心增长。在影片中，卡拉没有很好的管理好自己的感情，选错了给予感情的对象。但对于卡拉来说，真正对他好的也许只有卢卡斯一个人，她没有其他选择，才酿成了这种局面。</em></p>
<p><em>这部电影看完带来的最直观的感受是一种无法发泄的负能量，一种深沉的压抑感，这也许是我对这部电影的另类喜爱吧，就像练琴时弹错了旋律老师就会打你，因为疼了，你才会真正记住。</em></p>
<p><img src="https://img-blog.csdnimg.cn/20201117121107744.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzgyNDEzOQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>PS：强烈推荐男主角扮演者麦斯·米克尔森，丹麦男神，精湛的演艺把《狩猎》这部影片撑起，在困境中的绝望，那种无助的眼神真的是天生的演员才能做到。</p>
]]></content>
      <categories>
        <category>影评</category>
      </categories>
      <tags>
        <tag>Hide</tag>
        <tag>影评</tag>
      </tags>
  </entry>
  <entry>
    <title>辛德勒的名单影评</title>
    <url>/2020/11/17/%E8%BE%9B%E5%BE%B7%E5%8B%92%E7%9A%84%E5%90%8D%E5%8D%95%E5%BD%B1%E8%AF%84/</url>
    <content><![CDATA[<h1 id="辛德勒的名单"><a href="#辛德勒的名单" class="headerlink" title="辛德勒的名单"></a>辛德勒的名单</h1><h3 id="暗黑中的一丝曙光"><a href="#暗黑中的一丝曙光" class="headerlink" title="暗黑中的一丝曙光"></a>暗黑中的一丝曙光</h3><p><img src="https://img-blog.csdnimg.cn/20201117121115471.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzgyNDEzOQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p><strong>——Whoever saves one life ,saves the world entire .*</strong></p>
<p><strong><em>（当你挽救了一条生命就等于挽救了全世界。）\</em></strong></p>
<a id="more"></a>

<hr>
<p><em>Schindler’s List（辛德勒的名单）是根据澳大利亚小说家托马斯·肯尼利所著的《辛德勒的名单》改编而成，由导演史蒂文·斯皮尔伯格执导的一部电影。影片再现了德国企业家奥斯卡·辛德勒与其夫人埃米莉·辛德勒在第二次世界大战期间倾家荡产保护了1200余名犹太人面遭法西斯杀害的真实事件。</em></p>
<p><strong><em>如果你尊重一个人，如果你尊重生命，在那个时候，你记住那些名字，并拯救他们。辛德勒的行为，是荒谬的世界中，人性的反弹。他无法超越这荒谬吗，但他为人类争取回了良知。如果没有这样的良知，我想人类面对自身，也会感到愧疚。\</em></strong></p>
<p><img src="https://img-blog.csdnimg.cn/20201117121115486.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzgyNDEzOQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p><em>这部电影用黑白画面给人以历史的沧桑感，营造出一种类似纪录片的氛围。整部电影的主旨是和平和救赎，它用清晰的条理给观众展现了一个名叫辛德勒的德国军火商由一开始的贪图一己私利到最后发自内心的想要拯救每个受法西斯迫害的犹太人这一转变过程。</em></p>
<p><img src="https://img-blog.csdnimg.cn/20201117121115317.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzgyNDEzOQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p><em>首先，整部电影最关键的是人性的救赎。那么，什么是人性？</em></p>
<p><strong><em>从字面上看，人性应该是长期聚居的人们通过长时间的口耳传承达成的一种对社会行为的集体认知和行为指导。通俗易懂的说，就是我们的道德准则。所以人性并不是电影中遥不可及的大道理，惩恶扬善，助弱扶残，这些都是人性最直接的表现。同样的，人性并非是某些人独有的属性，而是每个人心中的潜意识。\</em></strong></p>
<hr>
<p><em>以下便是我对于电影关于人性的解读：</em></p>
<h2 id="音乐部分"><a href="#音乐部分" class="headerlink" title="音乐部分"></a><strong>音乐部分</strong></h2><p><em>当法西斯举起屠刀残杀无辜的犹太民众时，他们无情冷酷的脸庞将法西斯独有的残暴疯狂展现的一览无遗，我忘不了被纳粹追杀躲藏的妇孺，忘不了纳粹士兵在发现幸存犹太人后一拥而上的扫射，此时画面切换到一个绅士般的纳粹军官坐在犹太人家中的钢琴前拨弄琴键，莫扎特悦耳的乐章伴随着爆豆般的枪声犹如死神的歌声，导演熟练的运用音乐以一种看似荒诞的方式来讽刺纳粹的残暴与变态。</em></p>
<p><img src="https://img-blog.csdnimg.cn/20201117121115462.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzgyNDEzOQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<hr>
<h2 id="剧情部分"><a href="#剧情部分" class="headerlink" title="剧情部分"></a><strong>剧情部分</strong></h2><p><em>当辛德勒和妻子骑着马在山上目睹了城市中无辜的犹太民众正在被德国士兵大肆屠杀的野兽行为，当他在混乱的人群中看到那个穿着红衣服的小女孩慌张奔跑，他的内心顿悟了——在这乱世中，就算赚取再多的金钱也换不来人命;没有人性，再奢华再富有也终究只是一具行尸走肉·。影片用了很大篇幅交代辛德勒内心的转变，例如他开始利用自己积攒的人脉为工厂中的犹太工人谋取一线生机；在他的生日舞会上不顾他人的眼光亲吻了前来祝贺的犹太女士。</em></p>
<p><img src="https://img-blog.csdnimg.cn/20201117121115445.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzgyNDEzOQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h2 id="色彩部分"><a href="#色彩部分" class="headerlink" title="色彩部分"></a><strong>色彩部分</strong></h2><p><em>当电影即将结尾时，辛德勒看见纳粹士兵挖出那些在集中营被屠杀的人们的尸体，镜头给到身穿红色长裙女孩的身影躺在尸体堆中等待火花，小女孩的尸体早已腐烂，辛德勒的内心再次颤动。由于整部电影色彩为黑白，导演对小女孩的身影单独运用局部色相，使得画面具有冲击感。在黑白的尸体中，那一抹红显得异常刺眼，在这黑暗的时代，童真被无情淹没，希望被冷酷摧毁，更激起了观众对于人性的思考。</em></p>
<p><img src="https://img-blog.csdnimg.cn/20201117121115397.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzgyNDEzOQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p><em>最后辛德勒终于明白了人性的意义，明白了名单意味着什么，该去做什么，他用尽自己的每一份力量，只为多救一人。这与电影开头那个唯利是图的军火商截然不同，辛德勒完成了人性的蜕变，这样的背景给了辛德勒自我救赎的机会，让他明白了生命的意义。后辛德勒终于明白了人性的意义，明白了名单意味着什么，该去做什么，他用尽自己的每一份力量，只为多救一人。这与电影开头那个唯利是图的军火商截然不同，辛德勒完成了人性的蜕变，这样的背景给了辛德勒自我救赎的机会，让他明白了生命的意义。</em></p>
<p><em>最后辛德勒终于明白了人性的意义，明白了名单意味着什么，该去做什么，他用尽自己的每一份力量，只为多救一人。这与电影开头那个唯利是图的军火商截然不同，辛德勒完成了人性的蜕变，这样的背景给了辛德勒自我救赎的机会，让他明白了生命的意义。</em></p>
<p><em>战争中虽然有人性曙光的闪耀，但更多的是黑暗与绝望。对于战争，以平民百姓的角度，无论属于哪一方，都没有真正的胜者。</em></p>
<p><img src="https://img-blog.csdnimg.cn/20201117121115395.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzgyNDEzOQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p><strong>Today is history. Today will be remembered. Years from now the young will ask with wonder about this day. Today is history and you are part of it.</strong></p>
<p><strong><em>身在和平年代无法体会战争年代的绝望，我们该庆幸自己出生在这个时代，愿世间没有战争。\</em></strong></p>
]]></content>
      <categories>
        <category>影评</category>
      </categories>
      <tags>
        <tag>Hide</tag>
        <tag>影评</tag>
      </tags>
  </entry>
  <entry>
    <title>睡前故事-相遇</title>
    <url>/2020/11/16/%E7%9D%A1%E5%89%8D%E6%95%85%E4%BA%8B-%E7%9B%B8%E9%81%87/</url>
    <content><![CDATA[<h1 id="相遇"><a href="#相遇" class="headerlink" title="相遇"></a>相遇</h1><p>骑士生活在m王国，有一天m王国的国王Arthur在外征战时被俘，但因为敌国的君主看到了Arthur的乐观与不屈，决定放了他，但抛给他一个难题“女人真正想要的是什么？”，若回答出来则可以获得自由，给予了一年期限。</p>
<p>于是Arthur开始向身边的人询问这个问题，母亲、妹妹、牧师……但没人能给出满意的答案。</p>
<a id="more"></a>

<p>有一位智者找到Arthur，并告诉他，城堡外的森林里有一位女巫，但性格刁蛮古怪，要求离谱。</p>
<p>眼看期限将至，无可奈何的Arthur找到了女巫，女巫答应回答他的问题，但条件是要和骑士结婚。</p>
<p>看着眼前丑陋不堪，散发着难闻气味的女巫，再看看跟自己多年挚友，威武高大的骑士。Arthur拒绝了，他不忍看到自己为了自由而牺牲兄弟。</p>
<p>骑士知道这个消息后，毅然决然地对Arthur说：”我愿意娶她，为了您和国家。“</p>
<p>于是婚礼被公诸于世，而Arthur也得到了问题的答案”女人真正想要的，是主宰自己的命运。”</p>
<p>每个人都知道女巫说出的答案是真理，毫无疑问Arthur恢复了自由。</p>
<p>婚礼上，女巫没有形象的行为举止令Arthur觉得恶心并忍不住哭泣，但骑士却一如既往的谦和。</p>
<p>新婚之夜，骑士不顾别人的阻拦毅然决然地走进新房，准备面对一切，然而一个从未见过面的绝世美女却躺在了他的床上，女巫说：“我在一天的时间里，一半是丑陋的女巫，一半是倾城的美女，骑士，你想我白天变成美女还是晚上变成美女？”</p>
<p>骑士回答道：“既然你说女人真正想要的是主宰自己的命运，那么就由你自己决定吧！”</p>
<p>女巫终于热泪盈眶，“我选择白天夜晚都是美丽的女人，因为我爱你！”</p>
]]></content>
      <categories>
        <category>睡前故事</category>
      </categories>
      <tags>
        <tag>Hide</tag>
        <tag>睡前故事</tag>
        <tag>骑士与女巫</tag>
      </tags>
  </entry>
  <entry>
    <title>睡前故事-记忆森林</title>
    <url>/2020/11/16/%E7%9D%A1%E5%89%8D%E6%95%85%E4%BA%8B-%E8%AE%B0%E5%BF%86%E6%A3%AE%E6%9E%97/</url>
    <content><![CDATA[<h1 id="记忆森林"><a href="#记忆森林" class="headerlink" title="记忆森林"></a>记忆森林</h1><p>自从上次击败巨龙以后，一起探险的女巫和骑士一直牵着手从未放开过。</p>
<p>经过几天跋涉，他们走进了一片森林中，这个森林中的大树都如参天般，从他们的视角只能看到一片绿色的灌木和草坪，颜色万千、大小不一的花朵。</p>
<a id="more"></a>

<p>但他们进入森林后，从天上看去，仿佛森林像一个移动的迷宫，一棵棵树如同一道道墙在不断移动，刚才的进口已经被封上。</p>
<p>骑士在进来时，在第一颗树上绑上了红色的丝带，但此时此刻，那条红色的丝带却出现在了眼前，骑士警觉地回头说：“女巫，小心，这片森林有问题。”女巫用魔法棒在巫师帽里召唤出一只信鸽，信鸽飞出大树包围的范围，提供给女巫的是移动迷宫的奇异景象。女巫将见到的情景告诉骑士，并用魔法生成了一个红色的细绳在两个人的手腕连着。</p>
<p>这时奇异的事情发生了，一只矮矮的小精灵，头上长着兔子耳朵，出现在了两人面前，并说道：“这个森林是森林之神留下的记忆森林，只有正直、善良和懂得爱的人才能离开。你们必须经过考验才能离开，考验为期三天，如果你们还记得彼此，那么考验通过。假如失败，你们将失去一切记忆，并永远留在这个森林。”说完，便离开了两人的视野。</p>
<p>天暗下来了，两人熟练的搭起了帐篷，骑士钉好地钉，女巫将帐篷展开。女巫用魔法升起了篝火，因为森林的遮挡看不到星星，这一晚两个人都在帐篷里，骑士警戒着，女巫则进入了梦乡。梦里，女巫梦到了之前的一切经历，童年、少年和青年遇到骑士后的一点一滴。</p>
<!-- more -->

<p>第二天，天蒙蒙亮，女巫醒了，轻声嘀咕“我是谁？我在哪？”。</p>
<p>旁边的骑士彻夜未眠，一直守护着女巫，他想抱过去，但随之而来的是一声清脆的巴掌声。“流氓！你干什么？”骑士一脸懵逼地看向女巫，“是我呀，骑士。陪你一起冒险的骑士。”</p>
<p>“骑士？那我是谁？”“你是女巫，我们一起探险一年多了。天，可能是森林的考验。”</p>
<p>“什么考验？”“我们得互相记得曾经的事才能离开这片森林。”</p>
<p>“饿了吧，这是留下的干粮，你吃了吧”说完，骑士拿出了包好的干粮。</p>
<p>“不吃，万一你在里面下毒怎么办…”骑士无奈地掰下一小块吃了一口。</p>
<p>“走吧，得出去找找办法，让你恢复记忆。”骑士走在前面，女巫跟在后面，向森林的深处进发。</p>
<p>走了一段时间，他们终于走入了森林的中心地区，整个森林围绕着一个湖，湖中心有一个小树包裹着的小岛。一时之间，他们无法进入湖心岛，而且湖中还有鳄鱼的存在，冒出的头已经说明了它们危险的存在。骑士只能把帐篷扎在湖的旁边，他坚信湖心岛一定有解决的线索或者方法。骑士开始砍伐一些树枝，制作船只。女巫直直地看着眼前这个男人，却什么也想不到，但心里却有一种特殊的感觉。</p>
<p>骑士造船直到下午才完成，他自己一个人乘着小船，慢慢地划桨向湖心岛进发，他叮嘱了女巫留意他的情况，稍有不对立刻用系在船上的绳子把他拉回来。一开始，湖面安静，一切顺利，但进行到旅程的三分之一时，几只鳄鱼朝着小船游来，骑士拔出长剑，准备迎战。鳄鱼下一刻突然地跃出水面，直扑骑士而去，但骑士用剑挑飞扑来的鳄鱼，不想伤及动物的他只能被动的对付着鳄鱼。但更糟糕的是，在旅程的三分之二时，水面形成了一个漩涡，说明水下有强大的吸力在把所有东西往里拉，鳄鱼也不见了，但小船却无法前进，被牢牢的吸住，一点一点的朝着漩涡中心移动，骑士赶忙叫女巫拉绳子，自己借小船踏了一步，抓住绳子回到了岸边。</p>
<p>天色逐渐变黑，篝火再次升起，这次骑士识相的没有进帐篷，女巫一个人在帐篷脑袋空空的，想想起什么却又想不起来，骑士则一如既往的像一块石头一样，守护着女巫。</p>
<p>又过了一晚，第三天，两人都是整晚没有休息，骑士在守护，女巫在努力回忆着什么。</p>
<p>第三天清晨，鸟鸣声响彻森林，女巫仿佛之间记起了一些魔法，其中就包括飞行法术。走出帐篷，对骑士说：“我能送你过去，我记起飞行法术了。”骑士放心的将后背交给女巫，但女巫施法后却自己飞了起来直奔湖心岛而去，内心强烈渴求找回记忆，和对骑士莫名的感觉让她想自己去找寻答案。“诶，别走！”骑士望着渐渐飞远的女巫只能重新想办法渡湖。</p>
<p>女巫进入湖心岛，看到整座岛屿都围绕着一颗古树，这棵古树的年纪怕是有女巫的几十倍大。古树上结着许多果实，红的、绿的、蓝的，各式各样，奇妙的是每个果实上都如同屏幕一般播放着女巫的一段记忆。小时戴着比自己还高的巫师帽跟着妈妈学习魔法、长大自己一个人在外面闯荡帮助人们、和骑士一起战胜巨龙……这些记忆存在于一个个果实上。树的周围有一层绿色的结界保护，女巫尝试着用手碰了一下，刺骨的剧痛使女巫发出叫声并连忙将手收回。骑士听到女巫的叫声，放下手中的树枝，直接跳下了湖，朝对面游去。</p>
<p>骑士一边用长剑击退朝他游来的鳄鱼，一边用尽全力抵抗着漩涡的吸力。女巫正在尝试用自己的身躯越过结界，但难忍的剧痛让她一次次后退，又一次次前进，发出低沉的叫声。骑士已经担心到了极点，拼了全力终于抵达了对岸。这一次，女巫积攒了全部的力气，朝着结界冲了过去，骑士赶忙在身后追着，但被结界撞了回来。女巫过去了，拖着在这些年的冒险中收到的疼痛总和还要多的痛。</p>
<p>女巫摘下一颗果实，吃了下去，一段儿时的记忆立马浮现在脑海之中，紧接着的是一段段快乐的回忆，快乐让她嘴角带着笑。紧接着是骑士曾经死去的回忆，这些痛苦的记忆，吃下去后，女巫不停的哭泣落泪，抑制不了心中的悲伤。骑士硬扛着结界的痛苦，迈过去了半个身子，女巫不断地吃下了果实，酸甜苦辣的回忆不断冲击着脑海。等到女巫吃下最后一个果子，骑士才进入了结界内，女巫的脸绯红着，最后的果子是关于骑士的回忆，曾经的点点滴滴，牵着的手、落日下的拥抱和誓死的保护。女巫抱住了冲来的骑士，他们完成了最后的考验，恢复记忆。</p>
<p>森林之神从树中走出，缓缓的向着两人靠近。“恭喜你们，两个好孩子，你们是近十年来通过的唯一一对恋人。互相的爱让骑士能击退鳄鱼、逃出漩涡并进入结界，让女巫能进入结界、吃下记忆果实。孩子们，我祝福你们长长久久，爱能让你们突破任何艰难险阻。这是森林的出口，再见了，孩子们。”说罢，指向两人身后的丛林，丛林仿佛收到了召唤，分裂出一道缝隙。</p>
<p>骑士和女巫牵着手，向森林之神点头，并向出口走去，踏出一步，便回到了来时的石路上。</p>
<p>这次的经历让两人更加爱并信任彼此，考验的收获是手腕的红绳更加牢固了。</p>
]]></content>
      <categories>
        <category>睡前故事</category>
      </categories>
      <tags>
        <tag>Hide</tag>
        <tag>睡前故事</tag>
        <tag>骑士与女巫</tag>
      </tags>
  </entry>
  <entry>
    <title>睡前故事-骑士与恶龙</title>
    <url>/2020/11/16/%E7%9D%A1%E5%89%8D%E6%95%85%E4%BA%8B-%E9%AA%91%E5%A3%AB%E4%B8%8E%E6%81%B6%E9%BE%99/</url>
    <content><![CDATA[<h1 id="骑士与恶龙"><a href="#骑士与恶龙" class="headerlink" title="骑士与恶龙"></a>骑士与恶龙</h1><p>今天是骑士与女巫在外冒险的第397天了，他们并着肩走在一望无垠的大草原上，微风拂面，已入正暑的气温略显炎热，落下的夕阳犹如一个火球一般映照着大地。</p>
<p>一路上，这对默契的伙伴有说有笑，但远处却有一只巨大的瞳孔正在盯着他们…</p>
<p>走到河边，太阳已经落下，两人熟练的扎好帐篷、升起篝火。远处低沉的狼嚎声在广阔的草原显得额外响亮，但下一瞬却又突然中止，似乎在预示着什么。</p>
<p>两个人躺在草地上，抬头看着星星，诉说着这一路走来的经历-生与死的战斗、默契的配合和每天看星星的习惯…自从上次打败年以后，这对搭档已经经历了许多有趣但又危险的冒险。</p>
<p>正当两个人各自回帐篷，准备休息时，一声巨大的气流共振声传来，一双巨大的瞳孔在空中盯着地上的两人，下一刻便直接俯冲向两人。</p>
<a id="more"></a>

<p>两人敏捷的躲过这一击，通过篝火的映照看到了一只巨大的黑色巨龙，骑士赶忙拔出剑鞘内的长剑，举起盾站在女巫面前，女巫则举起魔法棒护在骑士身后，多次的战斗让他们锻炼出了非常难得的默契。</p>
<p>巨龙悬停在空中，双方就这么僵持着，巨龙开口，发出低沉又巨大的声音：“今天你们只能走一个人，另一个将永远的留在这里。”</p>
<p>“还没试过你怎么知道只能走一个人…”骑士回应。</p>
<p>巨龙再一次冲向骑士，女巫举起魔法棒，念着咒语，瞬间一道屏障展开在两人面前，但巨龙的撞击令这一道隐形的屏障碎裂，虽然延缓了一下巨龙的速度，但巨大的龙爪伴随着空气撕裂的低鸣拍打而来，骑士用长剑用力劈向巨爪，一瞬间巨大的冲击将两边都震开一段距离，骑士看着手中颤抖的长剑，虎口已经渗出鲜血。</p>
<p>“看来今天不好对付了。如果一会形势还是这么差，我掩护你先走。”骑士对着女巫讲。</p>
<p>“不！要走一起走，要死留下来一起死。”女巫不满的说道。</p>
<p>骑士再次咬牙，握紧手中的长剑，巨龙再次直直地冲向骑士，女巫用魔法砸出一个火球。龙爪丝毫没有减速直接撞向火球，虽然被烫伤但速度不减地砸向骑士，骑士左手用盾挡下巨爪，并用右手的长剑回击，砍下了数块鳞片，但自己被震飞出去。</p>
<p>几次迂回，女巫耗尽了法力，对战两方都背负了各自的信仰，巨龙只为了自己嗜血的本性，骑士为了他身后的女孩，现在双方都遍体鳞伤，巨龙翅膀和身体都布满了长剑划开的口子，骑士也浑身带有血渍。巨龙沉重的喘息，心脏像汽车引擎跳动着，黄色的巨瞳虽然浑浊但仍然发出巨大的威压。</p>
<p>骑士知道这是一场只有一个人站着的战斗，他想起了去世的导师留下的剑谱，最后一条禁忌之术是用自己的血来填充长剑的杀意，但副作用却会迷失自己。但此时已经无法思考，只能使用禁忌之术，划开自己的手腕，鲜血一滴滴的滴到长剑上，长剑逐渐变成红色，骑士的瞳孔也逐渐变红，在最后一刻说：“女巫，如果我战死了，你赶紧逃离这里，如果我赢了，杀了我。”</p>
<p>女巫失去了法力，只能在一旁看着这个场景，内心也在纠结着如何拯救骑士。</p>
<p>随着仪式的完成，骑士仿佛蜕变成了血色覆盖的杀神。骑士挥出一击，血色的剑刃和巨龙的翅膀撞击，下一瞬巨龙的翅膀像蛋糕一样被切成两半，但龙爪也在骑士身上留下了三道血痕。</p>
<p>再次经历几次交手，巨龙已经走到了生命的尽头，骑士也在死撑着目前的状态，巨龙深知自己生命受到巨大的威胁，拼出生命的全部力量，从口中吐出龙之炎息，骑士将头举过头顶，用尽全力劈下，在龙炎中劈出了一道缺口，直取巨龙的头颅而去，随着最后一声哀鸣，巨龙倒下了。</p>
<p>骑士也用剑抵着大地，单膝跪下，“我赢了，女巫，杀了我吧，我不知道什么时候会失控。我一直都很爱你，很爱很爱你，不能陪你到老了，对不起…”</p>
<p>女巫红着眼眶，“我不可能做这样的事，我们会一直走下去直到终老。”</p>
<p>说完，骑士背后长出了一对黑色的翅膀，“屠龙者，最后终将变成恶龙。”典故所记载的却是事实，这是巨龙的诅咒。下一刻，骑士抓住了女巫的脖子，龙的嗜血此时控制了骑士，但又松开了，内心仅存的对女巫的爱和人性暂时抑制了龙性，骑士举起长剑，“我知道你下不了手，这是我最后能救你的方法了，对不起。”</p>
<p>骑士将长剑刺入了自己的心脏，嘴角带着笑，缓慢的倒下了。</p>
<p>“骑士，不！”女巫嘶吼着。一滴滴泪水滴落在骑士的伤口上，悄无声息的变化发生在骑士身上，伤口正在痊愈，肤色也从雪白逐渐恢复血色。</p>
<p>女巫没有想到的是，在她离开自己的母亲也是她的女巫导师时，母亲没有告诉她女巫带有最真挚爱的眼泪是能治愈一切的物品，但一生只能生效一次。</p>
<p>骑士缓慢的睁开了眼睛，看着女巫哭泣，“我还没死呢…”</p>
<p>女巫不敢相信眼前的一切，紧紧的抱住骑士，骑士抚摸着女巫的头，也许这就是天意吧，骑士不明所以的恢复了。</p>
<p>这一天好漫长，两人相互抱着，第二天的朝阳升起…</p>
]]></content>
      <categories>
        <category>睡前故事</category>
      </categories>
      <tags>
        <tag>Hide</tag>
        <tag>睡前故事</tag>
        <tag>骑士与女巫</tag>
      </tags>
  </entry>
  <entry>
    <title>Servlet</title>
    <url>/2020/11/16/Servlet/</url>
    <content><![CDATA[<p><strong><em>Welcome to my Blog! This is my first article. The following are my study notes for learning Servlet.</em></strong></p>
<h1 id="Reasonable-use-of-SQL-statements"><a href="#Reasonable-use-of-SQL-statements" class="headerlink" title="Reasonable use of SQL statements"></a>Reasonable use of SQL statements</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String sql = <span class="string">&quot;insert into T_BOOK(BID,BNAME,BAUTHER,BTYPE,BPRICE,BAMOUNT,BPUBDATE)&quot;</span>;</span><br><span class="line">sql=sql+<span class="string">&quot; values(&#x27;&quot;</span>+BID+<span class="string">&quot;&#x27;,&#x27;&quot;</span>+BNAME+<span class="string">&quot;&#x27;,&#x27;&quot;</span>+BAUTHER+<span class="string">&quot;&#x27;,&#x27;&quot;</span>+BTYPE+<span class="string">&quot;&#x27;,&#x27;&quot;</span>+BPRICE+<span class="string">&quot;&#x27;,&quot;</span>+BAMOUNT+<span class="string">&quot;,&#x27;&quot;</span>+BPUBDATE+<span class="string">&quot;&#x27;)&quot;</span>;</span><br><span class="line"></span><br><span class="line">String sql = <span class="string">&quot;update T_BOOK set BAMOUNT = &quot;</span>+BAMOUNT+<span class="string">&quot; where BID = &#x27;&quot;</span>+BID+<span class="string">&quot;&#x27;&quot;</span>;</span><br><span class="line"></span><br><span class="line">String sql = <span class="string">&quot;select * from T_BOOK where BNAME like &#x27;%&quot;</span>+input+<span class="string">&quot;%&#x27;&quot;</span>;</span><br><span class="line"></span><br><span class="line">String sql = <span class="string">&quot;select * from T_BOOK where BPRICE between &quot;</span>+Low+<span class="string">&quot; and &quot;</span>+High;</span><br></pre></td></tr></table></figure>

<p><em>Proficiency in the SQL language is a prerequisite for implementing various operations through the servlet link to the database.</em></p>
<p><em>Mastering the most basic insert, update and conditional search statements can achieve most database operations.</em></p>
<hr>
<h1 id="Connect-to-the-database-via-JDBC"><a href="#Connect-to-the-database-via-JDBC" class="headerlink" title="Connect to the database via JDBC"></a>Connect to the database via JDBC</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class.forName(<span class="string">&quot;com.microsoft.sqlserver.jdbc.SQLServerDriver&quot;</span>).newInstance();</span><br><span class="line">			String url=<span class="string">&quot;jdbc:sqlserver://localhost:1433;databaseName=?&quot;</span>;</span><br><span class="line">			String user=<span class="string">&quot;user&quot;</span>;</span><br><span class="line">			String password=<span class="string">&quot;password&quot;</span>;</span><br><span class="line">			conn=DriverManager.getConnection(url, user, password);</span><br></pre></td></tr></table></figure>

<p><em>The project adopting MVC mode is to use JDBC technology to connect to the database.</em></p>
<p><em>Please add sqljdbc.jar in the lib folder of WEB-INF to ensure that JDBC can be successfully called.</em></p>
<hr>
<h1 id="Use-of-Servlet-annotations"><a href="#Use-of-Servlet-annotations" class="headerlink" title="Use of Servlet annotations"></a>Use of Servlet annotations</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/Classname&quot;)</span></span><br></pre></td></tr></table></figure>

<p><em>Using Servlet annotations can eliminate extra comments in web.xml, making the program more concise and portable.</em></p>
<hr>
<p><strong>Thank you for reading, I hope these tips can help you learn Servlet better.</strong></p>
]]></content>
      <categories>
        <category>编程</category>
        <category>Java Web</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Servlet</tag>
        <tag>Java Web</tag>
      </tags>
  </entry>
</search>
